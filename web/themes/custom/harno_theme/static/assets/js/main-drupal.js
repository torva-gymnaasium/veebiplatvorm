!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.moment=t()}(this,function(){"use strict";var e,i;function c(){return e.apply(null,arguments)}function o(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function u(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function l(e){return void 0===e}function h(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function d(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function f(e,t){var n,s=[];for(n=0;n<e.length;++n)s.push(t(e[n],n));return s}function m(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function _(e,t){for(var n in t)m(t,n)&&(e[n]=t[n]);return m(t,"toString")&&(e.toString=t.toString),m(t,"valueOf")&&(e.valueOf=t.valueOf),e}function y(e,t,n,s){return Tt(e,t,n,s,!0).utc()}function g(e){return null==e._pf&&(e._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),e._pf}function v(e){if(null==e._isValid){var t=g(e),n=i.call(t.parsedDateParts,function(e){return null!=e}),s=!isNaN(e._d.getTime())&&t.overflow<0&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.weekdayMismatch&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(s=s&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return s;e._isValid=s}return e._isValid}function p(e){var t=y(NaN);return null!=e?_(g(t),e):g(t).userInvalidated=!0,t}i=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,s=0;s<n;s++)if(s in t&&e.call(this,t[s],s,t))return!0;return!1};var r=c.momentProperties=[];function w(e,t){var n,s,i;if(l(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),l(t._i)||(e._i=t._i),l(t._f)||(e._f=t._f),l(t._l)||(e._l=t._l),l(t._strict)||(e._strict=t._strict),l(t._tzm)||(e._tzm=t._tzm),l(t._isUTC)||(e._isUTC=t._isUTC),l(t._offset)||(e._offset=t._offset),l(t._pf)||(e._pf=g(t)),l(t._locale)||(e._locale=t._locale),0<r.length)for(n=0;n<r.length;n++)l(i=t[s=r[n]])||(e[s]=i);return e}var t=!1;function M(e){w(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===t&&(t=!0,c.updateOffset(this),t=!1)}function k(e){return e instanceof M||null!=e&&null!=e._isAMomentObject}function S(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function D(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=S(t)),n}function a(e,t,n){var s,i=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),a=0;for(s=0;s<i;s++)(n&&e[s]!==t[s]||!n&&D(e[s])!==D(t[s]))&&a++;return a+r}function Y(e){!1===c.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e)}function n(i,r){var a=!0;return _(function(){if(null!=c.deprecationHandler&&c.deprecationHandler(null,i),a){for(var e,t=[],n=0;n<arguments.length;n++){if(e="","object"==typeof arguments[n]){for(var s in e+="\n["+n+"] ",arguments[0])e+=s+": "+arguments[0][s]+", ";e=e.slice(0,-2)}else e=arguments[n];t.push(e)}Y(i+"\nArguments: "+Array.prototype.slice.call(t).join("")+"\n"+(new Error).stack),a=!1}return r.apply(this,arguments)},r)}var s,O={};function T(e,t){null!=c.deprecationHandler&&c.deprecationHandler(e,t),O[e]||(Y(t),O[e]=!0)}function b(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function x(e,t){var n,s=_({},e);for(n in t)m(t,n)&&(u(e[n])&&u(t[n])?(s[n]={},_(s[n],e[n]),_(s[n],t[n])):null!=t[n]?s[n]=t[n]:delete s[n]);for(n in e)m(e,n)&&!m(t,n)&&u(e[n])&&(s[n]=_({},s[n]));return s}function P(e){null!=e&&this.set(e)}c.suppressDeprecationWarnings=!1,c.deprecationHandler=null,s=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)m(e,t)&&n.push(t);return n};var W={};function C(e,t){var n=e.toLowerCase();W[n]=W[n+"s"]=W[t]=e}function H(e){return"string"==typeof e?W[e]||W[e.toLowerCase()]:void 0}function R(e){var t,n,s={};for(n in e)m(e,n)&&(t=H(n))&&(s[t]=e[n]);return s}var U={};function F(e,t){U[e]=t}function L(e,t,n){var s=""+Math.abs(e),i=t-s.length;return(0<=e?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+s}var N=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,G=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,V={},E={};function I(e,t,n,s){var i=s;"string"==typeof s&&(i=function(){return this[s]()}),e&&(E[e]=i),t&&(E[t[0]]=function(){return L(i.apply(this,arguments),t[1],t[2])}),n&&(E[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),e)})}function A(e,t){return e.isValid()?(t=j(t,e.localeData()),V[t]=V[t]||function(s){var e,i,t,r=s.match(N);for(e=0,i=r.length;e<i;e++)E[r[e]]?r[e]=E[r[e]]:r[e]=(t=r[e]).match(/\[[\s\S]/)?t.replace(/^\[|\]$/g,""):t.replace(/\\/g,"");return function(e){var t,n="";for(t=0;t<i;t++)n+=b(r[t])?r[t].call(e,s):r[t];return n}}(t),V[t](e)):e.localeData().invalidDate()}function j(e,t){var n=5;function s(e){return t.longDateFormat(e)||e}for(G.lastIndex=0;0<=n&&G.test(e);)e=e.replace(G,s),G.lastIndex=0,n-=1;return e}var Z=/\d/,z=/\d\d/,$=/\d{3}/,q=/\d{4}/,J=/[+-]?\d{6}/,B=/\d\d?/,Q=/\d\d\d\d?/,X=/\d\d\d\d\d\d?/,K=/\d{1,3}/,ee=/\d{1,4}/,te=/[+-]?\d{1,6}/,ne=/\d+/,se=/[+-]?\d+/,ie=/Z|[+-]\d\d:?\d\d/gi,re=/Z|[+-]\d\d(?::?\d\d)?/gi,ae=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,oe={};function ue(e,n,s){oe[e]=b(n)?n:function(e,t){return e&&s?s:n}}function le(e,t){return m(oe,e)?oe[e](t._strict,t._locale):new RegExp(he(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,s,i){return t||n||s||i})))}function he(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var de={};function ce(e,n){var t,s=n;for("string"==typeof e&&(e=[e]),h(n)&&(s=function(e,t){t[n]=D(e)}),t=0;t<e.length;t++)de[e[t]]=s}function fe(e,i){ce(e,function(e,t,n,s){n._w=n._w||{},i(e,n._w,n,s)})}var me=0,_e=1,ye=2,ge=3,ve=4,pe=5,we=6,Me=7,ke=8;function Se(e){return De(e)?366:365}function De(e){return e%4==0&&e%100!=0||e%400==0}I("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),I(0,["YY",2],0,function(){return this.year()%100}),I(0,["YYYY",4],0,"year"),I(0,["YYYYY",5],0,"year"),I(0,["YYYYYY",6,!0],0,"year"),C("year","y"),F("year",1),ue("Y",se),ue("YY",B,z),ue("YYYY",ee,q),ue("YYYYY",te,J),ue("YYYYYY",te,J),ce(["YYYYY","YYYYYY"],me),ce("YYYY",function(e,t){t[me]=2===e.length?c.parseTwoDigitYear(e):D(e)}),ce("YY",function(e,t){t[me]=c.parseTwoDigitYear(e)}),ce("Y",function(e,t){t[me]=parseInt(e,10)}),c.parseTwoDigitYear=function(e){return D(e)+(68<D(e)?1900:2e3)};var Ye,Oe=Te("FullYear",!0);function Te(t,n){return function(e){return null!=e?(xe(this,t,e),c.updateOffset(this,n),this):be(this,t)}}function be(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function xe(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&De(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),Pe(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n))}function Pe(e,t){if(isNaN(e)||isNaN(t))return NaN;var n,s=(t%(n=12)+n)%n;return e+=(t-s)/12,1===s?De(e)?29:28:31-s%7%2}Ye=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;t<this.length;++t)if(this[t]===e)return t;return-1},I("M",["MM",2],"Mo",function(){return this.month()+1}),I("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),I("MMMM",0,0,function(e){return this.localeData().months(this,e)}),C("month","M"),F("month",8),ue("M",B),ue("MM",B,z),ue("MMM",function(e,t){return t.monthsShortRegex(e)}),ue("MMMM",function(e,t){return t.monthsRegex(e)}),ce(["M","MM"],function(e,t){t[_e]=D(e)-1}),ce(["MMM","MMMM"],function(e,t,n,s){var i=n._locale.monthsParse(e,s,n._strict);null!=i?t[_e]=i:g(n).invalidMonth=e});var We=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Ce="January_February_March_April_May_June_July_August_September_October_November_December".split("_");var He="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Re(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=D(t);else if(!h(t=e.localeData().monthsParse(t)))return e;return n=Math.min(e.date(),Pe(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function Ue(e){return null!=e?(Re(this,e),c.updateOffset(this,!0),this):be(this,"Month")}var Fe=ae;var Le=ae;function Ne(){function e(e,t){return t.length-e.length}var t,n,s=[],i=[],r=[];for(t=0;t<12;t++)n=y([2e3,t]),s.push(this.monthsShort(n,"")),i.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(s.sort(e),i.sort(e),r.sort(e),t=0;t<12;t++)s[t]=he(s[t]),i[t]=he(i[t]);for(t=0;t<24;t++)r[t]=he(r[t]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i")}function Ge(e){var t;if(e<100&&0<=e){var n=Array.prototype.slice.call(arguments);n[0]=e+400,t=new Date(Date.UTC.apply(null,n)),isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e)}else t=new Date(Date.UTC.apply(null,arguments));return t}function Ve(e,t,n){var s=7+t-n;return-((7+Ge(e,0,s).getUTCDay()-t)%7)+s-1}function Ee(e,t,n,s,i){var r,a,o=1+7*(t-1)+(7+n-s)%7+Ve(e,s,i);return a=o<=0?Se(r=e-1)+o:o>Se(e)?(r=e+1,o-Se(e)):(r=e,o),{year:r,dayOfYear:a}}function Ie(e,t,n){var s,i,r=Ve(e.year(),t,n),a=Math.floor((e.dayOfYear()-r-1)/7)+1;return a<1?s=a+Ae(i=e.year()-1,t,n):a>Ae(e.year(),t,n)?(s=a-Ae(e.year(),t,n),i=e.year()+1):(i=e.year(),s=a),{week:s,year:i}}function Ae(e,t,n){var s=Ve(e,t,n),i=Ve(e+1,t,n);return(Se(e)-s+i)/7}I("w",["ww",2],"wo","week"),I("W",["WW",2],"Wo","isoWeek"),C("week","w"),C("isoWeek","W"),F("week",5),F("isoWeek",5),ue("w",B),ue("ww",B,z),ue("W",B),ue("WW",B,z),fe(["w","ww","W","WW"],function(e,t,n,s){t[s.substr(0,1)]=D(e)});function je(e,t){return e.slice(t,7).concat(e.slice(0,t))}I("d",0,"do","day"),I("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),I("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),I("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),I("e",0,0,"weekday"),I("E",0,0,"isoWeekday"),C("day","d"),C("weekday","e"),C("isoWeekday","E"),F("day",11),F("weekday",11),F("isoWeekday",11),ue("d",B),ue("e",B),ue("E",B),ue("dd",function(e,t){return t.weekdaysMinRegex(e)}),ue("ddd",function(e,t){return t.weekdaysShortRegex(e)}),ue("dddd",function(e,t){return t.weekdaysRegex(e)}),fe(["dd","ddd","dddd"],function(e,t,n,s){var i=n._locale.weekdaysParse(e,s,n._strict);null!=i?t.d=i:g(n).invalidWeekday=e}),fe(["d","e","E"],function(e,t,n,s){t[s]=D(e)});var Ze="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");var ze="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");var $e="Su_Mo_Tu_We_Th_Fr_Sa".split("_");var qe=ae;var Je=ae;var Be=ae;function Qe(){function e(e,t){return t.length-e.length}var t,n,s,i,r,a=[],o=[],u=[],l=[];for(t=0;t<7;t++)n=y([2e3,1]).day(t),s=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),r=this.weekdays(n,""),a.push(s),o.push(i),u.push(r),l.push(s),l.push(i),l.push(r);for(a.sort(e),o.sort(e),u.sort(e),l.sort(e),t=0;t<7;t++)o[t]=he(o[t]),u[t]=he(u[t]),l[t]=he(l[t]);this._weekdaysRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i")}function Xe(){return this.hours()%12||12}function Ke(e,t){I(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)})}function et(e,t){return t._meridiemParse}I("H",["HH",2],0,"hour"),I("h",["hh",2],0,Xe),I("k",["kk",2],0,function(){return this.hours()||24}),I("hmm",0,0,function(){return""+Xe.apply(this)+L(this.minutes(),2)}),I("hmmss",0,0,function(){return""+Xe.apply(this)+L(this.minutes(),2)+L(this.seconds(),2)}),I("Hmm",0,0,function(){return""+this.hours()+L(this.minutes(),2)}),I("Hmmss",0,0,function(){return""+this.hours()+L(this.minutes(),2)+L(this.seconds(),2)}),Ke("a",!0),Ke("A",!1),C("hour","h"),F("hour",13),ue("a",et),ue("A",et),ue("H",B),ue("h",B),ue("k",B),ue("HH",B,z),ue("hh",B,z),ue("kk",B,z),ue("hmm",Q),ue("hmmss",X),ue("Hmm",Q),ue("Hmmss",X),ce(["H","HH"],ge),ce(["k","kk"],function(e,t,n){var s=D(e);t[ge]=24===s?0:s}),ce(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e}),ce(["h","hh"],function(e,t,n){t[ge]=D(e),g(n).bigHour=!0}),ce("hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s)),g(n).bigHour=!0}),ce("hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i)),g(n).bigHour=!0}),ce("Hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s))}),ce("Hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i))});var tt,nt=Te("Hours",!0),st={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Ce,monthsShort:He,week:{dow:0,doy:6},weekdays:Ze,weekdaysMin:$e,weekdaysShort:ze,meridiemParse:/[ap]\.?m?\.?/i},it={},rt={};function at(e){return e?e.toLowerCase().replace("_","-"):e}function ot(e){var t=null;if(!it[e]&&"undefined"!=typeof module&&module&&module.exports)try{t=tt._abbr,require("./locale/"+e),ut(t)}catch(e){}return it[e]}function ut(e,t){var n;return e&&((n=l(t)?ht(e):lt(e,t))?tt=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),tt._abbr}function lt(e,t){if(null===t)return delete it[e],null;var n,s=st;if(t.abbr=e,null!=it[e])T("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),s=it[e]._config;else if(null!=t.parentLocale)if(null!=it[t.parentLocale])s=it[t.parentLocale]._config;else{if(null==(n=ot(t.parentLocale)))return rt[t.parentLocale]||(rt[t.parentLocale]=[]),rt[t.parentLocale].push({name:e,config:t}),null;s=n._config}return it[e]=new P(x(s,t)),rt[e]&&rt[e].forEach(function(e){lt(e.name,e.config)}),ut(e),it[e]}function ht(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return tt;if(!o(e)){if(t=ot(e))return t;e=[e]}return function(e){for(var t,n,s,i,r=0;r<e.length;){for(t=(i=at(e[r]).split("-")).length,n=(n=at(e[r+1]))?n.split("-"):null;0<t;){if(s=ot(i.slice(0,t).join("-")))return s;if(n&&n.length>=t&&a(i,n,!0)>=t-1)break;t--}r++}return tt}(e)}function dt(e){var t,n=e._a;return n&&-2===g(e).overflow&&(t=n[_e]<0||11<n[_e]?_e:n[ye]<1||n[ye]>Pe(n[me],n[_e])?ye:n[ge]<0||24<n[ge]||24===n[ge]&&(0!==n[ve]||0!==n[pe]||0!==n[we])?ge:n[ve]<0||59<n[ve]?ve:n[pe]<0||59<n[pe]?pe:n[we]<0||999<n[we]?we:-1,g(e)._overflowDayOfYear&&(t<me||ye<t)&&(t=ye),g(e)._overflowWeeks&&-1===t&&(t=Me),g(e)._overflowWeekday&&-1===t&&(t=ke),g(e).overflow=t),e}function ct(e,t,n){return null!=e?e:null!=t?t:n}function ft(e){var t,n,s,i,r,a=[];if(!e._d){var o,u;for(o=e,u=new Date(c.now()),s=o._useUTC?[u.getUTCFullYear(),u.getUTCMonth(),u.getUTCDate()]:[u.getFullYear(),u.getMonth(),u.getDate()],e._w&&null==e._a[ye]&&null==e._a[_e]&&function(e){var t,n,s,i,r,a,o,u;if(null!=(t=e._w).GG||null!=t.W||null!=t.E)r=1,a=4,n=ct(t.GG,e._a[me],Ie(bt(),1,4).year),s=ct(t.W,1),((i=ct(t.E,1))<1||7<i)&&(u=!0);else{r=e._locale._week.dow,a=e._locale._week.doy;var l=Ie(bt(),r,a);n=ct(t.gg,e._a[me],l.year),s=ct(t.w,l.week),null!=t.d?((i=t.d)<0||6<i)&&(u=!0):null!=t.e?(i=t.e+r,(t.e<0||6<t.e)&&(u=!0)):i=r}s<1||s>Ae(n,r,a)?g(e)._overflowWeeks=!0:null!=u?g(e)._overflowWeekday=!0:(o=Ee(n,s,i,r,a),e._a[me]=o.year,e._dayOfYear=o.dayOfYear)}(e),null!=e._dayOfYear&&(r=ct(e._a[me],s[me]),(e._dayOfYear>Se(r)||0===e._dayOfYear)&&(g(e)._overflowDayOfYear=!0),n=Ge(r,0,e._dayOfYear),e._a[_e]=n.getUTCMonth(),e._a[ye]=n.getUTCDate()),t=0;t<3&&null==e._a[t];++t)e._a[t]=a[t]=s[t];for(;t<7;t++)e._a[t]=a[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[ge]&&0===e._a[ve]&&0===e._a[pe]&&0===e._a[we]&&(e._nextDay=!0,e._a[ge]=0),e._d=(e._useUTC?Ge:function(e,t,n,s,i,r,a){var o;return e<100&&0<=e?(o=new Date(e+400,t,n,s,i,r,a),isFinite(o.getFullYear())&&o.setFullYear(e)):o=new Date(e,t,n,s,i,r,a),o}).apply(null,a),i=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[ge]=24),e._w&&void 0!==e._w.d&&e._w.d!==i&&(g(e).weekdayMismatch=!0)}}var mt=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,_t=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,yt=/Z|[+-]\d\d(?::?\d\d)?/,gt=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],vt=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],pt=/^\/?Date\((\-?\d+)/i;function wt(e){var t,n,s,i,r,a,o=e._i,u=mt.exec(o)||_t.exec(o);if(u){for(g(e).iso=!0,t=0,n=gt.length;t<n;t++)if(gt[t][1].exec(u[1])){i=gt[t][0],s=!1!==gt[t][2];break}if(null==i)return void(e._isValid=!1);if(u[3]){for(t=0,n=vt.length;t<n;t++)if(vt[t][1].exec(u[3])){r=(u[2]||" ")+vt[t][0];break}if(null==r)return void(e._isValid=!1)}if(!s&&null!=r)return void(e._isValid=!1);if(u[4]){if(!yt.exec(u[4]))return void(e._isValid=!1);a="Z"}e._f=i+(r||"")+(a||""),Yt(e)}else e._isValid=!1}var Mt=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function kt(e,t,n,s,i,r){var a=[function(e){var t=parseInt(e,10);{if(t<=49)return 2e3+t;if(t<=999)return 1900+t}return t}(e),He.indexOf(t),parseInt(n,10),parseInt(s,10),parseInt(i,10)];return r&&a.push(parseInt(r,10)),a}var St={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Dt(e){var t,n,s,i=Mt.exec(e._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,""));if(i){var r=kt(i[4],i[3],i[2],i[5],i[6],i[7]);if(t=i[1],n=r,s=e,t&&ze.indexOf(t)!==new Date(n[0],n[1],n[2]).getDay()&&(g(s).weekdayMismatch=!0,!(s._isValid=!1)))return;e._a=r,e._tzm=function(e,t,n){if(e)return St[e];if(t)return 0;var s=parseInt(n,10),i=s%100;return(s-i)/100*60+i}(i[8],i[9],i[10]),e._d=Ge.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),g(e).rfc2822=!0}else e._isValid=!1}function Yt(e){if(e._f!==c.ISO_8601)if(e._f!==c.RFC_2822){e._a=[],g(e).empty=!0;var t,n,s,i,r,a,o,u,l=""+e._i,h=l.length,d=0;for(s=j(e._f,e._locale).match(N)||[],t=0;t<s.length;t++)i=s[t],(n=(l.match(le(i,e))||[])[0])&&(0<(r=l.substr(0,l.indexOf(n))).length&&g(e).unusedInput.push(r),l=l.slice(l.indexOf(n)+n.length),d+=n.length),E[i]?(n?g(e).empty=!1:g(e).unusedTokens.push(i),a=i,u=e,null!=(o=n)&&m(de,a)&&de[a](o,u._a,u,a)):e._strict&&!n&&g(e).unusedTokens.push(i);g(e).charsLeftOver=h-d,0<l.length&&g(e).unusedInput.push(l),e._a[ge]<=12&&!0===g(e).bigHour&&0<e._a[ge]&&(g(e).bigHour=void 0),g(e).parsedDateParts=e._a.slice(0),g(e).meridiem=e._meridiem,e._a[ge]=function(e,t,n){var s;if(null==n)return t;return null!=e.meridiemHour?e.meridiemHour(t,n):(null!=e.isPM&&((s=e.isPM(n))&&t<12&&(t+=12),s||12!==t||(t=0)),t)}(e._locale,e._a[ge],e._meridiem),ft(e),dt(e)}else Dt(e);else wt(e)}function Ot(e){var t,n,s,i,r=e._i,a=e._f;return e._locale=e._locale||ht(e._l),null===r||void 0===a&&""===r?p({nullInput:!0}):("string"==typeof r&&(e._i=r=e._locale.preparse(r)),k(r)?new M(dt(r)):(d(r)?e._d=r:o(a)?function(e){var t,n,s,i,r;if(0===e._f.length)return g(e).invalidFormat=!0,e._d=new Date(NaN);for(i=0;i<e._f.length;i++)r=0,t=w({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[i],Yt(t),v(t)&&(r+=g(t).charsLeftOver,r+=10*g(t).unusedTokens.length,g(t).score=r,(null==s||r<s)&&(s=r,n=t));_(e,n||t)}(e):a?Yt(e):l(n=(t=e)._i)?t._d=new Date(c.now()):d(n)?t._d=new Date(n.valueOf()):"string"==typeof n?(s=t,null===(i=pt.exec(s._i))?(wt(s),!1===s._isValid&&(delete s._isValid,Dt(s),!1===s._isValid&&(delete s._isValid,c.createFromInputFallback(s)))):s._d=new Date(+i[1])):o(n)?(t._a=f(n.slice(0),function(e){return parseInt(e,10)}),ft(t)):u(n)?function(e){if(!e._d){var t=R(e._i);e._a=f([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),ft(e)}}(t):h(n)?t._d=new Date(n):c.createFromInputFallback(t),v(e)||(e._d=null),e))}function Tt(e,t,n,s,i){var r,a={};return!0!==n&&!1!==n||(s=n,n=void 0),(u(e)&&function(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return!1;return!0}(e)||o(e)&&0===e.length)&&(e=void 0),a._isAMomentObject=!0,a._useUTC=a._isUTC=i,a._l=n,a._i=e,a._f=t,a._strict=s,(r=new M(dt(Ot(a))))._nextDay&&(r.add(1,"d"),r._nextDay=void 0),r}function bt(e,t,n,s){return Tt(e,t,n,s,!1)}c.createFromInputFallback=n("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),c.ISO_8601=function(){},c.RFC_2822=function(){};var xt=n("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:p()}),Pt=n("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?this<e?this:e:p()});function Wt(e,t){var n,s;if(1===t.length&&o(t[0])&&(t=t[0]),!t.length)return bt();for(n=t[0],s=1;s<t.length;++s)t[s].isValid()&&!t[s][e](n)||(n=t[s]);return n}var Ct=["year","quarter","month","week","day","hour","minute","second","millisecond"];function Ht(e){var t=R(e),n=t.year||0,s=t.quarter||0,i=t.month||0,r=t.week||t.isoWeek||0,a=t.day||0,o=t.hour||0,u=t.minute||0,l=t.second||0,h=t.millisecond||0;this._isValid=function(e){for(var t in e)if(-1===Ye.call(Ct,t)||null!=e[t]&&isNaN(e[t]))return!1;for(var n=!1,s=0;s<Ct.length;++s)if(e[Ct[s]]){if(n)return!1;parseFloat(e[Ct[s]])!==D(e[Ct[s]])&&(n=!0)}return!0}(t),this._milliseconds=+h+1e3*l+6e4*u+1e3*o*60*60,this._days=+a+7*r,this._months=+i+3*s+12*n,this._data={},this._locale=ht(),this._bubble()}function Rt(e){return e instanceof Ht}function Ut(e){return e<0?-1*Math.round(-1*e):Math.round(e)}function Ft(e,n){I(e,0,0,function(){var e=this.utcOffset(),t="+";return e<0&&(e=-e,t="-"),t+L(~~(e/60),2)+n+L(~~e%60,2)})}Ft("Z",":"),Ft("ZZ",""),ue("Z",re),ue("ZZ",re),ce(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=Nt(re,e)});var Lt=/([\+\-]|\d\d)/gi;function Nt(e,t){var n=(t||"").match(e);if(null===n)return null;var s=((n[n.length-1]||[])+"").match(Lt)||["-",0,0],i=60*s[1]+D(s[2]);return 0===i?0:"+"===s[0]?i:-i}function Gt(e,t){var n,s;return t._isUTC?(n=t.clone(),s=(k(e)||d(e)?e.valueOf():bt(e).valueOf())-n.valueOf(),n._d.setTime(n._d.valueOf()+s),c.updateOffset(n,!1),n):bt(e).local()}function Vt(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Et(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}c.updateOffset=function(){};var It=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,At=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function jt(e,t){var n,s,i,r=e,a=null;return Rt(e)?r={ms:e._milliseconds,d:e._days,M:e._months}:h(e)?(r={},t?r[t]=e:r.milliseconds=e):(a=It.exec(e))?(n="-"===a[1]?-1:1,r={y:0,d:D(a[ye])*n,h:D(a[ge])*n,m:D(a[ve])*n,s:D(a[pe])*n,ms:D(Ut(1e3*a[we]))*n}):(a=At.exec(e))?(n="-"===a[1]?-1:1,r={y:Zt(a[2],n),M:Zt(a[3],n),w:Zt(a[4],n),d:Zt(a[5],n),h:Zt(a[6],n),m:Zt(a[7],n),s:Zt(a[8],n)}):null==r?r={}:"object"==typeof r&&("from"in r||"to"in r)&&(i=function(e,t){var n;if(!e.isValid()||!t.isValid())return{milliseconds:0,months:0};t=Gt(t,e),e.isBefore(t)?n=zt(e,t):((n=zt(t,e)).milliseconds=-n.milliseconds,n.months=-n.months);return n}(bt(r.from),bt(r.to)),(r={}).ms=i.milliseconds,r.M=i.months),s=new Ht(r),Rt(e)&&m(e,"_locale")&&(s._locale=e._locale),s}function Zt(e,t){var n=e&&parseFloat(e.replace(",","."));return(isNaN(n)?0:n)*t}function zt(e,t){var n={};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function $t(s,i){return function(e,t){var n;return null===t||isNaN(+t)||(T(i,"moment()."+i+"(period, number) is deprecated. Please use moment()."+i+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),n=e,e=t,t=n),qt(this,jt(e="string"==typeof e?+e:e,t),s),this}}function qt(e,t,n,s){var i=t._milliseconds,r=Ut(t._days),a=Ut(t._months);e.isValid()&&(s=null==s||s,a&&Re(e,be(e,"Month")+a*n),r&&xe(e,"Date",be(e,"Date")+r*n),i&&e._d.setTime(e._d.valueOf()+i*n),s&&c.updateOffset(e,r||a))}jt.fn=Ht.prototype,jt.invalid=function(){return jt(NaN)};var Jt=$t(1,"add"),Bt=$t(-1,"subtract");function Qt(e,t){var n=12*(t.year()-e.year())+(t.month()-e.month()),s=e.clone().add(n,"months");return-(n+(t-s<0?(t-s)/(s-e.clone().add(n-1,"months")):(t-s)/(e.clone().add(n+1,"months")-s)))||0}function Xt(e){var t;return void 0===e?this._locale._abbr:(null!=(t=ht(e))&&(this._locale=t),this)}c.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",c.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Kt=n("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});function en(){return this._locale}var tn=126227808e5;function nn(e,t){return(e%t+t)%t}function sn(e,t,n){return e<100&&0<=e?new Date(e+400,t,n)-tn:new Date(e,t,n).valueOf()}function rn(e,t,n){return e<100&&0<=e?Date.UTC(e+400,t,n)-tn:Date.UTC(e,t,n)}function an(e,t){I(0,[e,e.length],0,t)}function on(e,t,n,s,i){var r;return null==e?Ie(this,s,i).year:((r=Ae(e,s,i))<t&&(t=r),function(e,t,n,s,i){var r=Ee(e,t,n,s,i),a=Ge(r.year,0,r.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}.call(this,e,t,n,s,i))}I(0,["gg",2],0,function(){return this.weekYear()%100}),I(0,["GG",2],0,function(){return this.isoWeekYear()%100}),an("gggg","weekYear"),an("ggggg","weekYear"),an("GGGG","isoWeekYear"),an("GGGGG","isoWeekYear"),C("weekYear","gg"),C("isoWeekYear","GG"),F("weekYear",1),F("isoWeekYear",1),ue("G",se),ue("g",se),ue("GG",B,z),ue("gg",B,z),ue("GGGG",ee,q),ue("gggg",ee,q),ue("GGGGG",te,J),ue("ggggg",te,J),fe(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,s){t[s.substr(0,2)]=D(e)}),fe(["gg","GG"],function(e,t,n,s){t[s]=c.parseTwoDigitYear(e)}),I("Q",0,"Qo","quarter"),C("quarter","Q"),F("quarter",7),ue("Q",Z),ce("Q",function(e,t){t[_e]=3*(D(e)-1)}),I("D",["DD",2],"Do","date"),C("date","D"),F("date",9),ue("D",B),ue("DD",B,z),ue("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),ce(["D","DD"],ye),ce("Do",function(e,t){t[ye]=D(e.match(B)[0])});var un=Te("Date",!0);I("DDD",["DDDD",3],"DDDo","dayOfYear"),C("dayOfYear","DDD"),F("dayOfYear",4),ue("DDD",K),ue("DDDD",$),ce(["DDD","DDDD"],function(e,t,n){n._dayOfYear=D(e)}),I("m",["mm",2],0,"minute"),C("minute","m"),F("minute",14),ue("m",B),ue("mm",B,z),ce(["m","mm"],ve);var ln=Te("Minutes",!1);I("s",["ss",2],0,"second"),C("second","s"),F("second",15),ue("s",B),ue("ss",B,z),ce(["s","ss"],pe);var hn,dn=Te("Seconds",!1);for(I("S",0,0,function(){return~~(this.millisecond()/100)}),I(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),I(0,["SSS",3],0,"millisecond"),I(0,["SSSS",4],0,function(){return 10*this.millisecond()}),I(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),I(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),I(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),I(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),I(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),C("millisecond","ms"),F("millisecond",16),ue("S",K,Z),ue("SS",K,z),ue("SSS",K,$),hn="SSSS";hn.length<=9;hn+="S")ue(hn,ne);function cn(e,t){t[we]=D(1e3*("0."+e))}for(hn="S";hn.length<=9;hn+="S")ce(hn,cn);var fn=Te("Milliseconds",!1);I("z",0,0,"zoneAbbr"),I("zz",0,0,"zoneName");var mn=M.prototype;function _n(e){return e}mn.add=Jt,mn.calendar=function(e,t){var n=e||bt(),s=Gt(n,this).startOf("day"),i=c.calendarFormat(this,s)||"sameElse",r=t&&(b(t[i])?t[i].call(this,n):t[i]);return this.format(r||this.localeData().calendar(i,this,bt(n)))},mn.clone=function(){return new M(this)},mn.diff=function(e,t,n){var s,i,r;if(!this.isValid())return NaN;if(!(s=Gt(e,this)).isValid())return NaN;switch(i=6e4*(s.utcOffset()-this.utcOffset()),t=H(t)){case"year":r=Qt(this,s)/12;break;case"month":r=Qt(this,s);break;case"quarter":r=Qt(this,s)/3;break;case"second":r=(this-s)/1e3;break;case"minute":r=(this-s)/6e4;break;case"hour":r=(this-s)/36e5;break;case"day":r=(this-s-i)/864e5;break;case"week":r=(this-s-i)/6048e5;break;default:r=this-s}return n?r:S(r)},mn.endOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year()+1,0,1)-1;break;case"quarter":t=n(this.year(),this.month()-this.month()%3+3,1)-1;break;case"month":t=n(this.year(),this.month()+1,1)-1;break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday()+7)-1;break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1)+7)-1;break;case"day":case"date":t=n(this.year(),this.month(),this.date()+1)-1;break;case"hour":t=this._d.valueOf(),t+=36e5-nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5)-1;break;case"minute":t=this._d.valueOf(),t+=6e4-nn(t,6e4)-1;break;case"second":t=this._d.valueOf(),t+=1e3-nn(t,1e3)-1;break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.format=function(e){e||(e=this.isUtc()?c.defaultFormatUtc:c.defaultFormat);var t=A(this,e);return this.localeData().postformat(t)},mn.from=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.fromNow=function(e){return this.from(bt(),e)},mn.to=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.toNow=function(e){return this.to(bt(),e)},mn.get=function(e){return b(this[e=H(e)])?this[e]():this},mn.invalidAt=function(){return g(this).overflow},mn.isAfter=function(e,t){var n=k(e)?e:bt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())},mn.isBefore=function(e,t){var n=k(e)?e:bt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())},mn.isBetween=function(e,t,n,s){var i=k(e)?e:bt(e),r=k(t)?t:bt(t);return!!(this.isValid()&&i.isValid()&&r.isValid())&&("("===(s=s||"()")[0]?this.isAfter(i,n):!this.isBefore(i,n))&&(")"===s[1]?this.isBefore(r,n):!this.isAfter(r,n))},mn.isSame=function(e,t){var n,s=k(e)?e:bt(e);return!(!this.isValid()||!s.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()===s.valueOf():(n=s.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))},mn.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)},mn.isSameOrBefore=function(e,t){return this.isSame(e,t)||this.isBefore(e,t)},mn.isValid=function(){return v(this)},mn.lang=Kt,mn.locale=Xt,mn.localeData=en,mn.max=Pt,mn.min=xt,mn.parsingFlags=function(){return _({},g(this))},mn.set=function(e,t){if("object"==typeof e)for(var n=function(e){var t=[];for(var n in e)t.push({unit:n,priority:U[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}(e=R(e)),s=0;s<n.length;s++)this[n[s].unit](e[n[s].unit]);else if(b(this[e=H(e)]))return this[e](t);return this},mn.startOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year(),0,1);break;case"quarter":t=n(this.year(),this.month()-this.month()%3,1);break;case"month":t=n(this.year(),this.month(),1);break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday());break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1));break;case"day":case"date":t=n(this.year(),this.month(),this.date());break;case"hour":t=this._d.valueOf(),t-=nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5);break;case"minute":t=this._d.valueOf(),t-=nn(t,6e4);break;case"second":t=this._d.valueOf(),t-=nn(t,1e3);break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.subtract=Bt,mn.toArray=function(){var e=this;return[e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]},mn.toObject=function(){var e=this;return{years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}},mn.toDate=function(){return new Date(this.valueOf())},mn.toISOString=function(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return n.year()<0||9999<n.year()?A(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):b(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",A(n,"Z")):A(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},mn.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");var n="["+e+'("]',s=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i=t+'[")]';return this.format(n+s+"-MM-DD[T]HH:mm:ss.SSS"+i)},mn.toJSON=function(){return this.isValid()?this.toISOString():null},mn.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},mn.unix=function(){return Math.floor(this.valueOf()/1e3)},mn.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},mn.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},mn.year=Oe,mn.isLeapYear=function(){return De(this.year())},mn.weekYear=function(e){return on.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},mn.isoWeekYear=function(e){return on.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)},mn.quarter=mn.quarters=function(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)},mn.month=Ue,mn.daysInMonth=function(){return Pe(this.year(),this.month())},mn.week=mn.weeks=function(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")},mn.isoWeek=mn.isoWeeks=function(e){var t=Ie(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")},mn.weeksInYear=function(){var e=this.localeData()._week;return Ae(this.year(),e.dow,e.doy)},mn.isoWeeksInYear=function(){return Ae(this.year(),1,4)},mn.date=un,mn.day=mn.days=function(e){if(!this.isValid())return null!=e?this:NaN;var t,n,s=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(t=e,n=this.localeData(),e="string"!=typeof t?t:isNaN(t)?"number"==typeof(t=n.weekdaysParse(t))?t:null:parseInt(t,10),this.add(e-s,"d")):s},mn.weekday=function(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")},mn.isoWeekday=function(e){if(!this.isValid())return null!=e?this:NaN;if(null==e)return this.day()||7;var t,n,s=(t=e,n=this.localeData(),"string"==typeof t?n.weekdaysParse(t)%7||7:isNaN(t)?null:t);return this.day(this.day()%7?s:s-7)},mn.dayOfYear=function(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")},mn.hour=mn.hours=nt,mn.minute=mn.minutes=ln,mn.second=mn.seconds=dn,mn.millisecond=mn.milliseconds=fn,mn.utcOffset=function(e,t,n){var s,i=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null==e)return this._isUTC?i:Vt(this);if("string"==typeof e){if(null===(e=Nt(re,e)))return this}else Math.abs(e)<16&&!n&&(e*=60);return!this._isUTC&&t&&(s=Vt(this)),this._offset=e,this._isUTC=!0,null!=s&&this.add(s,"m"),i!==e&&(!t||this._changeInProgress?qt(this,jt(e-i,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,c.updateOffset(this,!0),this._changeInProgress=null)),this},mn.utc=function(e){return this.utcOffset(0,e)},mn.local=function(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Vt(this),"m")),this},mn.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=Nt(ie,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this},mn.hasAlignedHourOffset=function(e){return!!this.isValid()&&(e=e?bt(e).utcOffset():0,(this.utcOffset()-e)%60==0)},mn.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},mn.isLocal=function(){return!!this.isValid()&&!this._isUTC},mn.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},mn.isUtc=Et,mn.isUTC=Et,mn.zoneAbbr=function(){return this._isUTC?"UTC":""},mn.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},mn.dates=n("dates accessor is deprecated. Use date instead.",un),mn.months=n("months accessor is deprecated. Use month instead",Ue),mn.years=n("years accessor is deprecated. Use year instead",Oe),mn.zone=n("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}),mn.isDSTShifted=n("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!l(this._isDSTShifted))return this._isDSTShifted;var e={};if(w(e,this),(e=Ot(e))._a){var t=e._isUTC?y(e._a):bt(e._a);this._isDSTShifted=this.isValid()&&0<a(e._a,t.toArray())}else this._isDSTShifted=!1;return this._isDSTShifted});var yn=P.prototype;function gn(e,t,n,s){var i=ht(),r=y().set(s,t);return i[n](r,e)}function vn(e,t,n){if(h(e)&&(t=e,e=void 0),e=e||"",null!=t)return gn(e,t,n,"month");var s,i=[];for(s=0;s<12;s++)i[s]=gn(e,s,n,"month");return i}function pn(e,t,n,s){t=("boolean"==typeof e?h(t)&&(n=t,t=void 0):(t=e,e=!1,h(n=t)&&(n=t,t=void 0)),t||"");var i,r=ht(),a=e?r._week.dow:0;if(null!=n)return gn(t,(n+a)%7,s,"day");var o=[];for(i=0;i<7;i++)o[i]=gn(t,(i+a)%7,s,"day");return o}yn.calendar=function(e,t,n){var s=this._calendar[e]||this._calendar.sameElse;return b(s)?s.call(t,n):s},yn.longDateFormat=function(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:(this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])},yn.invalidDate=function(){return this._invalidDate},yn.ordinal=function(e){return this._ordinal.replace("%d",e)},yn.preparse=_n,yn.postformat=_n,yn.relativeTime=function(e,t,n,s){var i=this._relativeTime[n];return b(i)?i(e,t,n,s):i.replace(/%d/i,e)},yn.pastFuture=function(e,t){var n=this._relativeTime[0<e?"future":"past"];return b(n)?n(t):n.replace(/%s/i,t)},yn.set=function(e){var t,n;for(n in e)b(t=e[n])?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},yn.months=function(e,t){return e?o(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||We).test(t)?"format":"standalone"][e.month()]:o(this._months)?this._months:this._months.standalone},yn.monthsShort=function(e,t){return e?o(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[We.test(t)?"format":"standalone"][e.month()]:o(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},yn.monthsParse=function(e,t,n){var s,i,r;if(this._monthsParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)r=y([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null}.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(i=y([2e3,s]),n&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[s]||(r="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[s]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[s].test(e))return s;if(n&&"MMM"===t&&this._shortMonthsParse[s].test(e))return s;if(!n&&this._monthsParse[s].test(e))return s}},yn.monthsRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsStrictRegex:this._monthsRegex):(m(this,"_monthsRegex")||(this._monthsRegex=Le),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)},yn.monthsShortRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(m(this,"_monthsShortRegex")||(this._monthsShortRegex=Fe),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)},yn.week=function(e){return Ie(e,this._week.dow,this._week.doy).week},yn.firstDayOfYear=function(){return this._week.doy},yn.firstDayOfWeek=function(){return this._week.dow},yn.weekdays=function(e,t){var n=o(this._weekdays)?this._weekdays:this._weekdays[e&&!0!==e&&this._weekdays.isFormat.test(t)?"format":"standalone"];return!0===e?je(n,this._week.dow):e?n[e.day()]:n},yn.weekdaysMin=function(e){return!0===e?je(this._weekdaysMin,this._week.dow):e?this._weekdaysMin[e.day()]:this._weekdaysMin},yn.weekdaysShort=function(e){return!0===e?je(this._weekdaysShort,this._week.dow):e?this._weekdaysShort[e.day()]:this._weekdaysShort},yn.weekdaysParse=function(e,t,n){var s,i,r;if(this._weekdaysParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)r=y([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null}.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(i=y([2e3,1]).day(s),n&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(i,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(i,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(i,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[s]||(r="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[s]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[s].test(e))return s;if(n&&"ddd"===t&&this._shortWeekdaysParse[s].test(e))return s;if(n&&"dd"===t&&this._minWeekdaysParse[s].test(e))return s;if(!n&&this._weekdaysParse[s].test(e))return s}},yn.weekdaysRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(m(this,"_weekdaysRegex")||(this._weekdaysRegex=qe),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)},yn.weekdaysShortRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(m(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Je),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},yn.weekdaysMinRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(m(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Be),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},yn.isPM=function(e){return"p"===(e+"").toLowerCase().charAt(0)},yn.meridiem=function(e,t,n){return 11<e?n?"pm":"PM":n?"am":"AM"},ut("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===D(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),c.lang=n("moment.lang is deprecated. Use moment.locale instead.",ut),c.langData=n("moment.langData is deprecated. Use moment.localeData instead.",ht);var wn=Math.abs;function Mn(e,t,n,s){var i=jt(t,n);return e._milliseconds+=s*i._milliseconds,e._days+=s*i._days,e._months+=s*i._months,e._bubble()}function kn(e){return e<0?Math.floor(e):Math.ceil(e)}function Sn(e){return 4800*e/146097}function Dn(e){return 146097*e/4800}function Yn(e){return function(){return this.as(e)}}var On=Yn("ms"),Tn=Yn("s"),bn=Yn("m"),xn=Yn("h"),Pn=Yn("d"),Wn=Yn("w"),Cn=Yn("M"),Hn=Yn("Q"),Rn=Yn("y");function Un(e){return function(){return this.isValid()?this._data[e]:NaN}}var Fn=Un("milliseconds"),Ln=Un("seconds"),Nn=Un("minutes"),Gn=Un("hours"),Vn=Un("days"),En=Un("months"),In=Un("years");var An=Math.round,jn={ss:44,s:45,m:45,h:22,d:26,M:11};var Zn=Math.abs;function zn(e){return(0<e)-(e<0)||+e}function $n(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n=Zn(this._milliseconds)/1e3,s=Zn(this._days),i=Zn(this._months);t=S((e=S(n/60))/60),n%=60,e%=60;var r=S(i/12),a=i%=12,o=s,u=t,l=e,h=n?n.toFixed(3).replace(/\.?0+$/,""):"",d=this.asSeconds();if(!d)return"P0D";var c=d<0?"-":"",f=zn(this._months)!==zn(d)?"-":"",m=zn(this._days)!==zn(d)?"-":"",_=zn(this._milliseconds)!==zn(d)?"-":"";return c+"P"+(r?f+r+"Y":"")+(a?f+a+"M":"")+(o?m+o+"D":"")+(u||l||h?"T":"")+(u?_+u+"H":"")+(l?_+l+"M":"")+(h?_+h+"S":"")}var qn=Ht.prototype;return qn.isValid=function(){return this._isValid},qn.abs=function(){var e=this._data;return this._milliseconds=wn(this._milliseconds),this._days=wn(this._days),this._months=wn(this._months),e.milliseconds=wn(e.milliseconds),e.seconds=wn(e.seconds),e.minutes=wn(e.minutes),e.hours=wn(e.hours),e.months=wn(e.months),e.years=wn(e.years),this},qn.add=function(e,t){return Mn(this,e,t,1)},qn.subtract=function(e,t){return Mn(this,e,t,-1)},qn.as=function(e){if(!this.isValid())return NaN;var t,n,s=this._milliseconds;if("month"===(e=H(e))||"quarter"===e||"year"===e)switch(t=this._days+s/864e5,n=this._months+Sn(t),e){case"month":return n;case"quarter":return n/3;case"year":return n/12}else switch(t=this._days+Math.round(Dn(this._months)),e){case"week":return t/7+s/6048e5;case"day":return t+s/864e5;case"hour":return 24*t+s/36e5;case"minute":return 1440*t+s/6e4;case"second":return 86400*t+s/1e3;case"millisecond":return Math.floor(864e5*t)+s;default:throw new Error("Unknown unit "+e)}},qn.asMilliseconds=On,qn.asSeconds=Tn,qn.asMinutes=bn,qn.asHours=xn,qn.asDays=Pn,qn.asWeeks=Wn,qn.asMonths=Cn,qn.asQuarters=Hn,qn.asYears=Rn,qn.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*D(this._months/12):NaN},qn._bubble=function(){var e,t,n,s,i,r=this._milliseconds,a=this._days,o=this._months,u=this._data;return 0<=r&&0<=a&&0<=o||r<=0&&a<=0&&o<=0||(r+=864e5*kn(Dn(o)+a),o=a=0),u.milliseconds=r%1e3,e=S(r/1e3),u.seconds=e%60,t=S(e/60),u.minutes=t%60,n=S(t/60),u.hours=n%24,o+=i=S(Sn(a+=S(n/24))),a-=kn(Dn(i)),s=S(o/12),o%=12,u.days=a,u.months=o,u.years=s,this},qn.clone=function(){return jt(this)},qn.get=function(e){return e=H(e),this.isValid()?this[e+"s"]():NaN},qn.milliseconds=Fn,qn.seconds=Ln,qn.minutes=Nn,qn.hours=Gn,qn.days=Vn,qn.weeks=function(){return S(this.days()/7)},qn.months=En,qn.years=In,qn.humanize=function(e){if(!this.isValid())return this.localeData().invalidDate();var t,n,s,i,r,a,o,u,l,h,d,c=this.localeData(),f=(n=!e,s=c,i=jt(t=this).abs(),r=An(i.as("s")),a=An(i.as("m")),o=An(i.as("h")),u=An(i.as("d")),l=An(i.as("M")),h=An(i.as("y")),(d=r<=jn.ss&&["s",r]||r<jn.s&&["ss",r]||a<=1&&["m"]||a<jn.m&&["mm",a]||o<=1&&["h"]||o<jn.h&&["hh",o]||u<=1&&["d"]||u<jn.d&&["dd",u]||l<=1&&["M"]||l<jn.M&&["MM",l]||h<=1&&["y"]||["yy",h])[2]=n,d[3]=0<+t,d[4]=s,function(e,t,n,s,i){return i.relativeTime(t||1,!!n,e,s)}.apply(null,d));return e&&(f=c.pastFuture(+this,f)),c.postformat(f)},qn.toISOString=$n,qn.toString=$n,qn.toJSON=$n,qn.locale=Xt,qn.localeData=en,qn.toIsoString=n("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",$n),qn.lang=Kt,I("X",0,0,"unix"),I("x",0,0,"valueOf"),ue("x",se),ue("X",/[+-]?\d+(\.\d{1,3})?/),ce("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10))}),ce("x",function(e,t,n){n._d=new Date(D(e))}),c.version="2.24.0",e=bt,c.fn=mn,c.min=function(){return Wt("isBefore",[].slice.call(arguments,0))},c.max=function(){return Wt("isAfter",[].slice.call(arguments,0))},c.now=function(){return Date.now?Date.now():+new Date},c.utc=y,c.unix=function(e){return bt(1e3*e)},c.months=function(e,t){return vn(e,t,"months")},c.isDate=d,c.locale=ut,c.invalid=p,c.duration=jt,c.isMoment=k,c.weekdays=function(e,t,n){return pn(e,t,n,"weekdays")},c.parseZone=function(){return bt.apply(null,arguments).parseZone()},c.localeData=ht,c.isDuration=Rt,c.monthsShort=function(e,t){return vn(e,t,"monthsShort")},c.weekdaysMin=function(e,t,n){return pn(e,t,n,"weekdaysMin")},c.defineLocale=lt,c.updateLocale=function(e,t){if(null!=t){var n,s,i=st;null!=(s=ot(e))&&(i=s._config),(n=new P(t=x(i,t))).parentLocale=it[e],it[e]=n,ut(e)}else null!=it[e]&&(null!=it[e].parentLocale?it[e]=it[e].parentLocale:null!=it[e]&&delete it[e]);return it[e]},c.locales=function(){return s(it)},c.weekdaysShort=function(e,t,n){return pn(e,t,n,"weekdaysShort")},c.normalizeUnits=H,c.relativeTimeRounding=function(e){return void 0===e?An:"function"==typeof e&&(An=e,!0)},c.relativeTimeThreshold=function(e,t){return void 0!==jn[e]&&(void 0===t?jn[e]:(jn[e]=t,"s"===e&&(jn.ss=t-1),!0))},c.calendarFormat=function(e,t){var n=e.diff(t,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},c.prototype=mn,c.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"GGGG-[W]WW",MONTH:"YYYY-MM"},c});
/**
 * Applies the :focus-visible polyfill at the given scope.
 * A scope in this case is either the top-level Document or a Shadow Root.
 *
 * @param {(Document|ShadowRoot)} scope
 * @see https://github.com/WICG/focus-visible
 */
 function applyFocusVisiblePolyfill(scope) {
  var hadKeyboardEvent = true;
  var hadFocusVisibleRecently = false;
  var hadFocusVisibleRecentlyTimeout = null;

  var inputTypesAllowlist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    'datetime-local': true
  };

  /**
   * Helper function for legacy browsers and iframes which sometimes focus
   * elements like document, body, and non-interactive SVG.
   * @param {Element} el
   */
  function isValidFocusTarget(el) {
    if (
      el &&
      el !== document &&
      el.nodeName !== 'HTML' &&
      el.nodeName !== 'BODY' &&
      'classList' in el &&
      'contains' in el.classList
    ) {
      return true;
    }
    return false;
  }

  /**
   * Computes whether the given element should automatically trigger the
   * `focus-visible` class being added, i.e. whether it should always match
   * `:focus-visible` when focused.
   * @param {Element} el
   * @return {boolean}
   */
  function focusTriggersKeyboardModality(el) {
    var type = el.type;
    var tagName = el.tagName;

    if (tagName === 'INPUT' && inputTypesAllowlist[type] && !el.readOnly) {
      return true;
    }

    if (tagName === 'TEXTAREA' && !el.readOnly) {
      return true;
    }

    if (el.isContentEditable) {
      return true;
    }

    return false;
  }

  /**
   * Add the `focus-visible` class to the given element if it was not added by
   * the author.
   * @param {Element} el
   */
  function addFocusVisibleClass(el) {
    if (el.classList.contains('focus-visible')) {
      return;
    }
    el.classList.add('focus-visible');
    el.setAttribute('data-focus-visible-added', '');
  }

  /**
   * Remove the `focus-visible` class from the given element if it was not
   * originally added by the author.
   * @param {Element} el
   */
  function removeFocusVisibleClass(el) {
    if (!el.hasAttribute('data-focus-visible-added')) {
      return;
    }
    el.classList.remove('focus-visible');
    el.removeAttribute('data-focus-visible-added');
  }

  /**
   * If the most recent user interaction was via the keyboard;
   * and the key press did not include a meta, alt/option, or control key;
   * then the modality is keyboard. Otherwise, the modality is not keyboard.
   * Apply `focus-visible` to any current active element and keep track
   * of our keyboard modality state with `hadKeyboardEvent`.
   * @param {KeyboardEvent} e
   */
  function onKeyDown(e) {
    if (e.metaKey || e.altKey || e.ctrlKey) {
      return;
    }

    if (isValidFocusTarget(scope.activeElement)) {
      addFocusVisibleClass(scope.activeElement);
    }

    hadKeyboardEvent = true;
  }

  /**
   * If at any point a user clicks with a pointing device, ensure that we change
   * the modality away from keyboard.
   * This avoids the situation where a user presses a key on an already focused
   * element, and then clicks on a different element, focusing it with a
   * pointing device, while we still think we're in keyboard modality.
   * @param {Event} e
   */
  function onPointerDown(e) {
    hadKeyboardEvent = false;
  }

  /**
   * On `focus`, add the `focus-visible` class to the target if:
   * - the target received focus as a result of keyboard navigation, or
   * - the event target is an element that will likely require interaction
   *   via the keyboard (e.g. a text box)
   * @param {Event} e
   */
  function onFocus(e) {
    // Prevent IE from focusing the document or HTML element.
    if (!isValidFocusTarget(e.target)) {
      return;
    }

    if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {
      addFocusVisibleClass(e.target);
    }
  }

  /**
   * On `blur`, remove the `focus-visible` class from the target.
   * @param {Event} e
   */
  function onBlur(e) {
    if (!isValidFocusTarget(e.target)) {
      return;
    }

    if (
      e.target.classList.contains('focus-visible') ||
      e.target.hasAttribute('data-focus-visible-added')
    ) {
      // To detect a tab/window switch, we look for a blur event followed
      // rapidly by a visibility change.
      // If we don't see a visibility change within 100ms, it's probably a
      // regular focus change.
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {
        hadFocusVisibleRecently = false;
      }, 100);
      removeFocusVisibleClass(e.target);
    }
  }

  /**
   * If the user changes tabs, keep track of whether or not the previously
   * focused element had .focus-visible.
   * @param {Event} e
   */
  function onVisibilityChange(e) {
    if (document.visibilityState === 'hidden') {
      // If the tab becomes active again, the browser will handle calling focus
      // on the element (Safari actually calls it twice).
      // If this tab change caused a blur on an element with focus-visible,
      // re-apply the class when the user switches back to the tab.
      if (hadFocusVisibleRecently) {
        hadKeyboardEvent = true;
      }
      addInitialPointerMoveListeners();
    }
  }

  /**
   * Add a group of listeners to detect usage of any pointing devices.
   * These listeners will be added when the polyfill first loads, and anytime
   * the window is blurred, so that they are active when the window regains
   * focus.
   */
  function addInitialPointerMoveListeners() {
    document.addEventListener('mousemove', onInitialPointerMove);
    document.addEventListener('mousedown', onInitialPointerMove);
    document.addEventListener('mouseup', onInitialPointerMove);
    document.addEventListener('pointermove', onInitialPointerMove);
    document.addEventListener('pointerdown', onInitialPointerMove);
    document.addEventListener('pointerup', onInitialPointerMove);
    document.addEventListener('touchmove', onInitialPointerMove);
    document.addEventListener('touchstart', onInitialPointerMove);
    document.addEventListener('touchend', onInitialPointerMove);
  }

  function removeInitialPointerMoveListeners() {
    document.removeEventListener('mousemove', onInitialPointerMove);
    document.removeEventListener('mousedown', onInitialPointerMove);
    document.removeEventListener('mouseup', onInitialPointerMove);
    document.removeEventListener('pointermove', onInitialPointerMove);
    document.removeEventListener('pointerdown', onInitialPointerMove);
    document.removeEventListener('pointerup', onInitialPointerMove);
    document.removeEventListener('touchmove', onInitialPointerMove);
    document.removeEventListener('touchstart', onInitialPointerMove);
    document.removeEventListener('touchend', onInitialPointerMove);
  }

  /**
   * When the polfyill first loads, assume the user is in keyboard modality.
   * If any event is received from a pointing device (e.g. mouse, pointer,
   * touch), turn off keyboard modality.
   * This accounts for situations where focus enters the page from the URL bar.
   * @param {Event} e
   */
  function onInitialPointerMove(e) {
    // Work around a Safari quirk that fires a mousemove on <html> whenever the
    // window blurs, even if you're tabbing out of the page. \_()_/
    if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {
      return;
    }

    hadKeyboardEvent = false;
    removeInitialPointerMoveListeners();
  }

  // For some kinds of state, we are interested in changes at the global scope
  // only. For example, global pointer input, global key presses and global
  // visibility change should affect the state at every scope:
  document.addEventListener('keydown', onKeyDown, true);
  document.addEventListener('mousedown', onPointerDown, true);
  document.addEventListener('pointerdown', onPointerDown, true);
  document.addEventListener('touchstart', onPointerDown, true);
  document.addEventListener('visibilitychange', onVisibilityChange, true);

  addInitialPointerMoveListeners();

  // For focus and blur, we specifically care about state changes in the local
  // scope. This is because focus / blur events that originate from within a
  // shadow root are not re-dispatched from the host element if it was already
  // the active element in its own scope:
  scope.addEventListener('focus', onFocus, true);
  scope.addEventListener('blur', onBlur, true);

  // We detect that a node is a ShadowRoot by ensuring that it is a
  // DocumentFragment and also has a host property. This check covers native
  // implementation and polyfill implementation transparently. If we only cared
  // about the native implementation, we could just check if the scope was
  // an instance of a ShadowRoot.
  if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {
    // Since a ShadowRoot is a special kind of DocumentFragment, it does not
    // have a root element to add a class to. So, we add this attribute to the
    // host element instead:
    scope.host.setAttribute('data-js-focus-visible', '');
  } else if (scope.nodeType === Node.DOCUMENT_NODE) {
    document.documentElement.classList.add('js-focus-visible');
    document.documentElement.setAttribute('data-js-focus-visible', '');
  }
}

// It is important to wrap all references to global window and document in
// these checks to support server-side rendering use cases
// @see https://github.com/WICG/focus-visible/issues/199
if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  // Make the polyfill helper globally available. This can be used as a signal
  // to interested libraries that wish to coordinate with the polyfill for e.g.,
  // applying the polyfill to a shadow root:
  window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;

  // Notify interested libraries of the polyfill's presence, in case the
  // polyfill was loaded lazily:
  var event;

  try {
    event = new CustomEvent('focus-visible-polyfill-ready');
  } catch (error) {
    // IE11 does not support using CustomEvent as a constructor directly:
    event = document.createEvent('CustomEvent');
    event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});
  }

  window.dispatchEvent(event);
}

if (typeof document !== 'undefined') {
  // Apply the polyfill to the global document, so that no JavaScript
  // coordination is required to use the polyfill in the top-level document:
  applyFocusVisiblePolyfill(document);
}

/* !function to prevent library conflicts */ 
!function($) {

  class twnDatepicker {
    constructor(input) {
      this.input = input;
      this.monthYearSelectable = input.getAttribute('data-monthYearSelectable') === 'false' ? false : true;
      this.maxYear = input.getAttribute('data-maxYear') ? parseInt(input.getAttribute('data-maxYear')) : parseInt(moment().year()) + 3;
      this.minYear = input.getAttribute('data-minYear') ? parseInt(input.getAttribute('data-minYear')) : 1960;
      this.inline = input.getAttribute('data-inline') === 'true' ? true : false;
      this.dateFormat = input.getAttribute('data-dateFormat') || 'DD.MM.YYYY';
      this.showPlaceholderFormat = input.getAttribute('data-monthYearSelectable') === 'true' ? true : false;
      this.hasDatepickerButton = input.getAttribute('data-datepickerButton') === 'true' ? true : false;
      this.hideInactiveDates = input.getAttribute('data-hideInactiveDates') === 'true' ? true : false;
      this.hideMonthNavButtons = input.getAttribute('data-hideMonthNavButtons') === 'true' ? true : false;
      this.twoDigitDays = input.getAttribute('data-twoDigitDays') === 'true' ? true : false;
      this.locale = input.getAttribute('data-locale') || 'et';
      this.placeholder = input.getAttribute('data-placeholder');

      this.labels = {
        close: 'Close date picker',
        monthSelect: 'Select month',
        yearSelect: 'Select year',
        previousMonth: 'Select previous month',
        nextMonth: 'Select next month',
        openDatepicker: 'Open date picker',
        selectedDate: 'Selected date',
      };
    }

    disableInut(){
      if(this.input.closest('.disabled')){
        this.calendarButton.setAttribute('tabindex', '-1');
      };
    }
  
    addCalendarButton() {
      this.calendarButton = document.createElement('button');
      this.calendarButton.setAttribute('aria-label', this.labels.openDatepicker);
      this.calendarButton.setAttribute('type', 'button');
      this.input.parentNode.appendChild(this.calendarButton);
    }
  
    bindEvents() {
      
      if (!this.inline) {
        if (this.hasDatepickerButton) {
          this.addCalendarButton();
        
          this.calendarButton.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            if (this.calendar) {
              this.closeCalendar();
            } else {
              this.initCalendar();
              //this.calendarButton.parentNode.classList.add('is-focused');
              this.calendar.querySelector(`[data-date="${this.activeDate.format(this.dateFormat)}"]`).focus();
            }
          });
          this.bindListener(this.input, 'focus', (e) => {
            e.preventDefault();
            this.input.setAttribute('placeholder', this.placeholder);
          });

          this.bindListener(this.calendarButton, 'focus', (e) => {
            e.preventDefault();
            this.input.setAttribute('placeholder', this.placeholder);
          });

        } else {
          this.bindListener(this.input, 'focus', (e) => {
            e.preventDefault();
            this.initCalendar();
          });
        }
        this.bindListener(document, 'mousedown', (e) => {
          this.input.removeAttribute('placeholder');
          
          if (this.calendar) {

            if (this.calendarButton && e.target === this.calendarButton) {
              //this.calendarButton.parentNode.classList.add('is-focused');
              this.input.setAttribute('placeholder', this.placeholder);
            } else {
              //this.calendarButton.parentNode.classList.remove('is-focused');
              this.input.removeAttribute('placeholder');
              this.closeCalendar();
            }
          }
        });

        this.bindListener(this.calendarButton, 'blur', () => {
          this.input.removeAttribute('placeholder');
        });

        this.bindListener(this.input, 'blur', () => {
          this.input.removeAttribute('placeholder');
        });

        this.disableInut();
      }
    }
  
    bindKeyboard() {
      this.bindListener(this.calendar, 'keydown', (e) => {
        this.calendarKeypress(e);
      });
    }
    
    calendarKeypress(e) {
      if (!this.calendar) { return false; }
  
      if (e.which === 27) {
        this.closeCalendar();
      }
  
      const isDay = (e.target.getAttribute('class') && e.target.getAttribute('class').indexOf('twnCalendar__day') !== -1);
  
      if (e.which === 9 && isDay) {
        if (e.shiftKey) {
          const availableFormItems = this.calendar.querySelector('.twnCalendar__header').querySelectorAll('button, select');
          availableFormItems[availableFormItems.length - 1].focus();
          e.preventDefault();
        } else {
          if (!this.inline) {
            this.calendar.querySelector('.twnCalendar__close').focus();
            e.preventDefault();
          }
        }
      }
  
      const arrows = [37,38,39,40];
  
      if (arrows.indexOf(e.which) !== -1 && isDay) {
        this.navigateButtonFocus(e, e.key.toLowerCase().replace('arrow', ''));
      }
    }
  
    navigateButtonFocus(e, key) {
      e.preventDefault();
      let navigateTo;
  
      let targetDate = moment(e.target.getAttribute('data-date'), 'DD.MM.YYYY');
      if (key === 'right') {
        navigateTo = moment(targetDate).add(1, 'd').format("DD.MM.YYYY");
      }
      else if (key === 'left') {
        navigateTo = moment(targetDate).subtract(1, 'd').format("DD.MM.YYYY");
      }
      else if (key === 'up') {
        navigateTo = moment(targetDate).subtract(1, 'w').format("DD.MM.YYYY");
      }
      else if (key === 'down') {
        navigateTo = moment(targetDate).add(1, 'w').format("DD.MM.YYYY");
      }
  
      const foundElement = this.calendar.querySelector(`[data-date="${navigateTo}"]`);
      if (foundElement) {
        foundElement.focus();
        e.preventDefault();
      } else {
        if (key === 'left' || key === 'up') {
          this.visibleDate.subtract(1, 'month');
          this.appendCalendar();
        } else {
          this.visibleDate.add(1, 'month');
          this.appendCalendar();
        }
        this.calendar.querySelector(`[data-date="${navigateTo}"]`).focus();
      }
  
      this.activeDate = moment(navigateTo, 'DD.MM.YYYY');
    }
  
    generateMonthView() {
      let daysArray = Array.from({length: this.visibleDate.daysInMonth()}, (x, i) => this.activeDate.clone().startOf('month').add(i, 'days').format('DD'));
  
      daysArray = daysArray.map((day) => {
        const year = this.visibleDate.year();
        let month = this.visibleDate.month() + 1;
        if (month < 10) { month = `0${month}`; }
        return `${day}.${month}.${year}`;
      });
  
      const startOfMonth = this.visibleDate.clone().startOf('month').isoWeekday();
      const endOfMonth = this.visibleDate.clone().endOf('month').isoWeekday();
      const prevMonth = this.visibleDate.clone().startOf('month').subtract(1, 'month');
      const nextMonth = this.visibleDate.clone().startOf('month').add(1, 'month');
      const prevMonthLastDay = prevMonth.endOf('month').date();
  
      for( var i = 0; i <= startOfMonth - 2 ; i++) {
        const year = prevMonth.year();
        let month = prevMonth.month() + 1;
        if (month < 10) { month = `0${month}`; }
        const day = (prevMonthLastDay - i).toString();
        const date = `${day}.${month}.${year}`;
        daysArray.unshift(date);
      }
      
      for( var i = 1; i <= 7 - endOfMonth ; i++) {
        let start = i;
        if (start < 10) {
          start = `0${start}`;
        } else {
          start = start.toString();
        }
        const year = nextMonth.year();
        let month = nextMonth.month() + 1;
        if (month < 10) { month = `0${month}`; }
        const day = start;
        const date = `${day}.${month}.${year}`;
        daysArray.push(date);
      }
      this.daysArray = daysArray;
    }
  
    generateCalendar() {
      this.generateMonthView();
      this.calendar = document.createElement('div');
      this.calendar.setAttribute('class', 'twnCalendar');
      this.calendar.innerHTML = twnCalendarTemplate(this);
      return this.calendar;
    }
  
    appendCalendar() {
      if (this.calendar) {
        this.input.parentNode.removeChild(this.calendar);
      }
      const calendar = this.generateCalendar();
      this.input.parentNode.appendChild(calendar);
  
      if (!this.inline) {
        this.calendar.classList.add('twnCalendar__fixed');

        if(this.input.parentNode.offsetLeft > 0 && document.querySelectorAll('[class^="fontSize-"]')){
          calendar.style.left = 'unset';
          calendar.style.right = '0';
        }
      }

      this.bindCalendarEvents();
      this.bindKeyboard();
    }
  
    focusElement(element) {
      if (element) {
        element.focus();
      }
    }

    checkEvents(obj) {
      
      if(this.input.classList.contains('inline-calendar')){
        const url = document.querySelector('.event-data').getAttribute('data-events');

        $.ajax({
          url: url,
          dataType: 'json',
          success: function(data) {
            if (data.events){
              const dates = {};
              data.events.forEach((item) => {
                dates[item] = 'filled';
              });
              obj.data = dates;
            }
          }
        });
      }else {
        return false;
      }
    }
  
    bindCalendarEvents() {
  
      this.bindListener(this.calendar.querySelector('.twnCalendar__close'), 'click', (e) => {
        e.preventDefault();
        this.closeCalendar();
      });
  
      this.bindListener(this.calendar.querySelector('.twnCalendar__close'), 'keydown', (e) => {
        if (e.which === 9 && !e.shiftKey) {
          if (this.calendar.querySelector('.twnCalendar__prev')) {
            e.preventDefault();
            this.focusElement(this.calendar.querySelector('.twnCalendar__prev'));
          }
        }
        else if (e.which === 9 && e.shiftKey) {
          const focusableDate = this.activeDate.format('DD.MM.YYYY');
          if(this.calendar.querySelector(`[data-date="${focusableDate}"]`)) {
            this.calendar.querySelector(`[data-date="${focusableDate}"]`).focus();
            e.preventDefault();
          }
        }
      });
  
      this.bindListener(this.calendar.querySelector('.twnCalendar__next'), 'click', (e) => {
        e.preventDefault();

        this.visibleDate.add(1, 'month');
        this.checkEvents(this);
        this.appendCalendar();
        this.calendar.querySelector('.twnCalendar__next').setAttribute('aria-label', this.visibleDate.startOf("month").format('MMMM ') + this.labels.nextMonth);
        this.focusElement(this.calendar.querySelector('.twnCalendar__next'));
      });
  
      this.bindListener(this.calendar.querySelector('.twnCalendar__prev'), 'keydown', (e) => {
        if (e.which === 9 && e.shiftKey) {
          if (this.calendar.querySelector('.twnCalendar__close')) {
            e.preventDefault();
            this.focusElement(this.calendar.querySelector('.twnCalendar__close'));
          }
        }
      });
  
      this.bindListener(this.calendar.querySelector('.twnCalendar__prev'), 'click', (e) => {
        e.preventDefault();
        this.visibleDate.subtract(1, 'month');
        this.checkEvents(this);
        this.appendCalendar();
        this.calendar.querySelector('.twnCalendar__prev').setAttribute('aria-label', this.visibleDate.startOf("month").format('MMMM ') + this.labels.previousMonth);
        this.focusElement(this.calendar.querySelector('.twnCalendar__prev'));
      });
  
      this.bindListener(this.calendar.querySelector('.twnCalendar__years'), 'change', (e) => {
        this.visibleDate.set('year', this.calendar.querySelector('.twnCalendar__years').value);
        this.checkEvents(this);
        this.appendCalendar();
        this.focusElement(this.calendar.querySelector('.twnCalendar__years'));
      });
      
      this.bindListener(this.calendar.querySelector('.twnCalendar__months'), 'change', (e) => {
        this.visibleDate.set('month', this.calendar.querySelector('.twnCalendar__months').value);
        this.checkEvents(this);
        this.appendCalendar();
        this.focusElement(this.calendar.querySelector('.twnCalendar__months'));
      });
      
      this.calendar.querySelectorAll('[data-type="day"]').forEach((element) => {
        const date = element.getAttribute('data-date');
        this.bindListener(element, 'click', (e) => {
          e.preventDefault();
          this.selectDate(date)
          if (this.inline) {
            this.focusElement(this.calendar.querySelector(`[data-date="${date}"]`));
          }
        });
      });
      
      const availableFormItems = this.calendar.querySelector('.twnCalendar__header').querySelectorAll('button, select');
  
      this.bindListener(availableFormItems[availableFormItems.length - 1], 'keydown', (e) => {
        if (!e.shiftKey && e.which === 9) { 
          const focusableDate = this.activeDate.format('DD.MM.YYYY');
          if(this.calendar.querySelector(`[data-date="${focusableDate}"]`)) {
            this.calendar.querySelector(`[data-date="${focusableDate}"]`).focus();
            e.preventDefault();
          }
        };
      });
  
      if (!this.inline) {
        //this.focusElement(this.calendar.querySelector('.twnCalendar__prev'));
        this.bindListener(this.calendar, 'mousedown', (e) => {
          e.stopImmediatePropagation();
        });
      }
    }
  
    bindListener(element, event, callback) {
      if (element) {
        element.addEventListener(event, callback);
      }
    }
  
    selectDate(date) {
      let dateString = moment(date, 'DD.MM.YYYY').format(this.dateFormat);
      this.input.value = dateString;
      this.inputValue = dateString;
      const dayName = moment.weekdays()[moment(date, 'DD.MM.YYYY').day()];
      this.voiceOver(`${this.labels.selectedDate}: ${dayName} ${dateString}`);
      this.closeCalendar();
    }
  
    voiceOver(label) {
      if (this.readSelectedDate) {
        document.body.removeChild(this.readSelectedDate);
        this.readSelectedDate = false;
      }
      this.readSelectedDate = document.createElement('div');
      this.readSelectedDate.setAttribute('aria-label', label);
      this.readSelectedDate.setAttribute('role', 'alert');
      this.readSelectedDate.setAttribute('aria-atomic', 'true');
      this.readSelectedDate.style.position = 'absolute';
      this.readSelectedDate.style.top = '-10000px';
      document.body.appendChild(this.readSelectedDate);
    }
  
    closeCalendar() {
      if (!this.calendar) {return false;}
      if (this.inline) { this.input.dispatchEvent(new Event('change')); this.appendCalendar(); return false; }
      this.calendar.parentNode.removeChild(this.calendar);
      this.calendar = false;
      this.input.dispatchEvent(new Event('change'));
      if (this.hasDatepickerButton){
        this.calendarButton.parentNode.classList.remove('is-focused');
        this.focusElement(this.calendarButton);
      }
      this.input.removeAttribute('placeholder');
    }
  
    initCalendar() {
      this.inputValue = this.input.value;
      this.activeDate = this.inputValue !== '' ? moment(this.inputValue, this.dateFormat) : moment();
      if (this.maxYear < moment().format('YYYY')){
        this.visibleDate = this.activeDate.clone().set('year', this.maxYear);
      } else {
        this.visibleDate = this.activeDate;
      }
      if (this.hasDatepickerButton){
        this.calendarButton.parentNode.classList.add('is-focused');
        this.input.setAttribute('placeholder', this.placeholder);
      }
      this.appendCalendar();

    }
    
    initialize() {
      moment.updateLocale(this.locale, { week: {
        dow: 1,
      }});
  
      moment.locale(this.locale);
  
      if (this.showPlaceholderFormat) {
        this.input.setAttribute('placeholder', this.dateFormat.toLowerCase());
      }
      if (this.inline) {
        this.initCalendar();
      }
      this.bindEvents();
    }
  }
  
  const twnCalendarTemplate = (instance) => {
    
    const year = instance.visibleDate.year();
    const month = parseInt(instance.visibleDate.format('M'));
    const monthName = moment.months()[month-1];
    const selectedDate = moment(instance.inputValue, instance.dateFormat).format('DD.MM.YYYY');
    const data = {...instance.data};
    const now = moment().format('DD.MM.YYYY');

    const columns = () => {
      return instance.daysArray.chunk_inefficient(7).map((row) => {
        return `<tr>${row.map((col, index) => {
          const addonClasses = [];
          const isInactive = !col.match(`${month}.${year}`);
          if (isInactive){
            addonClasses.push('twnCalendar__day--inactive');
          }
          if (col === selectedDate) {
            addonClasses.push('twnCalendar__day--selected');
          }
          if (data[col]) {
            addonClasses.push(`twnCalendar__day--${data[col]}`);
          }
  
          if (col === now) {
            addonClasses.push('twnCalendar__day--today');
          }
          
          if (index === 5 || index === 6) {
            addonClasses.push('twnCalendar__day--weekend');
          }
  
          const currentDateAria = now === col ? 'aria-current="date"' : '';
          const selectedDateAria = col === selectedDate ? 'aria-selected="true"' : '';
  
          const classString = addonClasses.join(' ');
          const template = `<td>
                            <button
                              tabindex="-1"
                              role="button"
                              class="twnCalendar__day ${classString}"
                              data-type="day"
                              data-date="${col}"
                              ${currentDateAria}
                              ${selectedDateAria}
                              ${data[col] === 'filled' ? `aria-label="${moment.weekdays(true)[index]} ${col} event"` : ''}
                              aria-label="${moment.weekdays(true)[index]} ${col}">${ instance.twoDigitDays ? col.split('.')[0] : parseInt(col.split('.')[0])}</button>
                          </td>`;
          return instance.hideInactiveDates &&  isInactive ? '<td aria-hidden="true"></td>' : template;
        }).join('')}</tr>`;
      }).join('');
    };
  
    const days = () => {
      return `<tr>
        ${moment.weekdaysMin(true).map((item, index) => {
          const addonClasses = [];
          if (index === 5 || index === 6) {
            addonClasses.push('twnCalendar__day--weekend');
          }
          return `<th class="${addonClasses.join(' ')}">${item}</th>`;
        }).join('')}
      </tr>`;
    }
  
    const yearSlot = () => {
      if (!instance.monthYearSelectable) {
        return `${year}`;
      }
      const years = Array(instance.maxYear + 1 - instance.minYear).fill().map((item, index) => {
        return index + instance.minYear;
      }).reverse().map((item) => {
        const selected = instance.visibleDate.year() === item;
        return `<option value="${item}" ${selected ? 'selected' : ''}>${item}</option>`
      }).join('');
      return `<div class="twnCalendar__select"><select aria-label="${instance.labels.yearSelect}" class="twnCalendar__years">${years}</select><div class="twnCalendar__arrow"></div></div>`
    }
  
    const monthSlot = () => {
      if (!instance.monthYearSelectable) {
        return `${monthName}`;
      }
      const months = Array(12).fill().map((item, index) => {
        const selected = instance.visibleDate.month() === index;
        const monthNames = moment.months();
        return `<option value="${index}" ${selected ? 'selected' : ''}>${monthNames[index]}</option>`
      }).join('');
      return `<div class="twnCalendar__select"><select aria-label="${instance.labels.monthSelect}" class="twnCalendar__months">${months}</select><div class="twnCalendar__arrow"></div></div>`
    }
  
    return /*html*/`
      <div class="twnCalendar__header">
      ${ instance.hideMonthNavButtons ? '' : '<button class="twnCalendar__prev" role="button" aria-label="'+instance.labels.previousMonth+'"></button>' }
        <div class="twnCalendar__title">
          ${monthSlot()}
          ${yearSlot()}
        </div><!--/twnCalendar__title-->
        ${ instance.hideMonthNavButtons ? '' : '<button class="twnCalendar__next" role="button" aria-label="'+instance.labels.nextMonth+'"></button>' }
      </div><!--/twnCalendar__header-->
  
      <div class="twnCalendar__body">
        <table>
          <thead>
            ${days()}
          </thead>
          <tbody>
            ${columns()}
          </tbody>
        </table>
        ${ !instance.inline ? '<button class="twnCalendar__close" role="button" aria-label="'+instance.labels.close+'">Close</button>' : ''}
      </div><!--/twnCalendar__body-->
  
    `;
  };
  
  Object.defineProperty(Array.prototype, 'chunk_inefficient', {
    value: function(chunkSize) {
      var array = this;
      return [].concat.apply([],
        array.map(function(elem, i) {
          return i % chunkSize ? [] : [array.slice(i, i + chunkSize)];
        })
      );
    }
  });

  window.onload = () => {
    document.querySelectorAll('.custom-date-input, .inline-calendar').forEach((input) => {
      const instance = new twnDatepicker(input);
      
      if(input.classList.contains('inline-calendar')){
        const url = document.querySelector('.event-data').getAttribute('data-events');

        $.ajax({
          url: url,
          dataType: 'json',
          success: function(data) {
            if (data.events){
              const dates = {};
              data.events.forEach((item) => {
                dates[item] = 'filled';
              });
              instance.data = dates;
            }
            instance.initialize();
          }
        });
      }else {
        instance.initialize();
      }
    });
  };

}(window.jQuery);
/* window.jQuery to end !function */
/* !function to prevent library conflicts */
!function ($) {
  $.fn.formFilter = function () {
    $(this).each(function () {
      $.formFilter.init($(this));
    });
  };
  $.fn.formFilter = function () {
    $.formFilter.initialize($(this));
  };
  $.formFilter = {
    options: {},
    templates: {},
    values: {},
    containers: {
      activeFilters: ".gallery-filter-form"
    },
    initialize: function (form) {
      this.options.form = form;
      this.options.inputs = this.options.form.find(".js-range-slider, input[type='radio'],input[type='text'], input[type='checkbox'], select");
      this.bindFilters();
      this.bindHashChange();
      this.restoreCheckedStatus();
    },
    bindFilters: function () {
      var self = this;
      self.options.inputs.on("input", function (e) {
        e.preventDefault();
        var name = $(this).attr('name');
        var val = $(this).val();

        var relations = {
          'gallerySearch': '#edit-gallerysearchmobile',
          'gallerySearchMobile': '#edit-gallerysearch',
          'newsSearch': '#edit-newssearchmobile',
          'newsSearchMobile': '#edit-newssearch',
          'departments': '#worker-department',
          'positions': '#worker-position',
          'years': '#gallery-years',
          'contactsSearchMobile': '#edit-contactssearchmobile',
          'contactsSearch': '#edit-contactssearch',
          'article_type': '#article_type_mobile',
          'article_type_mobile': '#article_type_mobile',
        }
        if (relations[name]) {
          self.options.form.find(relations[name]).val(val);
        }
        if($("input[id~='article_type']")){
          var toFind = '#edit-article-type-mobile-'+$(this)[0].value;
          var boxToCheck = self.options.form.find(toFind);
          boxToCheck.prop('checked',$(this)[0].checked);
        }
        if($("input[id~='article_type_mobile']")){
          var toFind = '#edit-article-type-'+$(this)[0].value;
          var boxToCheck = self.options.form.find(toFind);
          boxToCheck.prop('checked',$(this)[0].checked);
        }
        self.pushURL();
      });
      self.options.inputs.on("change", function (e) {
        e.preventDefault();
        if ($(this).attr('name') === 'sort') {
          self.options.form.find('#sort-text').text($(this).next('label').text().toLowerCase().trim());
        }
        self.pushURL();
      });
      self.bindHashChange();
    },
    bindDeleteFilter: function () {
      var self = this;
      $(self.containers.activeFilters).find('a').unbind("click").bind("click", function (e) {
        e.preventDefault();
      });
      $(self.containers.activeFilters).find('.delete-filter').unbind("click").bind("click", function (e) {
        e.preventDefault();
        var rel = $(this).attr('rel');
        self.options.inputs.filter('[value="' + rel + '"]').trigger('click');
      });
      $(self.containers.activeFilters).find('.delete-all').unbind("click").bind("click", function (e) {
        e.preventDefault();
        var inputs = self.options.inputs.filter(":checked");
        inputs.trigger('click');
      });
    },

    pushURL: function (from, to) {
      var self = this;
      var inputs = self.options.inputs.filter(":checked, [type='text'], input[type='checkbox'], select");

      var hash = '';
      var hashArray = {};
      if (from || to) {
        var priceRange = "min_price=" + from + "&max_price=" + to
        hashArray.min = from
        hashArray.max = to
      } 

      inputs.each(function () {
        var input = $(this);
        var type = input.attr('type');
        var name = input.attr("name");
        var value = input.val() ? input.val().replace(';', '-') : undefined;
        if (type!='checkbox') {
          if (value) {
            if (hashArray[name]) {
              hashArray[name] = hashArray[name] + "," + value;
            } else {
              hashArray[name] = value;
            }
          }
        }
        else{
          var checked = input.prop('checked');
          if (checked) {
            if (value) {
              if (name) {
                if (hashArray[name]) {
                  hashArray[name] = hashArray[name] + "," + value;
                } else {
                  hashArray[name] = value;
                }
              }
            }
          }
        }
      });
      for (var i in hashArray) {
        if (hash !== "") {
          hash += "&"
        }
        hash += i + "=" + hashArray[i];
      };
      window.history.replaceState(undefined, undefined, '?' + hash);
      $(window).trigger('querychange');
    },
    hashChangeEvent() {
      var hash = window.location.search;
      this.options.hashArray = this.getParameters(hash);
      this.options.hash = hash;
      this.restoreCheckedStatus();
    },
    bindHashChange: function () {
      var self = this;
      $(window).on("querychange", function (e) {
        e.preventDefault();
        self.hashChangeEvent();
      });
    },
    restoreCheckedStatus() {
      var self = this;
      var hash = window.location.search;
      this.options.hashArray = this.getParameters(hash);
      self.options.inputs.each(function () {
        var input = $(this);
        var name = input.attr("name");
        var value = input.val();
        var filterValues = self.options.hashArray[name];
        if (filterValues) {
          //if (filterValues && (self.options.hashArray[name] == value)) {
          filterValues = filterValues.split(',');
          filterValues.forEach(function (item) {
            if (item === value) {
              input.prop("checked", true);
              input.parent().addClass("active").addClass('is-focused');
            }
          });
        } else {
          input.prop("checked", false);
          input.parent().removeClass("active");
        }
      });
      this.options.inputs.filter('[name="sort"]:checked').each(function () {
        self.options.form.find('#sort-text').text($(this).next('label').text().toLowerCase().trim());
      });
    },
    getParameters(hash) {
      params = {}
      var keyValuePairs = hash.substr(1).split('&');
      for (x in keyValuePairs) {
        var split = keyValuePairs[x].split('=', 2);
        params[split[0]] = (split[1]) ? decodeURI(split[1]) : "";
      }
      return params;
    }
  }
  $.fn.filterRefresh = function(){
    $("span[data-remove-item]").on('click',function(){
    var yearToRemove = $(this).attr("data-remove-item");
      console.log(yearToRemove);
    $("input[name='years["+yearToRemove+"]']").trigger("click");
    $("input[name='["+yearToRemove+"]']").trigger("click");
    // $("input[name='"+yearToRemove+"']").trigger("click");
    //Remove from active filter bar
    //$(this.parentElement).remove();
  });
  }
  $(document).ready(function () {
    $("span[data-remove-item]").on('click',function(){
      var yearToRemove = $(this).attr("data-remove-item");
      $("input[name='years["+yearToRemove+"]']").trigger("click");
      // $("input[name='["+yearToRemove+"]']").trigger("click");
      // const url = new URL(window.location.href)
      // const urlObj = new URL(url);
      // const params = urlObj.searchParams
      // const $checks = $(':checkbox')
      // // on page load check the ones that exist un url
      // params.forEach((val, key) => $checks.filter('[name="' + key + '"]').prop('checked', true));
      //
      // $checks.change(function(){
      //   // append when checkbox gets checked and delete when unchecked
      //   if(this.checked){
      //     params.append(this.name, 'true')
      //   }else{
      //     params.delete('departments');
      //     params.delete(this.name);
      //   }
      //   window.location = urlObj.href;
      //
      // })
      //Remove from active filter bar
      //$(this.parentElement).remove();
    });
    $(window).on('load', function () {
      $("input[data-remove-checkbox-item]").on('click',function() {
        var yearToRemove = $(this).attr("data-remove-checkbox-item");
        $("input[name='years[" + yearToRemove + "]']").trigger("click");
        $(this.parentElement).remove();
      });
      $.fn.formFilter = function () {
        $(this).each(function () {
          $.formFilter.init($(this));
        });
      };
    })
    $('[role="filter"]').formFilter();
  });
  }(window.jQuery);
  
/* !function to prevent library conflicts */
!function($) {

	$(function() {

		$.fn.mobileMenu = function() {
			var main = $(this);
			var trigger = $('.mobile-banner');
			var mobileMenu = trigger.find('.mobile-menu');
			var logo = $('.header-logo-content');
			var menuDropdown = mobileMenu.find('.main-menu');
			var menuItem = menuDropdown.find('>li');
			var menuLink = menuItem.find('>a');
			var lastObj = mobileMenu.find('.main-focus-trap-last');
			var mobileSearch = $('.mobile-search-overlay');

			mobileMenuHeight();

			menuItem.each(function(){
				var ob = $(this);
				var mLink = ob.find('>a');
				var arrowTemplate ='<span class="mdi mdi-chevron-down" aria-hidden="true"></span>';

				if(ob.children().length > 1){
					mLink.append(arrowTemplate);
				}
			});

			var state = false;

			main.on('click', function(e) {
				e.preventDefault();

				state = !state;

				if(state){
					trigger.addClass('menu');
					$('.page-main').attr('aria-hidden','true').attr('inert', ' ');
					$('.main-footer').attr('aria-hidden','true').attr('inert', ' ');
					main.focus();
					main.attr('aria-expanded', 'true');
					$('html').addClass('scroll-lock');
					lastObj.attr('tabindex','0');
				}else {
					removeAttributes();
					lastObj.attr('tabindex','-1');
				}

				tabFocusTrap();

				menuLink.on('click', function(){
					var obj = $(this);
					var backLink = obj.parent().find('.back-to-menu');
					var trapFirst = obj.parent().find('.focus-trap-first');
					var trapLast = obj.parent().find('.focus-trap-last');
					var dropdownMenuElements = obj.parent().find('.dropdown-link-block>li');

					obj.parent().addClass('open');

					$('.main-menu-dropdown').attr('aria-hidden', 'false');
					obj.attr('aria-expanded', 'true');
					trapLast.attr('tabindex', '0');
					trapFirst.attr('tabindex', '0');

					setTimeout(function(){
						dropdownMenuElements[1].children[0].focus();
						$('.main-menu.mobile').css('visibility', 'hidden');
					},350);

					trapFirst.on('keyup', function(e){
						if(e.shiftKey && e.keyCode === 9) {
							e.preventDefault();
							return false;
						}else if (e.keyCode === 9){
							e.preventDefault();
							backLink.focus();
						}
					});

					trapLast.on('keyup', function(e){
						if(e.keyCode == 9 || e.which == 9) {
							e.preventDefault();
							backLink.focus();
						}
					});

					backLink.on('click', function(e){
						e.preventDefault();
						closeSubmenu(obj);
						obj.focus();
					});

					main.on('click', function(){
						closeSubmenu(obj);
						$('.focus-trap-last').attr('tabindex', '-1');
					});
				});

				function closeSubmenu(obj){
					obj.parent().removeClass('open');
					obj.parent().find('>a').attr('aria-expanded', 'false');
					$('.focus-trap-first').attr('tabindex', '-1');
					$('.main-menu-dropdown').removeAttr('aria-hidden');
					$('.main-menu.mobile').css('visibility','visible');
				}

				function tabFocusTrap(){
					$(document).off('keyup').on('keyup', function(e){
						lastObj.on('keyup', function(e){
							if(e.keyCode == 9 || e.which == 9 ) {
								e.preventDefault();
								logo.focus();
							}else if (e.keyCode === 39 || e.which === 39) {
								e.preventDefault();
								logo.focus();
							}
						});

						if(e.keyCode == 27){
							var searchMenu = $('.header-wrapper');

							if(searchMenu.hasClass('search-visible')){
								searchMenu.removeClass('search-visible');
							}

							removeAttributes();
							$('.main-focus-trap-last').attr('tabindex','-1');
							menuItem.removeClass('open');
							menuLink.attr('aria-expanded', 'false');
						}
					});
				}

				function removeAttributes() {
					state = false;
					main.attr('aria-expanded','false');
					trigger.removeClass('menu');
					$('html').removeClass('scroll-lock');
					$('.focus-trap-first').attr('tabindex','-1');
					$('.focus-trap-last').attr('tabindex', '-1');
					$('.page-main').removeAttr('aria-hidden')
					main.focus();
					$('.page-main').removeAttr('aria-hidden').removeAttr('inert');
					$('.main-footer').removeAttr('aria-hidden').removeAttr('inert');
				}
			});

			function mobileMenuHeight(){
				var headerWrapper = $('.header-wrapper');
				var headerWrapperHeight = headerWrapper.height();
				mobileMenu.css('top', headerWrapperHeight);
				mobileSearch.css('height', headerWrapperHeight);
			}
		}

		$.fn.mainMenuDropdown = function() {
			$(this).each(function() {
				var main = $(this);
				var li = main.find('>li');
				var activeClass = 'open';
				var arrowTemplate = '<span class="mdi mdi-menu-down"></span>';

				li.filter(".active").addClass(activeClass);

				li.on('show', function() {
					var obj = $(this);
					obj.addClass(activeClass);
					obj.children('a').attr("aria-expanded", "true");

					menuPosition();
				});

				li.on('hide', function() {
					var obj = $(this);
					obj.removeClass(activeClass);
					obj.children('a').attr("aria-expanded", "false");
					$('.desktop-menu .main-menu-dropdown').css({'left': '', 'right': ''});
				});

				function liToggle(obj) {
					if (obj.is('.' + activeClass)) {
						obj.trigger('hide');
					} else {
						li.not(obj).trigger('hide');
						obj.trigger('show');
					}
				}

				function documentClick(eventName, obj) {
					$(document).on(eventName, function (e) {
						if ($(e.target).parents('.main-menu').length == 0) {
							obj.trigger('hide');
							$(document).off(eventName);
						}
					});
				}

				function menuPosition() {
					var menuDropdown = $('.desktop-menu .main-menu-dropdown');
					var wrapperWidth = $('.header-wrapper').width();

					menuDropdown.each(function(){
						var el = $(this);
						var offsetLeft = (el.offset().left);
						var menuWidth = el.width();
						var checkMenuWidth = offsetLeft + menuWidth;
						var offsetRight = window.innerWidth - offsetLeft - menuWidth;

						if(checkMenuWidth > wrapperWidth) {
							el.css({'left': 'auto', 'right': '0'});
						}

						if(el.offset().left < 0 || offsetRight > 0) {
              el.css({'left': 'auto', 'right': 'auto'});
            }
					});
				}

				li.each(function() {
					var obj = $(this);
					var anchorTag = obj.children("a");
					var eventName = 'click.' + Math.random().toString().substr(2);

					if (obj.children(".main-menu-dropdown").length == 1) {
						anchorTag.append(arrowTemplate);
						anchorTag.addClass('special');
						obj.children("a, span").on('click', function (e) {
							e.preventDefault();
							documentClick(eventName, obj);
							liToggle(obj);
						});
					}
				});
			});
		}

		$.fn.dropdownMenu = function() {
			var ul = $.merge($(this), $(this).find('ul'));
			var liLimit = 3;

			ul.each(function() {
				var obj = $(this);
				var li = obj.children();
				var showMore = li.filter('.show-more');
				var showButton = showMore.find('.btn-show-more');
				var status = false;
				var subDropdown = li.filter('.sub-dropdown');

				if (li.length-1 > liLimit) {
					li.eq(liLimit-1).nextAll().not('.show-more').addClass('md-hidden');
				} else {
					showMore.hide();
				}

				showMore.on('click', function() {
					status = !status;
					if (status)  {
						li.removeClass('md-hidden');
						showMore.find('span').text(showMore.attr('data-showless'));
						showMore.addClass('show');
						showButton.attr('aria-expanded', 'true');
					} else {
						li.eq(liLimit-1).nextAll().not('.show-more').addClass('md-hidden');
						showMore.find('span').text(showMore.attr('data-showmore'));
						showMore.removeClass('show');
						showButton.attr('aria-expanded', 'false');
					}
				});

				li.each(function() {
					var obj = $(this);
					var anchor = obj.children('a');
					var subMenu = obj.children('.sub-dropdown');
					var subAnchor = subMenu.find('a');

					if (obj.not('.show-more')) {
						obj.children('ul').length > 0 ? obj.addClass('has-dropdown') : obj.not('.show-more').addClass('has-link');
					}

					if (obj.children('ul').length) {
						anchor.prepend('<span class="mdi mdi-chevron-down"></span>');

						anchor.on('click', function(e) {
							//e.preventDefault();

							if (obj.hasClass('open')) {
								li.not(obj).removeClass('md-hidden');
								obj.removeClass('open');
								anchor.attr('aria-expanded', 'false');
								li.filter('.show-more').hide();
								obj.parent().removeClass('menu-open');

								if(!(obj.hasClass('open') && li.parent().hasClass('menu-open'))){
									li.eq(liLimit-1).nextAll().not('.show-more').addClass('md-hidden');
								}

								if(li.filter('.show-more').hasClass('show')){
									li.eq(liLimit-1).nextAll().not('.show-more').removeClass('md-hidden');
								}

							}	else {
								li.not(obj).not('.show-more').addClass('md-hidden');
								obj.addClass('open');
								anchor.attr('aria-expanded', 'true');
								li.filter('.show-more').show();
								obj.parent().addClass('menu-open');
							}

							if(showMore.hasClass('show') && obj.hasClass('open') || obj.parent().hasClass('menu-open')){
								showMore.hide();
							}else {
								showMore.show();
							}
						});

						if($(window).width() <= 991){
							subAnchor.on('click', function(){
								var el = $(this);
								var backBtn = el.parent().find('.back-to-menu');
								var subShowMore = subMenu.find('.show-more');

								if(el.parent().hasClass('open')){
									subAnchor.not('.back-to-menu').show();
									anchor.show();
									backBtn.css('display','none');
									subMenu.removeClass('show');
									el.parent().removeClass('open');
									subShowMore.show();
								}else {
									subAnchor.hide();
									anchor.hide();
									backBtn.css('display', 'flex');
									subMenu.addClass('show');
									el.parent().addClass('open');
									subShowMore.hide();
								}

								// Menu flipping in 4th level is done by BE
							});
						}
					}
				});
			});
		};

		$.fn.accessibility = function(){
			$(this).each(function(){
				var main = $(this);
				var accessibilityWrapper = $('.accessibility');
				var closeModal = accessibilityWrapper.find('.btn-close-accessibility');
				var input = accessibilityWrapper.find('input');
				var checkboxes = accessibilityWrapper.find('input[type="checkbox"]');

				if(main.is('button')){
					main.on('click', function(e){
						e.preventDefault();
						accessibilityWrapper.hasClass('open') ? accessibilityWrapper.removeClass('open') && accessibilityWrapper.attr('aria-expanded', 'false') : accessibilityWrapper.addClass('open') && accessibilityWrapper.attr('aria-expanded', 'true');
						main.hasClass('open') ? main.removeClass('open') : main.addClass('open');
						closeModal.focus();
					});

					closeModal.on('click', function(e){
						e.preventDefault();
						accessibilityWrapper.hasClass('open') ? accessibilityWrapper.removeClass('open') && accessibilityWrapper.attr('aria-expanded', 'false') : accessibilityWrapper.addClass('open') && accessibilityWrapper.attr('aria-expanded', 'true');
						main.hasClass('open') ? main.removeClass('open') : main.addClass('open');
					});

					changeValues();
				}else {
					changeValues();
				}

				function changeValues(){
					accessibilityWrapper.each(function(){
						var array = {};
						var html = $('html:first');

						input.each(function(){
							var obj = $(this);
							var inputVal = obj.val();
							var inputName = obj.attr('name');

							obj.on('change', function(){
								if(obj.is(':checked')){
									if($(window).width() <= 991 && obj.is(':radio')){
										if (inputName === 'fontSize-mobile'){
											if(inputVal === '2x'){
												html.addClass('fontSize-mobile-2x');
												html.removeClass('fontSize-mobile-4x');
												checkboxes.parent().addClass('disabled');
												checkboxes.attr('disabled',true);
												createCookie(inputName, inputVal, 20);
												removeCheck();
												mobileMenuHeight();
											}else if(inputVal === '4x'){
												html.addClass('fontSize-mobile-4x');
												html.removeClass('fontSize-mobile-2x');
												checkboxes.parent().addClass('disabled');
												checkboxes.attr('disabled',true);
												createCookie(inputName, inputVal, 20);
												removeCheck();
												mobileMenuHeight();
											}else if (inputVal === '1x'){
												html.removeClass('fontSize-mobile-2x');
												html.removeClass('fontSize-mobile-4x');
												checkboxes.attr('disabled', false);
												checkboxes.parent().removeClass('disabled');
												eraseCookie(inputName);
												mobileMenuHeight();
											}
										}else if(inputName === 'pageContrast-mobile'){
											if(inputVal === 'normal'){
												html.removeClass('pageContrast-mobile-high');
												eraseCookie(inputName);
											}else {
												html.addClass('pageContrast-mobile-high');
												createCookie(inputName, inputVal, 20);
											}
										}
									}else {
										if (inputName === "fontSize"){
											if(inputVal === '2x'){
												html.addClass('fontSize-2x');
												html.removeClass('fontSize-4x');
												checkboxes.attr('disabled',true);
												checkboxes.parent().addClass('disabled');
												removeCheck();
												createCookie(inputName, inputVal, 20);
											}else if(inputVal === '4x'){
												html.addClass('fontSize-4x');
												html.removeClass('fontSize-2x');
												checkboxes.attr('disabled',true);
												checkboxes.parent().addClass('disabled');
												removeCheck();
												createCookie(inputName, inputVal, 20);
											}else if (inputVal === '1x'){
												html.removeClass('fontSize-2x');
												html.removeClass('fontSize-4x');
												checkboxes.attr('disabled',false);
												checkboxes.parent().removeClass('disabled');
												eraseCookie(inputName);
											}
										}else if(inputName === 'paragraphSpacing'){
											html.addClass('paragraphSpacing-high');
											createCookie(inputName, inputVal, 20);
										}else if (inputName === 'letterSpacing') {
											html.addClass('letterSpacing-high');
											createCookie(inputName, inputVal, 20);
										}else if (inputName === 'wordSpacing'){
											html.addClass('wordSpacing-high');
											createCookie(inputName, inputVal, 20);
										}else if (inputName === 'pageContrast'){
											if(inputVal === 'normal'){
												html.removeClass('pageContrast-high');
												eraseCookie(inputName);
											}else {
												html.addClass('pageContrast-high');
												createCookie(inputName, inputVal, 20);
											}
										}
									}
								}else {
									delete array[inputName];
									eraseCookie(inputName);

									if(html.hasClass('paragraphSpacing-high') || html.hasClass('letterSpacing-high') || html.hasClass('wordSpacing-high')){
										html.removeClass($(this).attr('name') +'-'+ $(this).val());
									}
								}
							});
						})
					});
				}

				function removeCheck(){
					checkboxes.each(function(){
						var el = $(this);

						if(el.is(':checked')){
							inputName = $(this).attr('name');

							if(inputName === 'paragraphSpacing'){
								$('html').removeClass('paragraphSpacing-high');
								$(this)[0].checked = false;
								eraseCookie(inputName);
							}else if (inputName === 'letterSpacing'){
								$('html').removeClass('letterSpacing-high');
								$(this)[0].checked = false;
								eraseCookie(inputName);
							}else if (inputName === 'wordSpacing'){
								$('html').removeClass('wordSpacing-high');
								$(this)[0].checked = false;
								eraseCookie(inputName);
							}
						}
					});
				}

				function mobileMenuHeight(){
					var headerWrapper = $('.header-wrapper');
					var headerWrapperHeight = headerWrapper.height();
					var mobileMenu = $('.mobile-menu');
					var mobileSearch = $('.mobile-search-overlay');
					mobileMenu.css('top', headerWrapperHeight);
					mobileSearch.css('height', headerWrapperHeight);
				}

				var cookies = ['pageContrast','pageContrast-mobile','fontSize','fontSize-mobile','paragraphSpacing','letterSpacing', 'wordSpacing'];

				for( var i in cookies ){
					var cookie = cookies[i];

					if( readCookie( cookie ) ){
						var checkbox = $('.accessibility').find('input[type="checkbox"]');

						if(!$("html").hasClass(cookie+"-"+readCookie(cookie))){
							$("html").addClass(cookie+"-"+readCookie(cookie));
							input.filter("[name='"+cookie+"'][value='"+readCookie(cookie)+"']").attr("checked", true);

							if($("html").hasClass('fontSize-2x') || $("html").hasClass('fontSize-4x') || $("html").hasClass('fontSize-mobile-2x') || $("html").hasClass('fontSize-mobile-4x')){
								checkbox.parent().addClass('disabled');
								checkbox.attr('disabled', true);
								checkbox.attr('checked', false);
								$('html').removeClass('paragraphSpacing-high').removeClass('letterSpacing-high').removeClass('wordSpacing-high');
							}else {
								checkbox.attr('disabled',false);
								checkbox.parent().removeClass('disabled');
							}
						}
					}
				}
			});
		}

		$.fn.shareModal = function(){
			$(this).each(function(){
				var main = $(this);
				var modalWrapper = $('.share-wrapper');
				var modal = modalWrapper.find('.share-modal');
				var closeModal = modal.find('.btn-close-modal');
				var facebookBtn = modal.find('.share-facebook');
				var twitterkBtn = modal.find('.share-twitter');
				var copyLinkBtn = modal.find('.copy-link');
				var topTrap = '<div class="focus-trap-first" tabindex="0"></div>';
				var bottomTrap = '<div class="focus-trap-last" tabindex="0"></div>';

				main.on('click', function(e){
					var el = $(this);
					e.preventDefault();
					modalWrapper.addClass('open');
					closeModal.focus();

					modal.prepend(topTrap)
					modal.append(bottomTrap)

					var firstTrap = modal.find('.focus-trap-first');
					var lastTrap = modal.find('.focus-trap-last');

					closeModal.off('click').on('click', function(e){
						closeShareModal();
					});

					var shareUrl = main.data('url');
					var fbPrefix = 'https://www.facebook.com/sharer/sharer.php?u=';
					var twPrefix = 'https://twitter.com/intent/tweet?url=';
					var pageUrl = window.location.href;

					if(shareUrl){
						facebookBtn.attr('href', fbPrefix + shareUrl);
						twitterkBtn.attr('href', twPrefix + shareUrl);
					}else {
						facebookBtn.attr('href', fbPrefix + pageUrl);
						twitterkBtn.attr('href', twPrefix + pageUrl);
					}

					tabFocusTrap(firstTrap, lastTrap, modal, closeModal);

					function closeShareModal() {
						$(document).off('keyup');
						modalWrapper.removeClass('open');
						firstTrap.remove();
						lastTrap.remove();
						main.focus();
					}

					function tabFocusTrap(firstItem, lastItem, menu, close){
						$(document).on('keyup', function(e){
							lastItem.on('keyup', function(e){
								if(e.keyCode == 9 || e.which == 9) {
									close.focus();
								}
							});

							firstItem.on('keyup', function(e){
								if(e.keyCode === 9 || e.which === 9 && e.keyCode === 16 || e.which === 16) {
									menu.children().last().find('a:last-of-type').focus();
								}
							});

							if(e.keyCode == 27 || e.which == 27){
								closeShareModal();
							}
						});
					}

					copyLinkBtn.on('click', function(e){
						e.preventDefault();
						var shareUrl = el.data('url');
						var temp = $('<input>')
						$('body').append(temp);
						temp.val(shareUrl).select();
						document.execCommand("copy");
						temp.remove();
					});
				});
			});
		}

		$.fn.languageDropdown = function(){
			$(this).each(function(){
				var main = $(this);

				main.on('click',function(e){
					e.preventDefault();
					main.parent().toggleClass('open');
					main.parent().hasClass('open') ? main.attr('aria-expanded', 'true') : main.attr('aria-expanded', 'false');
				});

				$(window).on('click', function(e){
					if($(e.target).parents('.language-picker').length == 0){
						main.parent().removeClass('open');
						main.attr('aria-expanded', 'false');
					};
				});

				$(document).on('keyup', function(e){
					if(e.keyCode == 27 || e.which == 27){
						main.parent().removeClass('open');
						main.attr('aria-expanded', 'false');
					}
				});
			});
		}

		$.fn.mobileSearch = function(){
			$(this).each(function(){
				var main = $(this);
				var headerWrapper = $('.header-wrapper');

				main.on('click', function(e){
					e.preventDefault();
					var searchOverlay = headerWrapper.find('.mobile-search-overlay');
					var searchInput = searchOverlay.find('input');
					var closeBtn = searchOverlay.find('.close-btn-search');

					headerWrapper.toggleClass('search-visible');

					setTimeout(function(){
						searchInput.focus()
					},250);

					headerWrapper.hasClass('search-visible') ? main.attr('aria-expanded', 'true') : main.attr('aria-expanded', 'false');

					closeBtn.on('click', function(e){
						headerWrapper.removeClass('search-visible');
						main.attr('aria-expanded', 'false');
						main.focus();
					});
				});

				$(document).on('keyup', function(e){
					if(e.keyCode == 27){
						headerWrapper.removeClass('search-visible');
						main.attr('aria-expanded', 'false');
						main.focus();
					}
				})
			});
		}

		$.fn.tooltip = function(){
			$(this).each(function(){
				var main = $(this);
				var tooltipTitle = main.attr('data-tooltip-title');

				if(main.parent().is('.swiper-slide')){
					main.tooltipster({
						trigger: 'hover',
						content: tooltipTitle,
						maxWidth: 190,
						animation: 'fade',
						theme: 'tooltipster-default',
						side: 'bottom',
						functionPosition: function(instance, helper, position){
							position.coord.bottom -= 10;
							return position;
						}
					});
				}else {
					main.tooltipster({
						trigger: 'click',
						content: tooltipTitle,
						animation: 'fade',
						theme: 'tooltipster-default',
					});
				}
			});
		}

		$.fn.movingLabel = function() {
			$(this).each(function() {
				var main = $(this);
				var input = main.find('input, select, textarea, button');

				input.val() == "" || input.val() == null ? main.removeClass('is-focused') : main.addClass('is-focused');

				main.on('focusin', function(){
					main.addClass('is-focused');
				});

				main.on('focusout', function(){
					main.removeClass('is-focused');
					if (input.val() == "") {
						main.removeClass('is-focused');
					} else {
						main.addClass('is-focused');
					}
				});

			});
		}

		$.fn.filtersModal = function() {
			var main = $(this);
			var modal = $('.filters-wrapper--mobile');
			var modalClose = modal.find('.btn-close');
			var firstItem = modal.find('.modal-header').children().first();
			var lastItem = modal.find('.filters-bottom').children().last();
			var lastItemContact = modal.find('.form-row-items').children().last();
			var readyBtn = modal.find('.filters-ready');

			main.on('click', function(e) {
				e.preventDefault();
				$('body').addClass('modal-open');
				modal.addClass('modal-open');
				modalClose.focus();

				if (modal.hasClass('modal-open')) {
					modalClose.on('click', function (e) {
						e.preventDefault();
						$('body').removeClass('modal-open');
						modal.removeClass('modal-open');
						main.focus();
					});
				}

				tabFocusTrap(lastItem, modalClose);
				tabFocusTrap(lastItemContact, modalClose);
			});

			function tabFocusTrap(lastItem, close){
				$(document).on('keyup', function(e){
					lastItem.on('keyup', function(e){
						if(e.keyCode == 9 || e.which == 9) {
							e.preventDefault();
							close.focus();
						}
					});

					firstItem.on('keyup', function(e){
						if(e.keyCode == 9 || e.which == 9 && e.keyCode == 16 || e.which == 16) {
							e.preventDefault();
							readyBtn.focus();
						}
					});

					if(e.keyCode == 27){
						modal.removeClass('modal-open');
						main.focus();
					}
				});
			}

			$(window).on('keyup', function(e){
				if(e.keyCode === 27 || e.which === 27) {
					$('body').removeClass('modal-open');
				}
			});
		}

		$.fn.rateCheckbox = function(){
			$(this).each(function(){
				var main = $(this);
				var rateStar = main.find('[role="checkbox"]');

				rateStar.on('mouseover', function(){
					var onStar = parseInt($(this).data('value'), 10);

					rateStar.each(function(e){
						if (e < onStar) {
							$(this).addClass('hover');
						}
						else {
							$(this).removeClass('hover');
						}
					});
				}).on('mouseout', function(){
					rateStar.each(function(e){
						$(this).removeClass('hover');
					});
				});

				rateStar.on('click', function(){
					var obj = $(this);
					var onStar = parseInt(obj.data('value'), 10);
					var emptyRating = $('.rate-wrapper').find('.empty-rating');

					selectStar(onStar);

					emptyRating.css('display', 'flex');

					emptyRating.on('click', function(e){
						e.preventDefault();
						rateStar.removeClass('selected');
						rateStar.removeClass('hover');
						rateStar.attr('aria-checked', 'false');
					});

				});

				rateStar.on('keyup', function(e){
					var obj = $(this);
					var onStar = parseInt(obj.data('value'), 10);
					var emptyRating = $('.rate-wrapper').find('.empty-rating');

					if(e.keyCode == 13 || e.which == 13) {
						e.preventDefault();
						selectStar(onStar);

						emptyRating.css('display', 'flex');

						emptyRating.on('click', function(e){
							e.preventDefault();
							rateStar.removeClass('selected');
							rateStar.removeClass('hover');
							rateStar.attr('aria-checked', 'false');
						});
					}
				});

				function selectStar(star) {
					for (i = 0; i < rateStar.length; i++) {
						$(rateStar[i]).removeClass('selected').attr('aria-checked','false');
					}

					for (i = 0; i < star; i++) {
						$(rateStar[i]).addClass('selected').attr('aria-checked','true');
					}
				}
			});
		}

		$.fn.rateIt = function(){
			$(this).each(function(){
				var main = $(this);
				var buttonText = main.parent().find('input').data('btn-text');
				var rangeWrapper = main.find('.rateit-range');
				var btnReset = main.find('.rateit-reset');
				var buttonHtml = btnReset.find('span');
				var ariaDescribe = main.parent().find('input').attr('data-describe');

				buttonHtml.html(buttonText);
				btnReset.insertAfter(rangeWrapper);

				rangeWrapper.on('click', function() {
					buttonHtml.show();
				});

				rangeWrapper.on('keydown', function(e){
					if(e.keyCode == 39 || e.which == 39) {
						buttonHtml.show();
					}
				});

				rangeWrapper.on('touchstart', function(e){
					buttonHtml.show();
				});

				main.rateit();

				if(ariaDescribe){
					main.rateit().find('.rateit-range').attr('aria-describedby', ariaDescribe);
				}

			});
		}

		$.fn.customNumbers = function(){
			$(this).each(function(){
				var main = $(this);
				var stepUp = main.parent().find('.step-up');
				var stepDown = main.parent().find('.step-down');
				var min = main.attr('min');
				var max = main.attr('max');

				stepUp.off('click').on('click.customNumbers', function(e){
					e.preventDefault();
					var currentVal = parseFloat(main.val());

					main.parent().addClass('is-focused');

					if(main.val() === '' || main.val() === NaN){
						main.val(min);
					}else if (currentVal >= max) {
						main.val(max);
					}else {
						main.val(currentVal + 1);
					}

					main.trigger('change');
				});

				stepDown.off('click').on('click.customNumbers', function(e){
					e.preventDefault();
					var currentVal = parseFloat(main.val());

					if(currentVal <= min || main.val() === NaN){
						main.val(min)
					} else if(currentVal > max){
						main.val(max)
					}else {
						main.val(currentVal - 1);
					}
					main.trigger('change');
				});
			});
		}

		$.fn.customTimePicker = function(){
			$(this).each(function(){
				var main = $(this);

				main.timepicker({
					timeFormat: 'H:i',
					show2400: true,
					minTime: '00:00',
					maxTime: '24:00',
					step: 10,
					startTime: new Date(0,0,0,15,0,0),
					change: function(){
						main.parent().addClass('is-focused');
					}
				});
			});
		}

		$.fn.selectTwo = function(){
			$(this).each(function(){

				var main = $(this);
				var dropdownParent = main.parent();
				var label = main.parent().find('.form-label');
				var btnArrow = main.parent().find('.select-arrow');
				var ariaDesc = main.attr('data-describe');
				var accordion = main.attr('data-changeAccordion');
				if (accordion) {
					main.on('select2:select',function(e){
						accordion_id = e.params.data.id;
						main.select2ContentChange(accordion_id);
					});
				}
				main.select2({
					placeholder: '',
					dropdownParent: dropdownParent
				});

				label.on('click', function(){
					main.select2('open');
				});

				btnArrow.on('click', function(e){
					e.preventDefault();
					main.select2('open');
				});

				main.on('select2:open', function(e){
					var ariaInfo = main.parent().find('.select2-selection');

					main.parent().addClass('is-focused');
					main.parent().find('.form-label').addClass('open-label');
					main.parent().find('.select-arrow').addClass('open-arrow');

					ariaInfo.attr('aria-describedby', ariaDesc);
				});

				main.on('select2:close', function(e){
					var ariaInfo = main.parent().find('.select2-selection');

					if(main.val() == null){
						main.parent().removeClass('is-focused');
					}

					main.parent().find('.form-label').removeClass('open-label');
					main.parent().find('.select-arrow').removeClass('open-arrow');
					ariaInfo.removeAttr('aria-describedby');
				});

				// on first focus (bubbles up to document), open the menu
				$(document).on('focus', '.select2-selection.select2-selection--single', function (e) {
					$(this).closest(".select2-container").siblings('select:enabled').select2('open');
				});

				// steal focus during close - only capture once and stop propogation
				$('select.select2').on('select2:closing', function (e) {
					$(e.target).data("select2").$selection.one('focus focusin', function (e) {
						e.stopPropagation();
					});
				});

				$(document).on('click', function (e) {
					if ($(e.target).parents('.custom-select').length == 0 && main.val() == null) {
						main.parent().removeClass('is-focused');
					}
				});

				$(window).on('load', function(){
					if($(window).width() < 991) {
						$('.select2-container').css({'min-width': '100%', 'width' : '100%'})
					}
				});
				debounce = setTimeout(function(){
					if($(window).width() < 991) {
						$('.select2-container').css({'min-width': '100%', 'width' : '100%'})
					}
				  }, 300);
			});
		}

		$.fn.customTel = function(){
			$(this).each(function(){
				var main = $(this);

				main.intlTelInput();

				if(main.attr('disabled')){
					main.intlTelInput().parent().find('.iti__selected-flag').attr('tabindex', '-1');
				}
			});
		}

		$.fn.printPage = function(){
			$(this).each(function(){
				var main = $(this);

				main.on('click', function(){
					setTimeout(window.print(), 1000);
				})
			});
		}

		$.fn.accordion = function(){
			$(this).each(function(){
				var main = $(this);
				var accordionTitle = main.find('.accordion__title');

				accordionTitle.on('click', function(){
					var el = $(this);
					var accordionParent = el.parent();
					var accordionButton = el.find('.btn-accordion');
					accordionParent.toggleClass('active');

					if(accordionParent.hasClass('active')){
						accordionButton.attr('aria-expanded', 'true')
					}else{
						accordionButton.attr('aria-expanded', 'false')
					}
				});
			});
		}

		$.fn.tabs = function(){
			$(this).each(function(){

				var el = this;
				var tablist = el.querySelector('[role="tablist"]');
				var tabs;
				var panels;
				var delay = determineDelay();
				generateArrays();

				function generateArrays () {
					tabs = el.querySelector('.tabs__navigation').querySelectorAll('[role="tab"]');
					panels = $(el).find('.tabs__panels:first').children('[role="tabpanel"]');
				};

				// For easy reference
				var keys = {
					end: 35,
					home: 36,
					left: 37,
					up: 38,
					right: 39,
					down: 40,
					delete: 46
				};

				// Add or substract depending on key pressed
				var direction = {
					37: -1,
					38: -1,
					39: 1,
					40: 1
				};

				// Bind listeners
				for (i = 0; i < tabs.length; ++i) {
					addListeners(i);
				};

				function addListeners (index) {
					tabs[index].addEventListener('click', clickEventListener);
					tabs[index].addEventListener('keydown', keydownEventListener);
					tabs[index].addEventListener('keyup', keyupEventListener);

					// Build an array with all tabs (<button>s) in it
					tabs[index].index = index;
				};

				// When a tab is clicked, activateTab is fired to activate it
				function clickEventListener (event) {
					var tab = event.target;
					activateTab(tab, false);
				};

				// Handle keydown on tabs
				function keydownEventListener (event) {
					var key = event.keyCode;

					switch (key) {
						case keys.end:
							event.preventDefault();
							// Activate last tab
							activateTab(tabs[tabs.length - 1]);
							break;
						case keys.home:
							event.preventDefault();
							// Activate first tab
							activateTab(tabs[0]);
							break;

						// Up and down are in keydown
						// because we need to prevent page scroll >:)
						case keys.up:
						case keys.down:
							determineOrientation(event);
							break;
					};
				};

				// Handle keyup on tabs
				function keyupEventListener (event) {
					var key = event.keyCode;

					switch (key) {
						case keys.left:
						case keys.right:
							determineOrientation(event);
							break;
						case keys.delete:
							determineDeletable(event);
							break;
					};
				};

				// When a tablists aria-orientation is set to vertical,
				// only up and down arrow should function.
				// In all other cases only left and right arrow function.
				function determineOrientation (event) {
					var key = event.keyCode;
					var vertical = tablist.getAttribute('aria-orientation') == 'vertical';
					var proceed = false;

					if (vertical) {
						if (key === keys.up || key === keys.down) {
							event.preventDefault();
							proceed = true;
						};
					}
					else {
						if (key === keys.left || key === keys.right) {
							proceed = true;
						};
					};

					if (proceed) {
						switchTabOnArrowPress(event);
					};
				};

				// Either focus the next, previous, first, or last tab
				// depening on key pressed
				function switchTabOnArrowPress (event) {
					var pressed = event.keyCode;

					for (x = 0; x < tabs.length; x++) {
						tabs[x].addEventListener('focus', focusEventHandler);
					};

					if (direction[pressed]) {
						var target = event.target;
						if (target.index !== undefined) {
							if (tabs[target.index + direction[pressed]]) {
								tabs[target.index + direction[pressed]].focus();
							}
							else if (pressed === keys.left || pressed === keys.up) {
								focusLastTab();
							}
							else if (pressed === keys.right || pressed == keys.down) {
								focusFirstTab();
							};
						};
					};
				};

				// Activates any given tab panel
				function activateTab (tab, setFocus) {
					setFocus = setFocus || true;
					// Deactivate all other tabs
					// Get tablist

					deactivateTabs(tab);
					// Remove tabindex attribute
					tab.removeAttribute('tabindex');

					// Set the tab as selected
					tab.setAttribute('aria-selected', 'true');

					tab.parentElement.classList.add('active');
					// Get the value of aria-controls (which is an ID)
					var controls = tab.getAttribute('aria-controls');

					// Remove hidden attribute from tab panel to make it visible
					document.getElementById(controls).removeAttribute('hidden');

					var parent = tab.parentElement.closest('.tabs__navigation');
					var allTabs = parent.querySelectorAll('.tabs__nav-item');

					if (allTabs.length !== 0) {
						var newTabPanel = tab.getAttribute('aria-controls');
						for (i = 0; i < allTabs.length; ++i) {
							var currentTab = allTabs[i].classList.contains('active');
							if (currentTab == false) {
								var activeButton = allTabs[i].querySelector('button');
								var controller = activeButton.getAttribute('aria-controls');
								var oldsubTab = $('div[id="'+controller+'"]');
								var oldsubTabButton = oldsubTab.find('li.active').children();
								var subtabid = oldsubTabButton.attr('data-placeid');
								if (subtabid) {
									var newButton = $('div[id="'+controls+'"]').find('button[data-placeid="'+subtabid+'"]');
								newButton.trigger('click');
								$('div[id="'+controls+'"]').find('div[id="'+oldsubTabButton.attr('aria-controls')+'"]').removeAttr('hidden');
								}

								// $('div[id="'+controls+'"]').find('button[aria-controls="'+oldsubTabButton+'"]').trigger('change');
								var oldSelected = $('select[data-tab-panel="'+controller+'"]');
								var oldSelectedValue = oldSelected.find(':selected').attr('data-original-value');
								var newSelectedValue = '';
								var newSelected = $('select[data-tab-panel="'+newTabPanel+'"]');
								newSelected.children("option").each(function(i,option)
								{
									if(option.getAttribute('data-original-value') == oldSelectedValue){
										newSelectedValue = option.getAttribute('value');
									}

								});
								if (newSelectedValue) {
									newSelected.val(newSelectedValue).trigger('change');
									newSelected.select2ContentChange(newSelectedValue);

								}
							}
						}
					}
					// Set focus when required
					if (setFocus) {
						tab.focus();
					};

					$(window).trigger('update:tableScroll');
				};

				// Deactivate all tabs and tab panels
				function deactivateTabs(tab) {

					if(tab.closest('.tabs__panel')){
						var parent = tab.parentElement.closest('.tabs');
						var parentTabs = parent.querySelector('.tabs__navigation').querySelectorAll('[role="tab"]');
						var parentPanels = parent.querySelector('.tabs__panels').querySelectorAll('[role="tabpanel"]');

						for (t = 0; t < parentTabs.length; t++) {
							parentTabs[t].parentElement.classList.remove('active');
							parentTabs[t].setAttribute('tabindex', '-1');
							parentTabs[t].setAttribute('aria-selected', 'false');
							parentTabs[t].removeEventListener('focus', focusEventHandler);

						};

						for (p = 0; p < parentPanels.length; p++) {
							parentPanels[p].setAttribute('hidden', 'hidden');
						};
					}else {
						for (t = 0; t < tabs.length; t++) {
							tabs[t].parentElement.classList.remove('active');
							tabs[t].setAttribute('tabindex', '-1');
							tabs[t].setAttribute('aria-selected', 'false');
							tabs[t].removeEventListener('focus', focusEventHandler);
						};

						for (p = 0; p < panels.length; p++) {
							panels[p].setAttribute('hidden', 'hidden');
						};
					}
				};

				// Make a guess
				function focusFirstTab () {
					tabs[0].focus();
				};

				// Make a guess
				function focusLastTab () {
					tabs[tabs.length - 1].focus();
				};

				// Detect if a tab is deletable
				function determineDeletable (event) {
					target = event.target;

					if (target.getAttribute('data-deletable') !== null) {
						// Delete target tab
						deleteTab(event, target);

						// Update arrays related to tabs widget
						generateArrays();

						// Activate the closest tab to the one that was just deleted
						if (target.index - 1 < 0) {
							activateTab(tabs[0]);
						}
						else {
							activateTab(tabs[target.index - 1]);
						};
					};
				};

				// Deletes a tab and its panel
				function deleteTab (event) {
					var target = event.target;
					var panel = document.getElementById(target.getAttribute('aria-controls'));

					target.parentElement.removeChild(target);
					panel.parentElement.removeChild(panel);
				};

				// Determine whether there should be a delay
				// when user navigates with the arrow keys
				function determineDelay () {
					var hasDelay = tablist.hasAttribute('data-delay');
					var delay = 0;

					if (hasDelay) {
						var delayValue = tablist.getAttribute('data-delay');
						if (delayValue) {
							delay = delayValue;
						}
						else {
							// If no value is specified, default to 300ms
							delay = 300;
						};
					};

					return delay;
				};

				//
				function focusEventHandler (event) {
					var target = event.target;

					setTimeout(checkTabFocus, delay, target);
				};

				// Only activate tab on focus if it still has focus after the delay
				function checkTabFocus (target) {
					focused = document.activeElement;

					if (target === focused) {
						activateTab(target, false);
					};
				};
			});
		}
		
		$.fn.select2ContentChange = function(selectid){
			var accordion = $(this).attr('data-changeaccordion');
			accordion_id = selectid;
			if (accordion) {
			  var tab_id = $(accordion_id).attr('data-tab-panel');
			  if ($('div[id="'+tab_id+'"]').children('div[data-'+accordion+']').length !== 0) {
			  $('div[id="'+tab_id+'"]').children('div[data-'+accordion+']').each(function(i,el){
				var accordion_element = $(this);
				var acc_id = accordion_element.attr('data-'+accordion);
				if (acc_id==accordion_id) {
					accordion_element.css({"display":"block"});
				}
				else{
					accordion_element.css({"display":"none"});
				}
			  });
			  }
			  else{
			  $('div[data-'+accordion+']').each(function(i,el){
				  var accordion_element = $(this);
				  var acc_id = accordion_element.attr('data-'+accordion);
				  if (acc_id==accordion_id) {
					  accordion_element.css({"display":"block"});
				  }
				  else{
					  accordion_element.css({"display":"none"});
				  }
			  });
			  }
			}
		}
		
		$.fn.tableScroll = function() {
			$(this).each(function() {
				var main = $(this);
				var scroller = main.find('.table-scrollable');
				var table = main.find('table');
				var foodTable = main.find('.food-menu');
				var tableRows = foodTable.find('th').length;
				var caption = main.find('caption:last');
				var captionHeight = caption.height();
				var rightEdge, leftEdge;

				function checkDimensions() {
					if (rightEdge) {
						rightEdge.remove();
						rightEdge = false;
						leftEdge.remove();
						leftEdge = false;
					}

					if((table.width() + 1) > scroller.width()){
						main.append(rightEdge = $('<span class="edge-right"></span>')) && main.append(leftEdge = $('<span class="edge-left"></span>'));

						if(caption.length > 0) {
							leftEdge.css({'top': captionHeight, 'height' : 'auto'});
							rightEdge.css({'top': captionHeight, 'height' : 'auto'});
						}

						scroller.on('scroll', function(){
							var leftScroll = scroller.scrollLeft();
							var scrollingWidth = scroller[0].scrollWidth - scroller.width();

							if(leftScroll >= scrollingWidth ){
								rightEdge.hide();
								leftEdge.show();
							}else if (leftScroll <= 0) {
								rightEdge.show();
								leftEdge.hide();
							}else {
								leftEdge.show();
								rightEdge.show();
							}
						});
					}
				}

				$(window).on('resize:tableScroll update:tableScroll', function(){
					checkDimensions();
					checkTable();
				});

				checkTable();

				function checkTable(){
					(table.width() + 1) <= scroller.width() ? scroller.addClass('no-scroll') : scroller.removeClass('no-scroll');

					if(foodTable){
						tableRows > 5 ? foodTable.addClass('wide') : foodTable.removeClass('wide');
					}
				}
			});
		}

		$.fn.heroSwipers = function(){
			$(this).each(function(){
				var swiper = $(this);

				var backgroundSwiper = new Swiper('.hero-background-swiper' ,{
					slidesPerView: 1,
					loop: $('.background-slide').length > 1 ? true : false,
					autoplay: {
						delay: 10000,
					},
					pagination: {
						el: swiper.find('.swiper-pagination')[0],
						clickable: true,
						type: 'bullets',
					},
					init: false
				});

				backgroundSwiper.on('init', function(){
					pauseSwiper();
				});

				function pauseSwiper() {
					var swiperPause = swiper.find('.swiper-stop');

					if(backgroundSwiper.slides.length == 1) {
						$('.hero-background-swiper').find('.swiper-pagination').hide();
						swiperPause.hide();
					}

					swiperPause.on('click', function(e){
						if(swiperPause.hasClass('paused')){
							swiperPause.removeClass('paused');
							backgroundSwiper.autoplay.start();
							swiperPause.attr('aria-label', ariaLabels.pause)
						}else {
							swiperPause.addClass('paused');
							backgroundSwiper.autoplay.stop();
							swiperPause.attr('aria-label', ariaLabels.start)
						}
					});
				}

				backgroundSwiper.init();

				var heroTextBoxSwiper = $('.hero-textbox-swiper');
				var textBoxSwiper = new Swiper(heroTextBoxSwiper[0], {
					slidesPerView: 1,
					autoplay: {
						delay: 10000,
					},
					pagination: {
						el: heroTextBoxSwiper.parents().find('.hero-paginator')[0],
						clickable: true,
						type: 'bullets',
					},
					navigation: {
						nextEl: heroTextBoxSwiper.parents().find('.swiper-button-next')[0],
						prevEl: heroTextBoxSwiper.parents().find('.swiper-button-prev')[0],
					},
					breakpoints: {
						320: {
							loop: false,
							autoplay: false,
						},
						992: {
							autoplay: {
								delay: 10000,
							},
							loop: $('.textbox-slide').length > 1 ? true : false,
						}
					},
					init: false,
				});

				textBoxSwiper.on('init', function(){
					pauseTextSwiper();
					getTexts();
					mobilePagination()
				});

				textBoxSwiper.on('slideChange', function(){
					getTexts();
					mobilePagination()
				});

				function getTexts() {
					var textBox = swiper.find('.swiper-textbox__block');
					var title = textBox.find('.swiper-textbox__title');
					var link = textBox.find('.swiper-textbox__link');
					var activeSlide = swiper.find('.swiper-slide').eq(textBoxSwiper.activeIndex);

					textBox.attr({
						href: activeSlide.attr('data-link'),
						target: '_self'
					});
					title.text(activeSlide.attr('data-title'));
					link.text(activeSlide.attr('data-linktext'));

					if(activeSlide.hasClass('link-out')){
						link.addClass('swiper-textbox__link--link-out')
						link.text(activeSlide.attr('data-linktext'));
						textBox.attr('target', '_blank');
						link.append('<span class="sr-only">'+ activeSlide.attr('data-aria') +'</span><i class="mdi mdi-open-in-new" aria-hidden="true"></i>');
					}
				}

				function mobilePagination() {
					var heroChildrenLength = $('.hero__textbox').children().length;
					var paginatorEl = $('.hero__pagination');

					if($(window).width() < 992) {
						paginatorEl.css('order', heroChildrenLength);
					}
				}

				function pauseTextSwiper() {
					var swiperPause = swiper.parent().find('.swiper-stop');

					if( textBoxSwiper.slides.length == 1) {
						$('.hero__textbox').find('.swiper-pagination').hide();
						swiperPause.hide();
						$('.hero__textbox').find('.swiper-button-next').hide();
						$('.hero__textbox').find('.swiper-button-prev').hide();
					}

					swiperPause.on('click', function(){
						if(swiperPause.hasClass('paused')){
							swiperPause.removeClass('paused');
							textBoxSwiper.autoplay.start();
							swiperPause.attr('aria-label', ariaLabels.pause)
						}else {
							swiperPause.addClass('paused');
							textBoxSwiper.autoplay.stop();
							swiperPause.attr('aria-label', ariaLabels.start)
						}
					});
				}

				textBoxSwiper.init();

				var heroBoxesSwiper = $('.hero-boxes-swiper');
				var quickLinksSwiper = new Swiper(heroBoxesSwiper[0], {
					pagination: false,
					navigation: {
						nextEl: heroBoxesSwiper.parent().find('.swiper-button-next')[0],
						prevEl: heroBoxesSwiper.parent().find('.swiper-button-prev')[0],
					},
					keyboard: {
						enabled: true,
					},
					a11y: {
						prevSlideMessage: 'Previous slide',
						nextSlideMessage: 'Next slide',
					},
					breakpoints: {
						320: {
							slidesPerView: 2,
							spaceBetween: 8,
						},
						400: {
							slidesPerView: 3,
							spaceBetween: 8,
						},
						575: {
							slidesPerView: 4,
							spaceBetween: 8,
						},
						765: {
							slidesPerView: 5,
							spaceBetween: 8,
						},
						830: {
							slidesPerView: 6,
							spaceBetween: 8,
						},
						992: {
							slidesPerView: 3,
							spaceBetween: 16,
						},
						1187: {
							slidesPerView: 4,
							spaceBetween: 16,
						},
						1375: {
							slidesPerView: 5,
							spaceBetween: 16,
						}
					},
					init: false
				});

				quickLinksSwiper.on('init', function(){
					hideNavigation();
					setSlides();
					centeredSlides();
					tabFocus();
				});

				quickLinksSwiper.on('beforeInit', function() {
					fontSizeSwiper();
				})


				function hideNavigation() {
					if(quickLinksSwiper.slides.length <= quickLinksSwiper.params.slidesPerView){
						heroBoxesSwiper.parent().find('.swiper-button-next').hide();
						heroBoxesSwiper.parent().find('.swiper-button-prev').hide();
					}
				}

				function setSlides() {
					if($(window).width() < 992 && quickLinksSwiper.slides.length < quickLinksSwiper.params.slidesPerView){
						heroBoxesSwiper.find('.swiper-wrapper').css('justify-content', 'center');
					}else if ($(window).width() < 400 && quickLinksSwiper.slides.length < quickLinksSwiper.params.slidesPerView){
						heroBoxesSwiper.find('.swiper-wrapper').css('justify-content', 'normal');
					}
				}

				function centeredSlides() {
					if(quickLinksSwiper.slides.length < 5){
						heroBoxesSwiper.find('.swiper-wrapper').css('justify-content', 'center');
					}
				}

				function fontSizeSwiper() {
					if($('html').hasClass('fontSize-mobile-4x') || $('html').hasClass('fontSize-mobile-2x')){
						quickLinksSwiper.params.breakpoints[320].slidesPerView = 1;
						quickLinksSwiper.params.breakpoints[400].slidesPerView = 2;
						quickLinksSwiper.params.breakpoints[575].slidesPerView = 2;
						quickLinksSwiper.params.breakpoints[765].slidesPerView = 3;
						quickLinksSwiper.params.breakpoints[830].slidesPerView = 3;
						quickLinksSwiper.update();
					}
				}

				function tabFocus() {
					quickLinksSwiper.$el.on('keydown', function(e) {
						var slideIndex = e.target.dataset.slideIndex;
						console.log(e.target)
					});
				}

				quickLinksSwiper.init()
			});
		}

		$.fn.frontSwipers = function(){
			$(this).each(function(){
				var swiper = $(this);
				var swiperEdgeLeft, swiperEdgeRight;

				if(swiper.parent().is('.quarter')){
					var quarterSwiper = new Swiper(swiper[0], {
						slidesPerView: 3,
						spaceBetween: 24,
						watchSlidesProgress: true,
						loop: false,
						pagination: {
							el: '.quarter-home-paginator',
							clickable: true,
							type: 'bullets',
						},
						breakpoints: {
							320: {
								slidesPerView: 1.1,
								spaceBetween: 16,
							},
							575: {
								slidesPerView: 2.2,
								spaceBetween: 16,
							},
							800: {
								slidesPerView: 3,
								spaceBetween: 16,
								noSwiping: false,
							},
							992: {
								slidesPerView: 3,
								pagination: false,
								enabled: false,
							},
						},
						init: false,
					});

					quarterSwiper.on('init', function(){
						checkWidth(quarterSwiper);
						checkLast(quarterSwiper);
						disableBullets(quarterSwiper);
					});

					quarterSwiper.on('slideChange', function(){
						checkLast(quarterSwiper);
					});

					swiperDisable(quarterSwiper);

					quarterSwiper.init();
				}else if (swiper.parent().is('.small') || swiper.parent().is('.wide') || swiper.parent().is('.half')){
					var homepageSwiper = new Swiper(swiper[0] ,{
						slidesPerView: 4,
						spaceBetween: 24,
						loop: false,
						setWrapperSize: true,
						watchSlidesProgress: true,
						pagination: {
							el: '.home-paginator',
							clickable: true,
							type: 'bullets',
						},
						breakpoints: {
							320: {
								slidesPerView: 1.1,
								spaceBetween: 16,
							},
							575: {
								slidesPerView: 2.2,
								spaceBetween: 16,
							},
							800: {
								slidesPerView: 4,
								spaceBetween: 16,
								noSwiping: false,
							},
							992: {
								slidesPerView: 4,
								pagination: false,
								enabled: false,
							},
						},
						init: false,
					});

					homepageSwiper.on('init', function(e){
						checkWidth(homepageSwiper);
						checkSmall(homepageSwiper);
						checkLast(homepageSwiper);
						disableBulletsHome(homepageSwiper);
						checkAccessibility(homepageSwiper);
					});

					homepageSwiper.on('slideChange', function(){
						checkLast(homepageSwiper);
					});
					
					swiperDisable(homepageSwiper);
					homepageSwiper.init();
				}

				function checkWidth(obj){
					var wrapper = swiper.parent();

					if($(window).width() <= 799 && obj.slides.length > 1){
						wrapper.append(swiperEdgeRight = $('<span class="swiper-edge"></span>'));
						wrapper.prepend(swiperEdgeLeft = $('<span class="swiper-edge-left"></span>'));
					}
				}

				function checkLast(obj) {
					if(obj.isEnd) {
						swiperEdgeRight.hide();
						swiperEdgeLeft.show();
					}else {
						swiperEdgeRight.show();
						swiperEdgeLeft.hide();
					}
				}

				function checkSmall(obj) {
					if(obj.$el.parent().hasClass('small')){
						obj.destroy();
						swiper.parent().css('margin','0');
					}
				}

				function swiperDisable(obj) {
					if($(window).width() > 992){
						obj.destroy();
					}
				}

				function checkAccessibility(obj){
					if(('html').hasClass('fontSize-mobile-4x')){
						obj.params.breakpoints[320].spaceBetween = 8;
						obj.params.breakpoints[575].spaceBetween = 8;
						obj.update();
					}else if (('html').hasClass('fontSize-mobile-2x')){
						obj.params.breakpoints[320].spaceBetween = 10;
						obj.params.breakpoints[575].spaceBetween = 10;
						obj.update();
					}else {
						return false;
					}
				}

				function disableBulletsHome(swiper) {
					swiper.pagination.bullets.attr({
						'tabindex': -1,
						'aria-hidden': true
					});
				}
			});
		}

		$.fn.logoSwipers = function(){
			$(this).each(function(){
				var swiper = $(this);

				if(swiper.parent().is('.logos--wide')){
					var btnNextw = swiper.parent().find('.logos-wide-next')[0];
					var btnPrevw = swiper.parent().find('.logos-wide-prev')[0];
					var paginatorw = swiper.parent().find('.wide-logos-paginator')[0];

					var wideLogosSwiper = new Swiper (swiper[0],{
						slidesPerView: 5,
						spaceBetween: 32,
						loop: false,
						pagination: {
							el: paginatorw,
							clickable: true,
							type: 'bullets',
						},
						navigation: {
							nextEl: btnNextw,
							prevEl: btnPrevw,
						},
						breakpoints: {
							320: {
								slidesPerView: 2,
								slidesPerGroup: 2,
							},
							575: {
								slidesPerView: 4,
								slidesPerGroup: 4,
							},
							830: {
								slidesPerView: 5,
							},
							992: {
								slidesPerView: 5,
							},
							1375: {
								slidesPerView: 5,
								slidesPerGroup: 5,
							}
						},
						init: false,
					});

					wideLogosSwiper.on('init', function(){
						hideNavigation(wideLogosSwiper, wideLogosSwiper.params.slidesPerView);
						buttonTop();
						disableBullets(wideLogosSwiper);
					});

					wideLogosSwiper.init();

				}else if (swiper.parent().is('.logos--quarter')){
					var btnNextqw = swiper.parent().find('.logos-quarter-next')[0];
					var btnPrevqw = swiper.parent().find('.logos-quarter-prev')[0];
					var paginatorqw = swiper.parent().find('.quarter-logos-paginator')[0];

					var quarterLogosSwiper = new Swiper (swiper[0],{
						slidesPerView: 5,
						spaceBetween: 32,
						loop: false,
						pagination: {
							el: paginatorqw,
							clickable: true,
							type: 'bullets',
						},
						navigation: {
							nextEl: btnNextqw,
							prevEl: btnPrevqw,
						},
						breakpoints: {
							320: {
								slidesPerView: 2,
								slidesPerGroup: 2
							},
							575: {
								slidesPerView: 4,
								slidesPerGroup: 4
							},
							800: {
								slidesPerView: 5,
								slidesPerGroup: 5
							},
							992: {
								slidesPerView: 3,
								slidesPerGroup: 3
							},
							1375: {
								slidesPerView: 5,
								slidesPerGroup: 5
							}
						},
						init: false,
					});

					quarterLogosSwiper.on('init', function(){
						buttonTop();
						hideNavigation(quarterLogosSwiper, quarterLogosSwiper.params.slidesPerView);
						cancelSwiper(quarterLogosSwiper);
						disableBullets(quarterLogosSwiper);
					});

					quarterLogosSwiper.init();

				}else if (swiper.parent().is('.logos--half')){
					var btnNexth = swiper.parent().find('.logos-half-next')[0];
					var btnPrevh = swiper.parent().find('.logos-half-prev')[0];
					var paginatorh = swiper.parent().find('.half-logos-paginator')[0];

					var halfLogosSwiper = new Swiper (swiper[0],{
						slidesPerView: 3,
						spaceBetween: 32,
						loop: false,
						pagination: {
							el: paginatorh,
							clickable: true,
							type: 'bullets',
						},
						navigation: {
							nextEl: btnNexth,
							prevEl: btnPrevh,
						},
						breakpoints: {
							320: {
								slidesPerView: 2,
								slidesPerGroup: 2
							},
							575: {
								slidesPerView: 4,
								slidesPerGroup: 4
							},
							800: {
								slidesPerView: 5,
								slidesPerGroup: 5
							},
							992: {
								slidesPerView: 2,
								slidesPerGroup: 2
							},
							1375: {
								slidesPerView: 3,
								slidesPerGroup: 3
							}
						},
						init: false,
					});

					halfLogosSwiper.on('init', function(){
						buttonTop();
						hideNavigation(halfLogosSwiper, halfLogosSwiper.params.slidesPerView);
						cancelSwiper(halfLogosSwiper);
						disableBullets(halfLogosSwiper);
					});

					halfLogosSwiper.init();
				}else if (swiper.parent().is('.logos--small')){
					var btnNexts = swiper.parent().find('.logos-small-next')[0];
					var btnPrevs = swiper.parent().find('.logos-small-prev')[0];
					var paginators = swiper.parent().find('.small-logos-paginator')[0];

					var smallLogoSwiper = new Swiper(swiper[0], {
						slidesPerView: 1,
						spaceBetween: 32,
						loop: false,
						pagination: {
							el: paginators,
							clickable: true,
							type: 'bullets',
						},
						navigation: {
							nextEl: btnNexts,
							prevEl: btnPrevs,
						},
						breakpoints: {
							320: {
								slidesPerView: 2,
								slidesPerGroup: 2
							},
							575: {
								slidesPerView: 4,
								slidesPerGroup: 4
							},
							830: {
								slidesPerView: 5,
								slidesPerGroup: 5
							},
							992: {
								slidesPerView: 1,
								slidesPerGroup: 1
							},
						},
						init: false,
					});

					smallLogoSwiper.on('init', function(){
						buttonTop();
						hideNavigation(smallLogoSwiper, smallLogoSwiper.params.slidesPerView);
						cancelSwiper(smallLogoSwiper);
						disableBullets(smallLogoSwiper);
					});

					smallLogoSwiper.init();
				}

				function buttonTop() {
					var containerHeight = swiper.height();
					var buttonNext = swiper.parent().find('.swiper-button-next');
					var buttonPrev = swiper.parent().find('.swiper-button-prev');

					buttonNext.css('top', containerHeight / 4);
					buttonPrev.css('top', containerHeight / 4);
				}

				function hideNavigation(obj, limit){
					if(obj.slides.length <= limit){
						swiper.parent().find('.swiper-button-next').hide();
						swiper.parent().find('.swiper-button-prev').hide();
					}
				}

				function cancelSwiper(obj) {
					if(swiper.parent().height() > 150 && $(window).width() > 992){
						obj.destroy();
						swiper.parent().addClass('high-logos-row');
						swiper.parent().find('.swiper-button-next').hide();
						swiper.parent().find('.swiper-button-prev').hide();
						swiper.parent().find('.swiper-pagination').hide();
					}
				}

				function disableBullets(swiper) {
					swiper.pagination.bullets.attr({
						'tabindex': -1,
						'aria-hidden': true
					});
				}
			});
		}

		$.fn.backToTop = function(){
			$(this).each(function(){
				var main = $(this);

				if($(window).width()< 576){
					$(window).on('scroll', function(){
						if($(window).scrollTop() > 0){
							main.css('display','block');

						}else {
							main.css('display','none');
						}
					});
				}else {
					return false;
				}

				main.on('click',function(e){
					e.preventDefault();

					$("html, body").animate({scrollTop: 0}, 800);
				});
			});
		}

		/** Header logo text size **/

		var html = $('html');
		var headerSchoolNameWrapper = $('.header-logo-text');
		var logoSchoolName = headerSchoolNameWrapper.find('span');
		var headerTextBlock = $('.header-school-name');
		var schoolName = headerTextBlock.find('.school-name');

		if(html.hasClass('fontSize-4x') || html.hasClass('fontSize-2x')){
			return false;
		}else {
			$(window).on('resize', function(){
				headerTextBlock.removeClass('text-small');
				headerSchoolNameWrapper.removeClass('shrink-text');

				if(schoolName.length > 0) {
					if(schoolName.height() > 37){
						headerTextBlock.addClass('text-small');
					}
				}

				if(headerSchoolNameWrapper.length > 0) {
					if(logoSchoolName.height() > 52){
						headerSchoolNameWrapper.addClass('shrink-text');
					}
				}
			}).trigger('resize');
		}

		/** Read/write cookies for accessibility menu **/

		function createCookie(name,value,days) {
			if (days) {
				var date = new Date();
				date.setTime(date.getTime()+(days*24*60*60*1000));
				var expires = "; expires="+date.toGMTString();
			}
			else var expires = "";
			document.cookie = name+"="+value+expires+"; path=/";
		};

		function readCookie(name) {
			var nameEQ = name + "=";
			var ca = document.cookie.split(';');
			for(var i=0;i < ca.length;i++) {
				var c = ca[i];
				while (c.charAt(0)==' ') c = c.substring(1,c.length);
				if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
			}
			return null;
		};

		function eraseCookie(name) {
			createCookie(name,"",-1);
		};

		/** Mobile main menu top position **/

		$(window).on('resize', function(){
			if($('html').hasClass('fontSize-mobile-2x') || $('html').hasClass('fontSize-mobile-4x')){
				var headerWrapper = $('.header-wrapper');
				var headerWrapperHeight = headerWrapper.height();
				var mobileMenu = $('.mobile-menu');
				var mobileSearch = $('.mobile-search-overlay');
				mobileMenu.css('top', headerWrapperHeight);
				mobileSearch.css('height', headerWrapperHeight);
			}
		}).trigger('resize');

		/** Calendar date change event **/

		$('#minicalendar').on('change', function(){
			$('#edit-date-start').val($(this).val());
			$('#edit-date-end').val($(this).val()).trigger('change');
		});
	});

}(window.jQuery);
/* window.jQuery to end !function */

/* !function to prevent library conflicts */ 
!function ($) {

  function parseQuery(queryString) {
    var query = {};
    var pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');
    for (var i = 0; i < pairs.length; i++) {
      var pair = pairs[i].split('=');
      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
    }
    return query;
  }

  $(function(){

    $.fn.gallery = function () {
      $(this).each(function(){
        var main = $(this);
        var gallery = main.find('#gallery');
        var paginator = main.find('.paginator:first');
        var thumbsContainer = main.find('.gallery-thumbs:first');
        var thumbnails = thumbsContainer.find('li');
        var thumbsPerView = 15;
        var pages = Math.ceil(thumbnails.length / thumbsPerView);
        var currentPage = 0;
        var visiblePageNumbers = 3;
        var thumbCount = thumbnails.length;
        var mobilePictureCounter = main.parent().find('.images-count');
        var bigPicture = gallery.find('a');
        var titleContainer = gallery.find('.image-title');
        var pageCounter = gallery.find('.image-page');
        var nextButton = gallery.find('.button-next');
        var prevButton = gallery.find('.button-prev');
        var mobileBottomCounter = $('.gallery-mobile-bottom').find('.image-page');
        var mobileTitle = mobileBottomCounter.data('title');
  
        mobilePictureCounter.html(thumbCount);
        mobileBottomCounter.html(thumbCount + ' ' + mobileTitle);
  
        function bindThumbnails() {
          var anchors = thumbnails.find('a');
          
          anchors.on('click', function (e) {
            e.preventDefault();
            var obj = $(this);
            var fullImage  = obj.attr('data-bigPicture');
            var parent = obj.parent();
            var activeIndex = thumbnails.index(parent);
            var indexCounter = activeIndex + 1;
            var thumbId = obj.attr('id');
  
            thumbnails.filter('.active').removeClass('active');
            thumbnails.eq(activeIndex).addClass('active');
  
            var dataImage = obj.attr('style');
            var title = obj.attr('title');
            bigPicture.attr('style', dataImage);
            bigPicture.find('img').attr('alt', obj.find('img').attr('alt'));
            bigPicture.attr('id', thumbId);
            if(fullImage){
              bigPicture.css({"background-image":"url('"+fullImage+"')"});
              bigPicture.attr('style').replaceAll('"','\'');
            }
            titleContainer.html(title);
            pageCounter.html((activeIndex + 1) + '/' + thumbCount);
  
            indexCounter === 1 ? prevButton.addClass('disabled') && prevButton.attr('aria-disabled', 'true') : prevButton.removeClass('disabled') && prevButton.attr('aria-disabled', 'false');
            indexCounter === thumbCount ? nextButton.addClass('disabled') && nextButton.attr('aria-disabled', 'true') : nextButton.removeClass('disabled') && nextButton.attr('aria-disabled', 'false');
          });
        }
  
        function fillEmptySlots() {
          if ($(window).width()< 1376) {
            thumbsPerView = 8;
            pages = Math.ceil(thumbnails.length / thumbsPerView);
          }
  
          if($(window).width() <= 991) {
            thumbsPerView = 5;
            pages = Math.ceil(thumbnails.length / thumbsPerView);
          }
  
          var emptySlots = (pages * thumbsPerView) - thumbCount;
  
          var emptySlotsHTML = '';
          for (var i = 0; i < emptySlots; i++) {
            emptySlotsHTML += '<li class="empty" tabindex="-1" aria-hidden="true"><span class="empty-picture">' + thumbnails.eq(0).find("a").html() + '</span></li>';
          }

          thumbsContainer.append(emptySlotsHTML);
          thumbnails = thumbsContainer.find("li");
        }
  
        function generatePaginator() {
          var paginatorHTML = '';
  
          if (pages == 1) {
            return false;
          }
  
          thumbnails.hide().slice(currentPage * thumbsPerView, (currentPage + 1) * thumbsPerView).show();
  
          if (currentPage == 0) {
            paginatorHTML += '<li><a href="#prev" class="back disabled" title="previous" rel="prev" aria-disabled="true></a></li>';
          }
  
          paginatorHTML += '<li><a href="#prev" class="back" title="previous" rel="prev"><span class="sr-only">previous</span></a></li>';
  
          var paginatorStart = currentPage;
  
          if (currentPage > 0) {
            paginatorStart--;
          }
  
          if (paginatorStart + (visiblePageNumbers + 1) > pages) {
            paginatorStart = pages - (visiblePageNumbers + 1);
          }
  
          var paginatorEnd = paginatorStart + visiblePageNumbers;
          if (paginatorEnd > pages) {
            paginatorEnd = pages;
          }
  
          for (var i = paginatorStart; i < paginatorEnd; i++) {
            if (i < 0) {
              continue;
            }
            if (i == currentPage) {
              paginatorHTML += '<li class="active"><a href="#page-' + i + '" aria-current="page">' + (i + 1) + '</a></li>';
            } else {
              paginatorHTML += '<li><a href="#page-' + i + '">' + (i + 1) + '</a></li>';
            }
          }
  
          if (paginatorStart + visiblePageNumbers < pages - 1) {
            paginatorHTML += '<li><a href="#step" title="nita jrgmiseid"><span class="sr-only">more pages</span>...</a></li>';
          }
  
          if (currentPage + 1 == pages) {
            paginatorHTML += '<li class="active"><a href="#page-' + (pages - 1) + '">' + (pages) + '</a></li>';
            paginatorHTML += '<li><a href="#next" class="next disabled" title="next" rel="next"><span class="sr-only">next</span></a></li>';
          } else {
            paginatorHTML += '<li><a href="#page-' + (pages - 1) + '">' + (pages) + '</a></li>';
            paginatorHTML += '<li><a href="#next" class="next" title="next" rel="next"><span class="sr-only">next</span></a></li>';
          }
          paginator.html(paginatorHTML);
  
          bindPaginator();
        };
  
        function bindPaginator() {
          paginator.find("a[href*='#page-']").on("click", function (e) {
            e.preventDefault();
            var nr = $(this).attr("href").split("#page-")[1];
            nr = parseInt(nr);
            currentPage = nr;
            generatePaginator();
          });
  
          paginator.find("a[href='#prev']").on("click", function(e) {
            e.preventDefault();
            currentPage--;
            if (currentPage < 0) {
              currentPage = 0;
              return false;
            }
            generatePaginator();
          });
  
          paginator.find("a[href='#next']").on("click", function(e) {
            e.preventDefault();
            currentPage++;
            if (currentPage > pages - 1) {
              currentPage = pages - 1;
              return false;
            }
            generatePaginator();
          });
        };
  
        function activeSlide(item, index) {
          var newitem = item.clone();
          var fullImage = newitem.attr('data-bigPicture');
          if (fullImage) {
            newitem.css({"background-image":"url('"+fullImage+"')"});
            newitem.attr('style').replaceAll('"','\'');
          }
          index.addClass('active');
          gallery.find('.gallery-image:first').attr('style',newitem.attr('style'));
          bigPicture.find('img').attr('alt', index.find('img').attr('alt'));
          bigPicture.attr('id', index.find('a').attr('id'));
          titleContainer.html(item.attr('title'));
          pageCounter.html((index.index() + 1) + '/' + thumbCount);
  
          index.index() === 0 ? prevButton.addClass('disabled') && prevButton.attr('aria-disabled', 'true') : prevButton.removeClass('disabled') && prevButton.attr('aria-disabled', 'false');
          index.index() + 1 === thumbCount ? nextButton.addClass('disabled') && nextButton.attr('aria-disabled', 'true') : nextButton.removeClass('disabled') && nextButton.attr('aria-disabled', 'false');
  
          if(thumbCount === 1){
            nextButton.hide();
            prevButton.hide();
          }
        }
  
        function loadGalleryImage() {
          var index = thumbsContainer.find('li').eq(0);
          var anchor = index.find('a');
          var contHeight = $('.gallery-image img').height();
          var nextBtnHeight = nextButton.height();
          var heightT = (contHeight / 2) - (nextBtnHeight / 2);
  
          activeSlide(anchor, index);

          nextButton.css('top', heightT);
          prevButton.css('top', heightT);
  
          nextButton.on('click', function (e) {
            e.preventDefault();
            var activeIndexNext = thumbnails.filter('.active');
            var indexUp = activeIndexNext.index() + 1;
            var activeId = activeIndexNext.find('a').attr('id');
            var activeThumbPage = Math.floor(indexUp / thumbsPerView);
            bigPicture.attr('id', activeId);
  
            if (activeThumbPage !== currentPage) {
              currentPage = activeThumbPage;
              generatePaginator();
            }
  
            thumbnails.each(function () {
              var obj = $(this);
              var link = obj.find('a');
  
              obj.index() == indexUp ? activeSlide(link, obj) : obj.removeClass('active');
            });
          });
  
          prevButton.on('click', function (e) {
            e.preventDefault();
            var activeIndexPrev = thumbnails.filter('.active');
            var indexDown = activeIndexPrev.index() - 1;
            var activeThumbPage = Math.floor(indexDown / thumbsPerView);
  
            if (activeThumbPage !== currentPage) {
              currentPage = activeThumbPage;
              generatePaginator();
            }
  
            thumbnails.each(function () {
              var obj = $(this);
              var link = obj.find('a');
  
              obj.index() == indexDown ? activeSlide(link, obj) : obj.removeClass('active');
            });
          });
        }
  
        bindThumbnails();
        fillEmptySlots();
        generatePaginator();
        loadGalleryImage();
      });
      
    }

    $.fn.modalOpener = function(){
			$(this).each(function(){
				var main = $(this);
        var galleryType = main.attr('data-modal');
				var pictureModal = $('.picture-modal');
        var anchor, galleryTop, galleryThumbnails, thumbnails, galleryModal, galleryWrapper, galleryToolbar, toolbarWrapper, imageCount, shareButton, printButton, downloadButton, closeButton, swiperThumbHTML, swiperMainHTML, swiperButtonPrev ,swiperButtonNext, imageDescription, focusTrapFirst, focusTrapLast, slideLast;
        var thumbs = $('.gallery-thumbs:first');
        thumbnails = thumbs.find('a');

        var galleryModalType = main.attr('data-modal');

        if(galleryModalType == 'single'){
          anchor = main.parent().find('a');
        }else if (galleryModalType == 'gallery') {
          if($(window).width() > 992){
            anchor = main;
          }else{
            anchor = $('.row-gallery').find('a');
          }
        }

				anchor.on('click', function(e){
          e.preventDefault();
          var activeThumb = thumbs.find('li.active');
          var anchorId = anchor.filter('#' + $(this).attr('id'));
          var thumbIndex = anchor.index(anchorId);

          if(anchor.length > 0) {
            openGallery();
            if(activeThumb.length){
              swiperPictureModal(activeThumb.index());
            }else {
              swiperPictureModal(thumbIndex);
            }
          }else {
            openGallery();
            swiperPictureModal(0);
          }
				});

        var query = parseQuery(window.location.search.replace('?', ''));
        if (query.gallery) {
          if($(window).width() > 992){
            if(anchor.parents().hasClass('image-block')){
              setTimeout(function(){
                smallGallery('#'+query.gallery);
              },500)
            }else {
              setTimeout(function(){
                bigGallery('#'+query.gallery);
              }, 500);
            }
          }else {
            anchor.filter('#'+query.gallery).trigger('click');
          }
        }

        function closeModalGallery() {
          $(document).off('keyup.modal');
          $('body').removeClass('modal-open');
          if(galleryModalType == 'single'){
            thumbnails = false;
          }
          else if(galleryModalType == 'gallery' && $(window).width() < 992) {
            thumbnails = false;
          }
          else {
            thumbnails.eq(galleryTop.activeIndex).trigger('click');
          }
          galleryModal.remove();
          main.focus();
        }

        function download(uri, name) {
          var link = document.createElement("a");
  
          link.setAttribute('download', name);
          link.href = uri;
          document.body.appendChild(link);
          link.click();
          link.remove();
        }

        function openGallery(){
          $('body').addClass('modal-open');
          $('body').append(galleryModal = $('<div class="picture-modal" id="gallery" role="modal" aria-modal="true"><div class="focus-trap-first" tabindex="0"></div><div class="picture-modal__container"></div><div class="focus-trap-last" tabindex="0"></div></div>'))
          galleryWrapper = galleryModal.find('.picture-modal__container');
          focusTrapFirst = galleryModal.find('.focus-trap-first');
          focusTrapLast = galleryModal.find('.focus-trap-last');

					pictureModal.addClass('open');

          galleryWrapper.append(galleryToolbar = $('<div class="modal-toolbar"><div class="item-wrapper"></div></div>'))
          toolbarWrapper = galleryToolbar.find('.item-wrapper');

          toolbarWrapper.append(imageCount =  $('<div class="modal-image-count"></div>'));
          toolbarWrapper.append(shareButton = $('<button class="btn btn-share" aria-label="'+ariaLabels.share+'" data-url=""><i class="mdi mdi-share-variant" aria-hidden="true"></i></button>'));
          toolbarWrapper.append(printButton =  $('<button class="btn btn-print" aria-label="'+ariaLabels.print+'"><i class="mdi mdi-printer" aria-hidden="true"></i></button>'));
          toolbarWrapper.append(downloadButton = $('<button class="btn btn-download" download="test picture" target="_blank" aria-label="'+ariaLabels.download+'"><i class="mdi mdi-download" aria-hidden="true"></i></button>'));
          toolbarWrapper.append(closeButton = $('<button class="btn btn-close" aria-label="'+ariaLabels.close+'"><i class="mdi mdi-close" aria-hidden="true"></i></button>'));

          shareButton.focus();

          printButton.on('click', function(){
            setTimeout(window.print(), 1000);
          });
  
          downloadButton.on('click', function(){
            var activeSlide = galleryTop.slides[galleryTop.activeIndex];
            var src = activeSlide.firstChild.getAttribute('data-image');
            var fileName = src.split('/')[src.split('/').length-1];
            download(src, fileName);
          });
  
          closeButton.off('click').on('click', function(){
            closeModalGallery();
          });

          shareButton.shareModal();
  
          $(document).on('keyup.modal', function(e){
            if(e.keyCode == 27 || e.which == 27) {
              closeModalGallery();
            }
          });
        }

				function imagesToModal(thums) {
          galleryWrapper.append(swiperMainHTML = $('<div class="swiper-container gallery-top"><div class="swiper-wrapper"></div></div>'));
					galleryWrapper.append(swiperThumbHTML = $('<div class="swiper-container gallery-thumbnails"><div class="swiper-wrapper"></div></div>'));
          swiperThumbHTML.prepend(imageDescription = $('<div class="image-description"><span class="title"></span></div>'));
          var imageSliderTitle = imageDescription.find('.title');
					var swiperMainWrapper = swiperMainHTML.find('.swiper-wrapper:first');
					var swiperThumbWrapper = swiperThumbHTML.find('.swiper-wrapper:first');
          slideLast = galleryWrapper.find('.swiper-slide:last > a');

          if(galleryType == 'single'){
            var modalThumbs = main.parent('.image-block').find('a');
          }else {
            var thumbnails = $('.gallery-thumbs');
            var modalThumbs = thumbnails.find('a');
          }

          var swiperThumbSlide = '';
          var swiperMainSlide = '';

          if (modalThumbs.length == 1){
            var id = main.attr('id') ? 'id="'+main.attr('id')+'"' : '';
            var obj = main.clone();

            var fullImage  = obj.attr('data-bigPicture');
            if (fullImage) {
              obj.css({"background-image": "url('"+fullImage+"')"});
              var newstyle = obj.attr('style').replaceAll('"','\'');
            }
            else{
              var newstyle = obj.attr('style');
            }
            swiperMainSlide += '<div class="swiper-slide single">'+
            '<a href="'+main.attr('data-image')+'" '+id+' class="gallery-image-item" data-hash="'+main.attr('data-image')+'" style="'+ newstyle + '" data-image="' + main.attr('data-image') + '" title="'+ main.attr('title') +'" tabindex="0">'+
            '<img src="../../assets/images/placeholder-1.gif" alt="'+main.children().attr('alt')+'">'+
            '</a>'+
            '</div>';

            swiperMainWrapper.append(swiperMainSlide);
            imageSliderTitle.html(main.attr('title'));
            swiperThumbWrapper.hide();

            var lastItem = swiperMainWrapper.find('.gallery-image-item');
            focusTrap(lastItem);
          }else {
            modalThumbs.each(function(){
              var obj = $(this).clone();
              var id = obj.attr('id') ? 'id="'+obj.attr('id')+'"' : '';
              var fullImage  = obj.attr('data-bigPicture');
              if (fullImage) {
                obj.css({"background-image": "url('"+fullImage+"')"});
                var newstyle = obj.attr('style').replaceAll('"','\'');
              }
              else{
                var newstyle = obj.attr('style');
              }
            
              swiperThumbSlide += '<div class="swiper-slide">'+
              '<a href="'+obj.attr('data-image')+'" '+id+' class="gallery-image-item" data-hash="'+obj.attr('data-image')+'" style="'+ newstyle + '" data-image="' + obj.attr('data-image') + '" title="'+ obj.attr('title') +'" tabindex="0">'+
              '<img src="../../assets/images/placeholder-1.gif" alt="'+obj.children().attr('alt')+'">'+
              '</a>'+
              '</div>';
            });
            swiperThumbWrapper.append(swiperThumbSlide);
            modalThumbs.each(function(){
              var obj = $(this).clone();
              var fullImage  = obj.attr('data-bigPicture');
              if (fullImage) {
                obj.css({"background-image": "url('"+fullImage+"')"});
                var newstyle = obj.attr('style').replaceAll('"','\'');
              }
              else{
                var newstyle = obj.attr('style');
              }
              var id = obj.attr('id') ? 'id="'+obj.attr('id')+'"' : '';
              swiperMainSlide += '<div class="swiper-slide">'+
              '<a href="'+obj.attr('data-image')+'" '+id+' class="gallery-image-item" data-hash="'+obj.attr('data-image')+'" style="'+ newstyle + '" data-image="' + obj.attr('data-image') + '" title="'+ obj.attr('title') +'" tabindex="0">'+
              '<img src="../../assets/images/placeholder-1.gif" alt="'+obj.children().attr('alt')+'">'+
              '</a>'+
              '</div>';
            });
            swiperMainWrapper.append(swiperMainSlide);
            swiperMainHTML.append(swiperButtonNext = $('<div class="swiper-button-next"></div>'));
            swiperMainHTML.append(swiperButtonPrev = $('<div class="swiper-button-prev"></div>'));

            var lastThumb = swiperThumbWrapper.find('.swiper-slide:last > a');

            focusTrap(lastThumb)
          }

          function focusTrap(lastItem) {
            $(document).on('keyup.modal', function(e){
              focusTrapFirst.on('keyup', function(){
                if(e.keyCode == 9 || e.which == 9) {
                  e.preventDefault();
                  lastItem.focus();
                }
              });
  
              focusTrapLast.on('keyup', function(){
                if(e.keyCode == 9 || e.which == 9 && e.keyCode == 16 || e.which == 16) {
                  e.preventDefault();
                  shareButton.focus();
                }
              });
            });
          }
				}
	
				function swiperPictureModal(indx) {
          imagesToModal();
          var pictureCountContainer = $('.modal-toolbar').find('.modal-image-count');
          var shareBtn = $('.modal-toolbar').find('.btn-share');

          galleryThumbnails = new Swiper('.gallery-thumbnails', {
            spaceBetween: 16,
            freeMode: true,
            slidesPerView: 3,
            watchSlidesVisibility: true,
            watchSlidesProgress: true,
            initialSlide: indx,
            breakpoints: {
              320: {
                slidesPerView: 3,
              },
              575: {
                slidesPerView: 5,
              },
              991: {
                slidesPerView: 7,
              },
              1200: {
                slidesPerView: 10,
              },
              2160: {
                slidesPerView: 15,
              }
            }
          });
          
          galleryTop = new Swiper('.gallery-top', {
            spaceBetween: 10,
            hashNavigation:true,
            watchSlidesProgress: true,
            initialSlide: indx,
            init: false,
            a11y: {
              prevSlideMessage: 'Previous slide',
              nextSlideMessage: 'Next slide',
              lastSlideMessage: 'This is last slide',
              slideRole: 'Group'
            },
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev',
            },
            keyboard: {
              enabled: true,
              onlyInViewport: false
            },
            thumbs: {
              swiper: galleryThumbnails,
            },
          });

          galleryTop.on('slideChange init', function(){
            var count = galleryTop.slides.length;
            var active = galleryTop.activeIndex;
            var activeSlide = galleryTop.slides[galleryTop.activeIndex];
            var src = window.location.href.split('#')[0];

            swiperActiveSlide(active);
            pictureCountContainer.html('<span>'+ (active + 1) + '/' + count +'</span>');
            
            var id = $(activeSlide).find('a').attr('id');

            if (id) {
              var query = parseQuery(window.location.search.replace('?', ''));
              query.gallery = id;
              var hash = Object.keys(query).filter(function(key) {
                return key;
              }).map(function(key){
                return key+'='+query[key];
              }).join('&');

              src = src.split('?', 1) + '?' + hash;
            }

            shareBtn.data('url', src);

            if(galleryThumbnails.slides.length === 0){
              pictureCountContainer.hide();
            }
          });

          galleryTop.init();
          galleryTop.$wrapperEl.removeAttr('aria-live');
				}

        function swiperActiveSlide(act) {
          var thumbnails = $('.gallery-thumbnails');
          var swiperActive = thumbnails.find('.swiper-slide-thumb-active');
          var pictureTitleContainer = thumbnails.find('.image-description');
          var pictureTitle = swiperActive.find('.gallery-image-item').attr('title');
          var pictureTitleContainer = $('.picture-modal').find('.image-description > .title');
          var galleryTop = $('.gallery-top');
          var topSlideActive = galleryTop.find('.swiper-slide-active');
          var topTitle = topSlideActive.find('.gallery-image-item').attr('title');

          $('.gallery-image-item').on('click', function(e){
            e.preventDefault();
          });
                    
          act = swiperActive.index() + 1;
          pictureTitleContainer.html(pictureTitle);

          if(thumbnails.find('.swiper-wrapper').children().length === 0){
            pictureTitleContainer.html(topTitle);
          }
        }

        function smallGallery(id) {
          var anchorId = anchor.filter(id);
          if(anchorId.length > 0){
            anchorId.trigger('click');
          }
        }

        function bigGallery(id) {
          var thumbnails = $('.gallery-thumbnails');
          var thumbId = thumbs.find(id);
          thumbId.trigger('click');
          anchor.trigger('click');
          thumbnails.find(id).trigger('click');
        }
			});
		}
  });

}(window.jQuery);
/* window.jQuery to end !function */
/*
 * International Telephone Input v17.0.12
 * https://github.com/jackocnr/intl-tel-input.git
 * Licensed under the MIT license
 */

!function(a){"object"==typeof module&&module.exports?module.exports=a(require("jquery")):"function"==typeof define&&define.amd?define(["jquery"],function(b){a(b)}):a(jQuery)}(function(a,b){"use strict";function c(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function d(a,b){for(var c=0;c<b.length;c++){var d=b[c];d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=!0),Object.defineProperty(a,d.key,d)}}function e(a,b,c){return b&&d(a.prototype,b),c&&d(a,c),a}for(var f=[["Afghanistan ()","af","93"],["Albania (Shqipri)","al","355"],["Algeria ()","dz","213"],["American Samoa","as","1",5,["684"]],["Andorra","ad","376"],["Angola","ao","244"],["Anguilla","ai","1",6,["264"]],["Antigua and Barbuda","ag","1",7,["268"]],["Argentina","ar","54"],["Armenia ()","am","374"],["Aruba","aw","297"],["Ascension Island","ac","247"],["Australia","au","61",0],["Austria (sterreich)","at","43"],["Azerbaijan (Azrbaycan)","az","994"],["Bahamas","bs","1",8,["242"]],["Bahrain ()","bh","973"],["Bangladesh ()","bd","880"],["Barbados","bb","1",9,["246"]],["Belarus ()","by","375"],["Belgium (Belgi)","be","32"],["Belize","bz","501"],["Benin (Bnin)","bj","229"],["Bermuda","bm","1",10,["441"]],["Bhutan ()","bt","975"],["Bolivia","bo","591"],["Bosnia and Herzegovina (  )","ba","387"],["Botswana","bw","267"],["Brazil (Brasil)","br","55"],["British Indian Ocean Territory","io","246"],["British Virgin Islands","vg","1",11,["284"]],["Brunei","bn","673"],["Bulgaria ()","bg","359"],["Burkina Faso","bf","226"],["Burundi (Uburundi)","bi","257"],["Cambodia ()","kh","855"],["Cameroon (Cameroun)","cm","237"],["Canada","ca","1",1,["204","226","236","249","250","289","306","343","365","387","403","416","418","431","437","438","450","506","514","519","548","579","581","587","604","613","639","647","672","705","709","742","778","780","782","807","819","825","867","873","902","905"]],["Cape Verde (Kabu Verdi)","cv","238"],["Caribbean Netherlands","bq","599",1,["3","4","7"]],["Cayman Islands","ky","1",12,["345"]],["Central African Republic (Rpublique centrafricaine)","cf","236"],["Chad (Tchad)","td","235"],["Chile","cl","56"],["China ()","cn","86"],["Christmas Island","cx","61",2,["89164"]],["Cocos (Keeling) Islands","cc","61",1,["89162"]],["Colombia","co","57"],["Comoros ( )","km","269"],["Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)","cd","243"],["Congo (Republic) (Congo-Brazzaville)","cg","242"],["Cook Islands","ck","682"],["Costa Rica","cr","506"],["Cte dIvoire","ci","225"],["Croatia (Hrvatska)","hr","385"],["Cuba","cu","53"],["Curaao","cw","599",0],["Cyprus ()","cy","357"],["Czech Republic (esk republika)","cz","420"],["Denmark (Danmark)","dk","45"],["Djibouti","dj","253"],["Dominica","dm","1",13,["767"]],["Dominican Republic (Repblica Dominicana)","do","1",2,["809","829","849"]],["Ecuador","ec","593"],["Egypt ()","eg","20"],["El Salvador","sv","503"],["Equatorial Guinea (Guinea Ecuatorial)","gq","240"],["Eritrea","er","291"],["Estonia (Eesti)","ee","372"],["Eswatini","sz","268"],["Ethiopia","et","251"],["Falkland Islands (Islas Malvinas)","fk","500"],["Faroe Islands (Froyar)","fo","298"],["Fiji","fj","679"],["Finland (Suomi)","fi","358",0],["France","fr","33"],["French Guiana (Guyane franaise)","gf","594"],["French Polynesia (Polynsie franaise)","pf","689"],["Gabon","ga","241"],["Gambia","gm","220"],["Georgia ()","ge","995"],["Germany (Deutschland)","de","49"],["Ghana (Gaana)","gh","233"],["Gibraltar","gi","350"],["Greece ()","gr","30"],["Greenland (Kalaallit Nunaat)","gl","299"],["Grenada","gd","1",14,["473"]],["Guadeloupe","gp","590",0],["Guam","gu","1",15,["671"]],["Guatemala","gt","502"],["Guernsey","gg","44",1,["1481","7781","7839","7911"]],["Guinea (Guine)","gn","224"],["Guinea-Bissau (Guin Bissau)","gw","245"],["Guyana","gy","592"],["Haiti","ht","509"],["Honduras","hn","504"],["Hong Kong ()","hk","852"],["Hungary (Magyarorszg)","hu","36"],["Iceland (sland)","is","354"],["India ()","in","91"],["Indonesia","id","62"],["Iran ()","ir","98"],["Iraq ()","iq","964"],["Ireland","ie","353"],["Isle of Man","im","44",2,["1624","74576","7524","7924","7624"]],["Israel ()","il","972"],["Italy (Italia)","it","39",0],["Jamaica","jm","1",4,["876","658"]],["Japan ()","jp","81"],["Jersey","je","44",3,["1534","7509","7700","7797","7829","7937"]],["Jordan ()","jo","962"],["Kazakhstan ()","kz","7",1,["33","7"]],["Kenya","ke","254"],["Kiribati","ki","686"],["Kosovo","xk","383"],["Kuwait ()","kw","965"],["Kyrgyzstan ()","kg","996"],["Laos ()","la","856"],["Latvia (Latvija)","lv","371"],["Lebanon ()","lb","961"],["Lesotho","ls","266"],["Liberia","lr","231"],["Libya ()","ly","218"],["Liechtenstein","li","423"],["Lithuania (Lietuva)","lt","370"],["Luxembourg","lu","352"],["Macau ()","mo","853"],["Macedonia (FYROM) ()","mk","389"],["Madagascar (Madagasikara)","mg","261"],["Malawi","mw","265"],["Malaysia","my","60"],["Maldives","mv","960"],["Mali","ml","223"],["Malta","mt","356"],["Marshall Islands","mh","692"],["Martinique","mq","596"],["Mauritania ()","mr","222"],["Mauritius (Moris)","mu","230"],["Mayotte","yt","262",1,["269","639"]],["Mexico (Mxico)","mx","52"],["Micronesia","fm","691"],["Moldova (Republica Moldova)","md","373"],["Monaco","mc","377"],["Mongolia ()","mn","976"],["Montenegro (Crna Gora)","me","382"],["Montserrat","ms","1",16,["664"]],["Morocco ()","ma","212",0],["Mozambique (Moambique)","mz","258"],["Myanmar (Burma) ()","mm","95"],["Namibia (Namibi)","na","264"],["Nauru","nr","674"],["Nepal ()","np","977"],["Netherlands (Nederland)","nl","31"],["New Caledonia (Nouvelle-Caldonie)","nc","687"],["New Zealand","nz","64"],["Nicaragua","ni","505"],["Niger (Nijar)","ne","227"],["Nigeria","ng","234"],["Niue","nu","683"],["Norfolk Island","nf","672"],["North Korea (   )","kp","850"],["Northern Mariana Islands","mp","1",17,["670"]],["Norway (Norge)","no","47",0],["Oman ()","om","968"],["Pakistan ()","pk","92"],["Palau","pw","680"],["Palestine ()","ps","970"],["Panama (Panam)","pa","507"],["Papua New Guinea","pg","675"],["Paraguay","py","595"],["Peru (Per)","pe","51"],["Philippines","ph","63"],["Poland (Polska)","pl","48"],["Portugal","pt","351"],["Puerto Rico","pr","1",3,["787","939"]],["Qatar ()","qa","974"],["Runion (La Runion)","re","262",0],["Romania (Romnia)","ro","40"],["Russia ()","ru","7",0],["Rwanda","rw","250"],["Saint Barthlemy","bl","590",1],["Saint Helena","sh","290"],["Saint Kitts and Nevis","kn","1",18,["869"]],["Saint Lucia","lc","1",19,["758"]],["Saint Martin (Saint-Martin (partie franaise))","mf","590",2],["Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)","pm","508"],["Saint Vincent and the Grenadines","vc","1",20,["784"]],["Samoa","ws","685"],["San Marino","sm","378"],["So Tom and Prncipe (So Tom e Prncipe)","st","239"],["Saudi Arabia (  )","sa","966"],["Senegal (Sngal)","sn","221"],["Serbia ()","rs","381"],["Seychelles","sc","248"],["Sierra Leone","sl","232"],["Singapore","sg","65"],["Sint Maarten","sx","1",21,["721"]],["Slovakia (Slovensko)","sk","421"],["Slovenia (Slovenija)","si","386"],["Solomon Islands","sb","677"],["Somalia (Soomaaliya)","so","252"],["South Africa","za","27"],["South Korea ()","kr","82"],["South Sudan ( )","ss","211"],["Spain (Espaa)","es","34"],["Sri Lanka ( )","lk","94"],["Sudan ()","sd","249"],["Suriname","sr","597"],["Svalbard and Jan Mayen","sj","47",1,["79"]],["Sweden (Sverige)","se","46"],["Switzerland (Schweiz)","ch","41"],["Syria ()","sy","963"],["Taiwan ()","tw","886"],["Tajikistan","tj","992"],["Tanzania","tz","255"],["Thailand ()","th","66"],["Timor-Leste","tl","670"],["Togo","tg","228"],["Tokelau","tk","690"],["Tonga","to","676"],["Trinidad and Tobago","tt","1",22,["868"]],["Tunisia ()","tn","216"],["Turkey (Trkiye)","tr","90"],["Turkmenistan","tm","993"],["Turks and Caicos Islands","tc","1",23,["649"]],["Tuvalu","tv","688"],["U.S. Virgin Islands","vi","1",24,["340"]],["Uganda","ug","256"],["Ukraine ()","ua","380"],["United Arab Emirates (  )","ae","971"],["United Kingdom","gb","44",0],["United States","us","1",0],["Uruguay","uy","598"],["Uzbekistan (Ozbekiston)","uz","998"],["Vanuatu","vu","678"],["Vatican City (Citt del Vaticano)","va","39",1,["06698"]],["Venezuela","ve","58"],["Vietnam (Vit Nam)","vn","84"],["Wallis and Futuna (Wallis-et-Futuna)","wf","681"],["Western Sahara ( )","eh","212",1,["5288","5289"]],["Yemen ()","ye","967"],["Zambia","zm","260"],["Zimbabwe","zw","263"],["land Islands","ax","358",1,["18"]]],g=0;g<f.length;g++){var h=f[g];f[g]={name:h[0],iso2:h[1],dialCode:h[2],priority:h[3]||0,areaCodes:h[4]||null}}var i={getInstance:function(a){var b=a.getAttribute("data-intl-tel-input-id");return window.intlTelInputGlobals.instances[b]},instances:{},documentReady:function(){return"complete"===document.readyState}};"object"==typeof window&&(window.intlTelInputGlobals=i);var j=0,k={allowDropdown:!0,autoHideDialCode:!0,autoPlaceholder:"polite",customContainer:"",customPlaceholder:null,dropdownContainer:null,excludeCountries:[],formatOnDisplay:!0,geoIpLookup:null,hiddenInput:"",initialCountry:"",localizedCountries:null,nationalMode:!0,onlyCountries:[],placeholderNumberType:"MOBILE",preferredCountries:["us","gb"],separateDialCode:!1,utilsScript:""},l=["800","822","833","844","855","866","877","880","881","882","883","884","885","886","887","888","889"],m=function(a,b){for(var c=Object.keys(a),d=0;d<c.length;d++)b(c[d],a[c[d]])},n=function(a){m(window.intlTelInputGlobals.instances,function(b){window.intlTelInputGlobals.instances[b][a]()})},o=function(){function a(b,d){var e=this;c(this,a),this.id=j++,this.a=b,this.b=null,this.c=null;var f=d||{};this.d={},m(k,function(a,b){e.d[a]=f.hasOwnProperty(a)?f[a]:b}),this.e=Boolean(b.getAttribute("placeholder"))}return e(a,[{key:"_init",value:function(){var a=this;if(this.d.nationalMode&&(this.d.autoHideDialCode=!1),this.d.separateDialCode&&(this.d.autoHideDialCode=this.d.nationalMode=!1),this.g=/Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),this.g&&(document.body.classList.add("iti-mobile"),this.d.dropdownContainer||(this.d.dropdownContainer=document.body)),"undefined"!=typeof Promise){var b=new Promise(function(b,c){a.h=b,a.i=c}),c=new Promise(function(b,c){a.i0=b,a.i1=c});this.promise=Promise.all([b,c])}else this.h=this.i=function(){},this.i0=this.i1=function(){};this.s={},this._b(),this._f(),this._h(),this._i(),this._i3()}},{key:"_b",value:function(){this._d(),this._d2(),this._e(),this.d.localizedCountries&&this._d0(),(this.d.onlyCountries.length||this.d.localizedCountries)&&this.p.sort(this._d1)}},{key:"_c",value:function(a,c,d){c.length>this.countryCodeMaxLen&&(this.countryCodeMaxLen=c.length),this.q.hasOwnProperty(c)||(this.q[c]=[]);for(var e=0;e<this.q[c].length;e++)if(this.q[c][e]===a)return;var f=d!==b?d:this.q[c].length;this.q[c][f]=a}},{key:"_d",value:function(){if(this.d.onlyCountries.length){var a=this.d.onlyCountries.map(function(a){return a.toLowerCase()});this.p=f.filter(function(b){return a.indexOf(b.iso2)>-1})}else if(this.d.excludeCountries.length){var b=this.d.excludeCountries.map(function(a){return a.toLowerCase()});this.p=f.filter(function(a){return-1===b.indexOf(a.iso2)})}else this.p=f}},{key:"_d0",value:function(){for(var a=0;a<this.p.length;a++){var b=this.p[a].iso2.toLowerCase();this.d.localizedCountries.hasOwnProperty(b)&&(this.p[a].name=this.d.localizedCountries[b])}}},{key:"_d1",value:function(a,b){return a.name.localeCompare(b.name)}},{key:"_d2",value:function(){this.countryCodeMaxLen=0,this.dialCodes={},this.q={};for(var a=0;a<this.p.length;a++){var b=this.p[a];this.dialCodes[b.dialCode]||(this.dialCodes[b.dialCode]=!0),this._c(b.iso2,b.dialCode,b.priority)}for(var c=0;c<this.p.length;c++){var d=this.p[c];if(d.areaCodes)for(var e=this.q[d.dialCode][0],f=0;f<d.areaCodes.length;f++){for(var g=d.areaCodes[f],h=1;h<g.length;h++){var i=d.dialCode+g.substr(0,h);this._c(e,i),this._c(d.iso2,i)}this._c(d.iso2,d.dialCode+g)}}}},{key:"_e",value:function(){this.preferredCountries=[];for(var a=0;a<this.d.preferredCountries.length;a++){var b=this.d.preferredCountries[a].toLowerCase(),c=this._y(b,!1,!0);c&&this.preferredCountries.push(c)}}},{key:"_e2",value:function(a,b,c){var d=document.createElement(a);return b&&m(b,function(a,b){return d.setAttribute(a,b)}),c&&c.appendChild(d),d}},{key:"_f",value:function(){this.a.hasAttribute("autocomplete")||this.a.form&&this.a.form.hasAttribute("autocomplete")||this.a.setAttribute("autocomplete","off");var a="iti";this.d.allowDropdown&&(a+=" iti--allow-dropdown"),this.d.separateDialCode&&(a+=" iti--separate-dial-code"),this.d.customContainer&&(a+=" ",a+=this.d.customContainer);var b=this._e2("div",{"class":a});if(this.a.parentNode.insertBefore(b,this.a),this.k=this._e2("div",{"class":"iti__flag-container"},b),b.appendChild(this.a),this.selectedFlag=this._e2("div",{"class":"iti__selected-flag",role:"combobox","aria-controls":"iti-".concat(this.id,"__country-listbox"),"aria-owns":"iti-".concat(this.id,"__country-listbox"),"aria-expanded":"false"},this.k),this.l=this._e2("div",{"class":"iti__flag"},this.selectedFlag),this.d.separateDialCode&&(this.t=this._e2("div",{"class":"iti__selected-dial-code"},this.selectedFlag)),this.d.allowDropdown&&(this.selectedFlag.setAttribute("tabindex","0"),this.u=this._e2("div",{"class":"iti__arrow"},this.selectedFlag),this.m=this._e2("ul",{"class":"iti__country-list iti__hide",id:"iti-".concat(this.id,"__country-listbox"),role:"listbox","aria-label":"List of countries"}),this.preferredCountries.length&&(this._g(this.preferredCountries,"iti__preferred",!0),this._e2("li",{"class":"iti__divider",role:"separator","aria-disabled":"true"},this.m)),this._g(this.p,"iti__standard"),this.d.dropdownContainer?(this.dropdown=this._e2("div",{"class":"iti iti--container"}),this.dropdown.appendChild(this.m)):this.k.appendChild(this.m)),this.d.hiddenInput){var c=this.d.hiddenInput,d=this.a.getAttribute("name");if(d){var e=d.lastIndexOf("[");-1!==e&&(c="".concat(d.substr(0,e),"[").concat(c,"]"))}this.hiddenInput=this._e2("input",{type:"hidden",name:c}),b.appendChild(this.hiddenInput)}}},{key:"_g",value:function(a,b,c){for(var d="",e=0;e<a.length;e++){var f=a[e],g=c?"-preferred":"";d+="<li class='iti__country ".concat(b,"' tabIndex='-1' id='iti-").concat(this.id,"__item-").concat(f.iso2).concat(g,"' role='option' data-dial-code='").concat(f.dialCode,"' data-country-code='").concat(f.iso2,"' aria-selected='false'>"),d+="<div class='iti__flag-box'><div class='iti__flag iti__".concat(f.iso2,"'></div></div>"),d+="<span class='iti__country-name'>".concat(f.name,"</span>"),d+="<span class='iti__dial-code'>+".concat(f.dialCode,"</span>"),d+="</li>"}this.m.insertAdjacentHTML("beforeend",d)}},{key:"_h",value:function(){var a=this.a.getAttribute("value"),b=this.a.value,c=a&&"+"===a.charAt(0)&&(!b||"+"!==b.charAt(0)),d=c?a:b,e=this._5(d),f=this._w(d),g=this.d,h=g.initialCountry,i=g.nationalMode,j=g.autoHideDialCode,k=g.separateDialCode;e&&!f?this._v(d):"auto"!==h&&(h?this._z(h.toLowerCase()):e&&f?this._z("us"):(this.j=this.preferredCountries.length?this.preferredCountries[0].iso2:this.p[0].iso2,d||this._z(this.j)),d||i||j||k||(this.a.value="+".concat(this.s.dialCode))),d&&this._u(d)}},{key:"_i",value:function(){this._j(),this.d.autoHideDialCode&&this._l(),this.d.allowDropdown&&this._i2(),this.hiddenInput&&this._i0()}},{key:"_i0",value:function(){var a=this;this._a14=function(){a.hiddenInput.value=a.getNumber()},this.a.form&&this.a.form.addEventListener("submit",this._a14)}},{key:"_i1",value:function(){for(var a=this.a;a&&"LABEL"!==a.tagName;)a=a.parentNode;return a}},{key:"_i2",value:function(){var a=this;this._a9=function(b){a.m.classList.contains("iti__hide")?a.a.focus():b.preventDefault()};var b=this._i1();b&&b.addEventListener("click",this._a9),this._a10=function(){!a.m.classList.contains("iti__hide")||a.a.disabled||a.a.readOnly||a._n()},this.selectedFlag.addEventListener("click",this._a10),this._a11=function(b){a.m.classList.contains("iti__hide")&&-1!==["ArrowUp","Up","ArrowDown","Down"," ","Enter"].indexOf(b.key)&&(b.preventDefault(),b.stopPropagation(),a._n()),"Tab"===b.key&&a._2()},this.k.addEventListener("keydown",this._a11)}},{key:"_i3",value:function(){var a=this;this.d.utilsScript&&!window.intlTelInputUtils?window.intlTelInputGlobals.documentReady()?window.intlTelInputGlobals.loadUtils(this.d.utilsScript):window.addEventListener("load",function(){window.intlTelInputGlobals.loadUtils(a.d.utilsScript)}):this.i0(),"auto"===this.d.initialCountry?this._i4():this.h()}},{key:"_i4",value:function(){window.intlTelInputGlobals.autoCountry?this.handleAutoCountry():window.intlTelInputGlobals.startedLoadingAutoCountry||(window.intlTelInputGlobals.startedLoadingAutoCountry=!0,"function"==typeof this.d.geoIpLookup&&this.d.geoIpLookup(function(a){window.intlTelInputGlobals.autoCountry=a.toLowerCase(),setTimeout(function(){return n("handleAutoCountry")})},function(){return n("rejectAutoCountryPromise")}))}},{key:"_j",value:function(){var a=this;this._a12=function(){a._v(a.a.value)&&a._m2CountryChange()},this.a.addEventListener("keyup",this._a12),this._a13=function(){setTimeout(a._a12)},this.a.addEventListener("cut",this._a13),this.a.addEventListener("paste",this._a13)}},{key:"_j2",value:function(a){var b=this.a.getAttribute("maxlength");return b&&a.length>b?a.substr(0,b):a}},{key:"_l",value:function(){var a=this;this._a8=function(){a._l2()},this.a.form&&this.a.form.addEventListener("submit",this._a8),this.a.addEventListener("blur",this._a8)}},{key:"_l2",value:function(){if("+"===this.a.value.charAt(0)){var a=this._m(this.a.value);a&&this.s.dialCode!==a||(this.a.value="")}}},{key:"_m",value:function(a){return a.replace(/\D/g,"")}},{key:"_m2",value:function(a){var b=document.createEvent("Event");b.initEvent(a,!0,!0),this.a.dispatchEvent(b)}},{key:"_n",value:function(){this.m.classList.remove("iti__hide"),this.selectedFlag.setAttribute("aria-expanded","true"),this._o(),this.b&&(this._x(this.b,!1),this._3(this.b,!0)),this._p(),this.u.classList.add("iti__arrow--up"),this._m2("open:countrydropdown")}},{key:"_n2",value:function(a,b,c){c&&!a.classList.contains(b)?a.classList.add(b):!c&&a.classList.contains(b)&&a.classList.remove(b)}},{key:"_o",value:function(){var a=this;if(this.d.dropdownContainer&&this.d.dropdownContainer.appendChild(this.dropdown),!this.g){var b=this.a.getBoundingClientRect(),c=window.pageYOffset||document.documentElement.scrollTop,d=b.top+c,e=this.m.offsetHeight,f=d+this.a.offsetHeight+e<c+window.innerHeight,g=d-e>c;if(this._n2(this.m,"iti__country-list--dropup",!f&&g),this.d.dropdownContainer){var h=!f&&g?0:this.a.offsetHeight;this.dropdown.style.top="".concat(d+h,"px"),this.dropdown.style.left="".concat(b.left+document.body.scrollLeft,"px"),this._a4=function(){return a._2()},window.addEventListener("scroll",this._a4)}}}},{key:"_o2",value:function(a){for(var b=a;b&&b!==this.m&&!b.classList.contains("iti__country");)b=b.parentNode;return b===this.m?null:b}},{key:"_p",value:function(){var a=this;this._a0=function(b){var c=a._o2(b.target);c&&a._x(c,!1)},this.m.addEventListener("mouseover",this._a0),this._a1=function(b){var c=a._o2(b.target);c&&a._1(c)},this.m.addEventListener("click",this._a1);var b=!0;this._a2=function(){b||a._2(),b=!1},document.documentElement.addEventListener("click",this._a2);var c="",d=null;this._a3=function(b){b.preventDefault(),"ArrowUp"===b.key||"Up"===b.key||"ArrowDown"===b.key||"Down"===b.key?a._q(b.key):"Enter"===b.key?a._r():"Escape"===b.key?a._2():/^[a-zA-Z--- ]$/.test(b.key)&&(d&&clearTimeout(d),c+=b.key.toLowerCase(),a._s(c),d=setTimeout(function(){c=""},1e3))},document.addEventListener("keydown",this._a3)}},{key:"_q",value:function(a){var b="ArrowUp"===a||"Up"===a?this.c.previousElementSibling:this.c.nextElementSibling;b&&(b.classList.contains("iti__divider")&&(b="ArrowUp"===a||"Up"===a?b.previousElementSibling:b.nextElementSibling),this._x(b,!0))}},{key:"_r",value:function(){this.c&&this._1(this.c)}},{key:"_s",value:function(a){for(var b=0;b<this.p.length;b++)if(this._t(this.p[b].name,a)){var c=this.m.querySelector("#iti-".concat(this.id,"__item-").concat(this.p[b].iso2));this._x(c,!1),this._3(c,!0);break}}},{key:"_t",value:function(a,b){return a.substr(0,b.length).toLowerCase()===b}},{key:"_u",value:function(a){var b=a;if(this.d.formatOnDisplay&&window.intlTelInputUtils&&this.s){var c=!this.d.separateDialCode&&(this.d.nationalMode||"+"!==b.charAt(0)),d=intlTelInputUtils.numberFormat,e=d.NATIONAL,f=d.INTERNATIONAL,g=c?e:f;b=intlTelInputUtils.formatNumber(b,this.s.iso2,g)}b=this._7(b),this.a.value=b}},{key:"_v",value:function(a){var b=a,c=this.s.dialCode,d="1"===c;b&&this.d.nationalMode&&d&&"+"!==b.charAt(0)&&("1"!==b.charAt(0)&&(b="1".concat(b)),b="+".concat(b)),this.d.separateDialCode&&c&&"+"!==b.charAt(0)&&(b="+".concat(c).concat(b));var e=this._5(b,!0),f=this._m(b),g=null;if(e){var h=this.q[this._m(e)],i=-1!==h.indexOf(this.s.iso2)&&f.length<=e.length-1;if(!("1"===c&&this._w(f))&&!i)for(var j=0;j<h.length;j++)if(h[j]){g=h[j];break}}else"+"===b.charAt(0)&&f.length?g="":b&&"+"!==b||(g=this.j);return null!==g&&this._z(g)}},{key:"_w",value:function(a){var b=this._m(a);if("1"===b.charAt(0)){var c=b.substr(1,3);return-1!==l.indexOf(c)}return!1}},{key:"_x",value:function(a,b){var c=this.c;c&&c.classList.remove("iti__highlight"),this.c=a,this.c.classList.add("iti__highlight"),b&&this.c.focus()}},{key:"_y",value:function(a,b,c){for(var d=b?f:this.p,e=0;e<d.length;e++)if(d[e].iso2===a)return d[e];if(c)return null;throw new Error("No country data for '".concat(a,"'"))}},{key:"_z",value:function(a){var b=this.s.iso2?this.s:{};this.s=a?this._y(a,!1,!1):{},this.s.iso2&&(this.j=this.s.iso2),this.l.setAttribute("class","iti__flag iti__".concat(a));var c=a?"".concat(this.s.name,": +").concat(this.s.dialCode):"Unknown";if(this.selectedFlag.setAttribute("title",c),this.d.separateDialCode){var d=this.s.dialCode?"+".concat(this.s.dialCode):"";this.t.innerHTML=d;var e=this.selectedFlag.offsetWidth||this._z2();this.a.style.paddingLeft="".concat(e+6,"px")}if(this._0(),this.d.allowDropdown){var f=this.b;if(f&&(f.classList.remove("iti__active"),f.setAttribute("aria-selected","false")),a){var g=this.m.querySelector("#iti-".concat(this.id,"__item-").concat(a,"-preferred"))||this.m.querySelector("#iti-".concat(this.id,"__item-").concat(a));g.setAttribute("aria-selected","true"),g.classList.add("iti__active"),this.b=g,this.selectedFlag.setAttribute("aria-activedescendant",g.getAttribute("id"))}}return b.iso2!==a}},{key:"_z2",value:function(){var a=this.a.parentNode.cloneNode();a.style.visibility="hidden",document.body.appendChild(a);var b=this.k.cloneNode();a.appendChild(b);var c=this.selectedFlag.cloneNode(!0);b.appendChild(c);var d=c.offsetWidth;return a.parentNode.removeChild(a),d}},{key:"_0",value:function(){var a="aggressive"===this.d.autoPlaceholder||!this.e&&"polite"===this.d.autoPlaceholder;if(window.intlTelInputUtils&&a){var b=intlTelInputUtils.numberType[this.d.placeholderNumberType],c=this.s.iso2?intlTelInputUtils.getExampleNumber(this.s.iso2,this.d.nationalMode,b):"";c=this._7(c),"function"==typeof this.d.customPlaceholder&&(c=this.d.customPlaceholder(c,this.s)),this.a.setAttribute("placeholder",c)}}},{key:"_1",value:function(a){var b=this._z(a.getAttribute("data-country-code"));this._2(),this._4(a.getAttribute("data-dial-code"),!0),this.a.focus();var c=this.a.value.length;this.a.setSelectionRange(c,c),b&&this._m2CountryChange()}},{key:"_2",value:function(){this.m.classList.add("iti__hide"),this.selectedFlag.setAttribute("aria-expanded","false"),this.u.classList.remove("iti__arrow--up"),document.removeEventListener("keydown",this._a3),document.documentElement.removeEventListener("click",this._a2),this.m.removeEventListener("mouseover",this._a0),this.m.removeEventListener("click",this._a1),this.d.dropdownContainer&&(this.g||window.removeEventListener("scroll",this._a4),this.dropdown.parentNode&&this.dropdown.parentNode.removeChild(this.dropdown)),this._m2("close:countrydropdown")}},{key:"_3",value:function(a,b){var c=this.m,d=window.pageYOffset||document.documentElement.scrollTop,e=c.offsetHeight,f=c.getBoundingClientRect().top+d,g=f+e,h=a.offsetHeight,i=a.getBoundingClientRect().top+d,j=i+h,k=i-f+c.scrollTop,l=e/2-h/2;if(i<f)b&&(k-=l),c.scrollTop=k;else if(j>g){b&&(k+=l);var m=e-h;c.scrollTop=k-m}}},{key:"_4",value:function(a,b){var c,d=this.a.value,e="+".concat(a);if("+"===d.charAt(0)){var f=this._5(d);c=f?d.replace(f,e):e}else{if(this.d.nationalMode||this.d.separateDialCode)return;if(d)c=e+d;else{if(!b&&this.d.autoHideDialCode)return;c=e}}this.a.value=c}},{key:"_5",value:function(a,b){var c="";if("+"===a.charAt(0))for(var d="",e=0;e<a.length;e++){var f=a.charAt(e);if(!isNaN(parseInt(f,10))){if(d+=f,b)this.q[d]&&(c=a.substr(0,e+1));else if(this.dialCodes[d]){c=a.substr(0,e+1);break}if(d.length===this.countryCodeMaxLen)break}}return c}},{key:"_6",value:function(){var a=this.a.value.trim(),b=this.s.dialCode,c=this._m(a);return(this.d.separateDialCode&&"+"!==a.charAt(0)&&b&&c?"+".concat(b):"")+a}},{key:"_7",value:function(a){var b=a;if(this.d.separateDialCode){var c=this._5(b);if(c){c="+".concat(this.s.dialCode);var d=" "===b[c.length]||"-"===b[c.length]?c.length+1:c.length;b=b.substr(d)}}return this._j2(b)}},{key:"_m2CountryChange",value:function(){this._m2("countrychange")}},{key:"handleAutoCountry",value:function(){"auto"===this.d.initialCountry&&(this.j=window.intlTelInputGlobals.autoCountry,this.a.value||this.setCountry(this.j),this.h())}},{key:"handleUtils",value:function(){window.intlTelInputUtils&&(this.a.value&&this._u(this.a.value),this._0()),this.i0()}},{key:"destroy",value:function(){var a=this.a.form;if(this.d.allowDropdown){this._2(),this.selectedFlag.removeEventListener("click",this._a10),this.k.removeEventListener("keydown",this._a11);var b=this._i1();b&&b.removeEventListener("click",this._a9)}this.hiddenInput&&a&&a.removeEventListener("submit",this._a14),this.d.autoHideDialCode&&(a&&a.removeEventListener("submit",this._a8),this.a.removeEventListener("blur",this._a8)),this.a.removeEventListener("keyup",this._a12),this.a.removeEventListener("cut",this._a13),this.a.removeEventListener("paste",this._a13),this.a.removeAttribute("data-intl-tel-input-id");var c=this.a.parentNode;c.parentNode.insertBefore(this.a,c),c.parentNode.removeChild(c),delete window.intlTelInputGlobals.instances[this.id]}},{key:"getExtension",value:function(){return window.intlTelInputUtils?intlTelInputUtils.getExtension(this._6(),this.s.iso2):""}},{key:"getNumber",
value:function(a){if(window.intlTelInputUtils){var b=this.s.iso2;return intlTelInputUtils.formatNumber(this._6(),b,a)}return""}},{key:"getNumberType",value:function(){return window.intlTelInputUtils?intlTelInputUtils.getNumberType(this._6(),this.s.iso2):-99}},{key:"getSelectedCountryData",value:function(){return this.s}},{key:"getValidationError",value:function(){if(window.intlTelInputUtils){var a=this.s.iso2;return intlTelInputUtils.getValidationError(this._6(),a)}return-99}},{key:"isValidNumber",value:function(){var a=this._6().trim(),b=this.d.nationalMode?this.s.iso2:"";return window.intlTelInputUtils?intlTelInputUtils.isValidNumber(a,b):null}},{key:"setCountry",value:function(a){var b=a.toLowerCase();this.l.classList.contains("iti__".concat(b))||(this._z(b),this._4(this.s.dialCode,!1),this._m2CountryChange())}},{key:"setNumber",value:function(a){var b=this._v(a);this._u(a),b&&this._m2CountryChange()}},{key:"setPlaceholderNumberType",value:function(a){this.d.placeholderNumberType=a,this._0()}}]),a}();i.getCountryData=function(){return f};var p=function(a,b,c){var d=document.createElement("script");d.onload=function(){n("handleUtils"),b&&b()},d.onerror=function(){n("rejectUtilsScriptPromise"),c&&c()},d.className="iti-load-utils",d.async=!0,d.src=a,document.body.appendChild(d)};i.loadUtils=function(a){if(!window.intlTelInputUtils&&!window.intlTelInputGlobals.startedLoadingUtilsScript){if(window.intlTelInputGlobals.startedLoadingUtilsScript=!0,"undefined"!=typeof Promise)return new Promise(function(b,c){return p(a,b,c)});p(a)}return null},i.defaults=k,i.version="17.0.12";a.fn.intlTelInput=function(c){var d=arguments;if(c===b||"object"==typeof c)return this.each(function(){if(!a.data(this,"plugin_intlTelInput")){var b=new o(this,c);b._init(),window.intlTelInputGlobals.instances[b.id]=b,a.data(this,"plugin_intlTelInput",b)}});if("string"==typeof c&&"_"!==c[0]){var e;return this.each(function(){var b=a.data(this,"plugin_intlTelInput");b instanceof o&&"function"==typeof b[c]&&(e=b[c].apply(b,Array.prototype.slice.call(d,1))),"destroy"===c&&a.data(this,"plugin_intlTelInput",null)}),e!==b?e:this}}});
/* !function to prevent library conflicts */ 
!function ($) {

  $(function(){
    $.fn.modal = function(){
      $(this).each(function(){
        var main = $(this);
        var href = main.attr('href');
        var html, overlay;
        var modalType = main.attr('data-modaltype');
        var mainWrapper = $('.main-wrapper');
        var visible = false;
        
        main.on('click', function(e){
          e.preventDefault();
          e.stopPropagation();
          openOverlay(modalType);
          getData();
        });

        function getData(newHref) {

          var tmpHref = newHref ? newHref : href;
  
          xhr = $.ajax({
            dataType: "html",
            url: tmpHref,
            cache: false,
            success: function(response){
              html = $(response).find("[data-modal]")[0].outerHTML;
              appendOverlay();
            }
          });
        }
  
        function openOverlay(type) {
          if(visible){ return false; }
          visible = true;

          var output = '<div class="overlay">';
          output+= 	'</div><!--/overlay-->';

          if(main.parent().hasClass('event-header-buttons')){
            main.parent().append(overlay = $(output));
            setTimeout(function(){
              $('.calendar-share-items').find('a:first').focus();
            },350);
          }else {
            if(!type){
              $('body').addClass('modal-open');
              $('body').append(overlay = $(output));
              mainWrapper.attr('aria-hidden', 'true');
            }else {
              $('body').addClass('modal-secondary');
              $('body').append(overlay = $(output));
              mainWrapper.attr('aria-hidden', 'true');
            }
          }

          overlay.fadeIn(250, function(){});

          setTimeout(function(){
            var closeBtn = overlay.find('.btn-close');
            closeBtn.on('click', function(){
              closeOverlay();
            })
          }, 1000);
  
          overlay.off('click').on('click', function(e){
            if($(e.target).is('[data-close]')){
              closeOverlay(type);
            }
          });
        }

        function appendOverlay() {
          visible = true;
          if(!visible){
            setTimeout(function(){
              appendOverlay();
            },100);
            return false;
          }

          var output = '';
          output+= '<div class="focus-trap" tabindex="0"></div>'
          output+= html;
          output+= '<div class="focus-trap" tabindex="0"></div>'
          overlay.html(output);
          
          bindEvents();
        }

        function closeOverlay(type) {
          visible = false;
          html = '';

          setTimeout(function(){
            if(!type){
              mainWrapper.removeAttr('aria-hidden');
              overlay.fadeOut(250, function(){
                $('body').removeClass("modal-open");
                $('.overlay').remove();
                overlay.remove();
                main.focus();
              });
            }else {
              mainWrapper.removeAttr('aria-hidden');
              overlay.fadeOut(250, function(){
                $('body').removeClass("modal-secondary");
                overlay.remove();
                main.focus();
              });
            }
          }, 250);
        }

        function bindEvents() {
          var closeBtn = overlay.find('.btn-close:first');
          var firstItem = overlay.find('.focus-trap:first');
          var lastItem = overlay.find('.focus-trap:last');
          var parent = overlay.parent();
  
          closeBtn.focus();
  
          tabFocusTrap(firstItem, lastItem, closeBtn, parent);
  
          $(document).on('keyup.modal', function(e){
            if(e.code === 'Escape' || e.which == 27 ){
              closeOverlay();
              $(document).off("keyup.modal");
            }
          });
  
          $(document).on('click.modal', function(e){
            if($(e.target).parents('.overlay').length == 0){
              closeOverlay();
            }
          });

          $wpm.bindObjects(overlay);
        }

        function tabFocusTrap(firstItem, lastItem, close, parent){
          if(!parent.hasClass('event-header-buttons')){
            $(document).on('keyup', function(e){
              lastItem.on('keyup', function(e){
                if(e.keyCode == 9 || e.which == 9) {
                  e.preventDefault();
                  close.focus();
                }
              });
    
              firstItem.on('keyup', function(e){
                if(e.keyCode == 9 || e.which == 9 && e.keyCode == 16 || e.which == 16) {
                  e.preventDefault();
                  lastItem.focus();
                }
              });
            });
          }else {
            $(document).on('keyup', function(e){
              lastItem.on('keyup', function(e){
                if(e.keyCode == 9 || e.which == 9) {
                  e.preventDefault();
                  $('.calendar-share-items li>a:first').focus();
                }
              });
    
              firstItem.on('keyup', function(e){
                if(e.keyCode == 9 || e.which == 9 && e.keyCode == 16 || e.which == 16) {
                  e.preventDefault();
                  $('.calendar-share-items li>a:last').focus();
                }
              });
            });
          }
        }
      });
    }
  });
}(window.jQuery);
/* window.jQuery to end !function */
/*! RateIt | v1.1.5 / 03/10/2021
    https://github.com/gjunge/rateit.js | Twitter: @gjunge
*/
!function(M){function I(e){var t=e.originalEvent.changedTouches[0],a="";switch(e.type){case"touchmove":a="mousemove";break;case"touchend":a="mouseup";break;default:return}var i=document.createEvent("MouseEvent");i.initMouseEvent(a,!0,!0,window,1,t.screenX,t.screenY,t.clientX,t.clientY,!1,!1,!1,!1,0,null),t.target.dispatchEvent(i),e.preventDefault()}M.rateit={aria:{resetLabel:"reset rating",ratingLabel:"rating"}},M.fn.rateit=function(w,N){var y=1,C={},k="init",E=function(e){return e.charAt(0).toUpperCase()+e.substr(1)};if(0===this.length)return this;var e=typeof w;if("object"==e||null==w)C=M.extend({},M.fn.rateit.defaults,w);else{if("string"==e&&"reset"!==w&&void 0===N)return this.data("rateit"+E(w));"string"==e&&(k="setvalue")}return this.each(function(){var r=M(this),n=function(e,t){if(null!=t){var a="aria-value"+("value"==e?"now":e),i=r.find(".rateit-range");null!=i.attr(a)&&i.attr(a,t)}return e="rateit"+E(e),r.data.apply(r,arguments)};if("reset"==w){var e=n("init");for(var t in e)r.data(t,e[t]);if(n("backingfld"))"SELECT"==(a=M(n("backingfld")))[0].nodeName&&"index"===a[0].getAttribute("data-rateit-valuesrc")?a.prop("selectedIndex",n("value")):a.val(n("value")),a.trigger("change"),a[0].min&&(a[0].min=n("min")),a[0].max&&(a[0].max=n("max")),a[0].step&&(a[0].step=n("step"));r.trigger("reset")}r.hasClass("rateit")||r.addClass("rateit");var i="rtl"!=r.css("direction");if("setvalue"==k){if(!n("init"))throw"Can't set value before init";if("readonly"!=w||1!=N||n("readonly")||(r.find(".rateit-range").off(),n("wired",!1)),"value"==w&&(N=null==N?n("min"):Math.max(n("min"),Math.min(n("max"),N))),n("backingfld"))"SELECT"==(a=M(n("backingfld")))[0].nodeName&&"index"===a[0].getAttribute("data-rateit-valuesrc")?"value"==w&&a.prop("selectedIndex",N):"value"==w&&a.val(N),"min"==w&&a[0].min&&(a[0].min=N),"max"==w&&a[0].max&&(a[0].max=N),"step"==w&&a[0].step&&(a[0].step=N);n(w,N)}if(!n("init")){var a;if(n("mode",n("mode")||C.mode),n("icon",n("icon")||C.icon),n("min",isNaN(n("min"))?C.min:n("min")),n("max",isNaN(n("max"))?C.max:n("max")),n("step",n("step")||C.step),n("readonly",void 0!==n("readonly")?n("readonly"):C.readonly),n("resetable",void 0!==n("resetable")?n("resetable"):C.resetable),n("backingfld",n("backingfld")||C.backingfld),n("starwidth",n("starwidth")||C.starwidth),n("starheight",n("starheight")||C.starheight),n("value",Math.max(n("min"),Math.min(n("max"),isNaN(n("value"))?isNaN(C.value)?C.min:C.value:n("value")))),n("ispreset",void 0!==n("ispreset")?n("ispreset"):C.ispreset),n("backingfld"))if(((a=M(n("backingfld")).hide()).attr("disabled")||a.attr("readonly"))&&n("readonly",!0),"INPUT"==a[0].nodeName&&("range"!=a[0].type&&"text"!=a[0].type||(n("min",parseInt(a.attr("min"))||n("min")),n("max",parseInt(a.attr("max"))||n("max")),n("step",parseInt(a.attr("step"))||n("step")))),"SELECT"==a[0].nodeName&&1<a[0].options.length){"index"===a[0].getAttribute("data-rateit-valuesrc")?(n("min",isNaN(n("min"))?Number(a[0].options[0].index):n("min")),n("max",Number(a[0].options[a[0].length-1].index)),n("step",Number(a[0].options[1].index)-Number(a[0].options[0].index))):(n("min",isNaN(n("min"))?Number(a[0].options[0].value):n("min")),n("max",Number(a[0].options[a[0].length-1].value)),n("step",Number(a[0].options[1].value)-Number(a[0].options[0].value)));var s=a.find("option[selected]");1==s.length&&("index"===a[0].getAttribute("data-rateit-valuesrc")?n("value",s[0].index):n("value",s.val()))}else n("value",a.val());var d="DIV"==r[0].nodeName?"div":"span";y++;var l='<button id="rateit-reset-{{index}}" type="button" data-role="none" class="rateit-reset" aria-label="'+M.rateit.aria.resetLabel+'" aria-controls="rateit-range-{{index}}"><span></span></button><{{element}} id="rateit-range-{{index}}" class="rateit-range"'+(1==n("readonly")?"":' tabindex="0"')+' role="slider" aria-label="'+M.rateit.aria.ratingLabel+'" aria-owns="rateit-reset-{{index}}" aria-valuemin="'+n("min")+'" aria-valuemax="'+n("max")+'" aria-valuenow="'+n("value")+'"><{{element}} class="rateit-empty"></{{element}}><{{element}} class="rateit-selected"></{{element}}><{{element}} class="rateit-hover"></{{element}}></{{element}}>';r.append(l.replace(/{{index}}/gi,y).replace(/{{element}}/gi,d)),i||(r.find(".rateit-reset").css("float","right"),r.find(".rateit-selected").addClass("rateit-selected-rtl"),r.find(".rateit-hover").addClass("rateit-hover-rtl")),"font"==n("mode")?r.addClass("rateit-font").removeClass("rateit-bg"):r.addClass("rateit-bg").removeClass("rateit-font"),n("init",JSON.parse(JSON.stringify(r.data())))}var o="font"==n("mode");o||r.find(".rateit-selected, .rateit-hover").height(n("starheight"));var u=r.find(".rateit-range");if(o){for(var m=n("icon"),v=n("max")-n("min"),h="",c=0;c<v;c++)h+=m;u.find("> *").text(h),n("starwidth",u.width()/(n("max")-n("min")))}else u.width(n("starwidth")*(n("max")-n("min"))).height(n("starheight"));var g="rateit-preset"+(i?"":"-rtl");if(n("ispreset")?r.find(".rateit-selected").addClass(g):r.find(".rateit-selected").removeClass(g),null!=n("value")){var f=(n("value")-n("min"))*n("starwidth");r.find(".rateit-selected").width(f)}var p=r.find(".rateit-reset");!0!==p.data("wired")&&p.on("click",function(e){e.preventDefault(),p.trigger("blur");var t=M.Event("beforereset");if(r.trigger(t),t.isDefaultPrevented())return!1;r.rateit("value",null),r.trigger("reset")}).data("wired",!0);var b=function(e,t){var a=(t.changedTouches?t.changedTouches[0].pageX:t.pageX)-M(e).offset().left;return i||(a=u.width()-a),a>u.width()&&(a=u.width()),a<0&&(a=0),f=Math.ceil(a/n("starwidth")*(1/n("step")))},x=function(e){var t=M.Event("beforerated");return r.trigger(t,[e]),!t.isDefaultPrevented()&&(n("value",e),n("backingfld")&&("SELECT"==a[0].nodeName&&"index"===a[0].getAttribute("data-rateit-valuesrc")?M(n("backingfld")).prop("selectedIndex",e).trigger("change"):M(n("backingfld")).val(e).trigger("change")),n("ispreset")&&(u.find(".rateit-selected").removeClass(g),n("ispreset",!1)),u.find(".rateit-hover").hide(),u.find(".rateit-selected").width(e*n("starwidth")-n("min")*n("starwidth")).show(),r.trigger("hover",[null]).trigger("over",[null]).trigger("rated",[e]),!0)};n("readonly")?p.hide():(n("resetable")||p.hide(),n("wired")||(u.on("touchmove touchend",I),u.on("mousemove",function(e){!function(e){var t=e*n("starwidth")*n("step"),a=u.find(".rateit-hover");if(a.data("width")!=t){u.find(".rateit-selected").hide(),a.width(t).show().data("width",t);var i=[e*n("step")+n("min")];r.trigger("hover",i).trigger("over",i)}}(b(this,e))}),u.on("mouseleave",function(e){u.find(".rateit-hover").hide().width(0).data("width",""),r.trigger("hover",[null]).trigger("over",[null]),u.find(".rateit-selected").show()}),u.on("mouseup",function(e){var t=b(this,e)*n("step")+n("min");x(t),u.trigger("blur")}),u.on("keyup",function(e){38!=e.which&&e.which!=(i?39:37)||x(Math.min(n("value")+n("step"),n("max"))),40!=e.which&&e.which!=(i?37:39)||x(Math.max(n("value")-n("step"),n("min")))}),n("wired",!0)),n("resetable")&&p.show()),u.attr("aria-readonly",n("readonly"))})},M.fn.rateit.defaults={min:0,max:5,step:.5,mode:"bg",icon:"",starwidth:16,starheight:16,readonly:!1,resetable:!0,ispreset:!1},M(function(){M("div.rateit, span.rateit").rateit()})}(jQuery);
//# sourceMappingURL=jquery.rateit.min.js.map

;(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  global.moment = factory()
}(this, (function () { 'use strict';

  var hookCallback;

  function hooks() {
      return hookCallback.apply(null, arguments);
  }

  // This is done to register the method called with moment()
  // without creating circular dependencies.
  function setHookCallback(callback) {
      hookCallback = callback;
  }

  function isArray(input) {
      return (
          input instanceof Array ||
          Object.prototype.toString.call(input) === '[object Array]'
      );
  }

  function isObject(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return (
          input != null &&
          Object.prototype.toString.call(input) === '[object Object]'
      );
  }

  function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
  }

  function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
      } else {
          var k;
          for (k in obj) {
              if (hasOwnProp(obj, k)) {
                  return false;
              }
          }
          return true;
      }
  }

  function isUndefined(input) {
      return input === void 0;
  }

  function isNumber(input) {
      return (
          typeof input === 'number' ||
          Object.prototype.toString.call(input) === '[object Number]'
      );
  }

  function isDate(input) {
      return (
          input instanceof Date ||
          Object.prototype.toString.call(input) === '[object Date]'
      );
  }

  function map(arr, fn) {
      var res = [],
          i;
      for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
      }
      return res;
  }

  function extend(a, b) {
      for (var i in b) {
          if (hasOwnProp(b, i)) {
              a[i] = b[i];
          }
      }

      if (hasOwnProp(b, 'toString')) {
          a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
          a.valueOf = b.valueOf;
      }

      return a;
  }

  function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
  }

  function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false,
      };
  }

  function getParsingFlags(m) {
      if (m._pf == null) {
          m._pf = defaultParsingFlags();
      }
      return m._pf;
  }

  var some;
  if (Array.prototype.some) {
      some = Array.prototype.some;
  } else {
      some = function (fun) {
          var t = Object(this),
              len = t.length >>> 0,
              i;

          for (i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                  return true;
              }
          }

          return false;
      };
  }

  function isValid(m) {
      if (m._isValid == null) {
          var flags = getParsingFlags(m),
              parsedParts = some.call(flags.parsedDateParts, function (i) {
                  return i != null;
              }),
              isNowValid =
                  !isNaN(m._d.getTime()) &&
                  flags.overflow < 0 &&
                  !flags.empty &&
                  !flags.invalidEra &&
                  !flags.invalidMonth &&
                  !flags.invalidWeekday &&
                  !flags.weekdayMismatch &&
                  !flags.nullInput &&
                  !flags.invalidFormat &&
                  !flags.userInvalidated &&
                  (!flags.meridiem || (flags.meridiem && parsedParts));

          if (m._strict) {
              isNowValid =
                  isNowValid &&
                  flags.charsLeftOver === 0 &&
                  flags.unusedTokens.length === 0 &&
                  flags.bigHour === undefined;
          }

          if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
          } else {
              return isNowValid;
          }
      }
      return m._isValid;
  }

  function createInvalid(flags) {
      var m = createUTC(NaN);
      if (flags != null) {
          extend(getParsingFlags(m), flags);
      } else {
          getParsingFlags(m).userInvalidated = true;
      }

      return m;
  }

  // Plugins that add properties should also add the key here (null value),
  // so we can properly clone ourselves.
  var momentProperties = (hooks.momentProperties = []),
      updateInProgress = false;

  function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
          to._isAMomentObject = from._isAMomentObject;
      }
      if (!isUndefined(from._i)) {
          to._i = from._i;
      }
      if (!isUndefined(from._f)) {
          to._f = from._f;
      }
      if (!isUndefined(from._l)) {
          to._l = from._l;
      }
      if (!isUndefined(from._strict)) {
          to._strict = from._strict;
      }
      if (!isUndefined(from._tzm)) {
          to._tzm = from._tzm;
      }
      if (!isUndefined(from._isUTC)) {
          to._isUTC = from._isUTC;
      }
      if (!isUndefined(from._offset)) {
          to._offset = from._offset;
      }
      if (!isUndefined(from._pf)) {
          to._pf = getParsingFlags(from);
      }
      if (!isUndefined(from._locale)) {
          to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
          for (i = 0; i < momentProperties.length; i++) {
              prop = momentProperties[i];
              val = from[prop];
              if (!isUndefined(val)) {
                  to[prop] = val;
              }
          }
      }

      return to;
  }

  // Moment prototype object
  function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
          this._d = new Date(NaN);
      }
      // Prevent infinite loop in case updateOffset creates new moment
      // objects.
      if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
      }
  }

  function isMoment(obj) {
      return (
          obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
      );
  }

  function warn(msg) {
      if (
          hooks.suppressDeprecationWarnings === false &&
          typeof console !== 'undefined' &&
          console.warn
      ) {
          console.warn('Deprecation warning: ' + msg);
      }
  }

  function deprecate(msg, fn) {
      var firstTime = true;

      return extend(function () {
          if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
              var args = [],
                  arg,
                  i,
                  key;
              for (i = 0; i < arguments.length; i++) {
                  arg = '';
                  if (typeof arguments[i] === 'object') {
                      arg += '\n[' + i + '] ';
                      for (key in arguments[0]) {
                          if (hasOwnProp(arguments[0], key)) {
                              arg += key + ': ' + arguments[0][key] + ', ';
                          }
                      }
                      arg = arg.slice(0, -2); // Remove trailing comma and space
                  } else {
                      arg = arguments[i];
                  }
                  args.push(arg);
              }
              warn(
                  msg +
                      '\nArguments: ' +
                      Array.prototype.slice.call(args).join('') +
                      '\n' +
                      new Error().stack
              );
              firstTime = false;
          }
          return fn.apply(this, arguments);
      }, fn);
  }

  var deprecations = {};

  function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
      }
  }

  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;

  function isFunction(input) {
      return (
          (typeof Function !== 'undefined' && input instanceof Function) ||
          Object.prototype.toString.call(input) === '[object Function]'
      );
  }

  function set(config) {
      var prop, i;
      for (i in config) {
          if (hasOwnProp(config, i)) {
              prop = config[i];
              if (isFunction(prop)) {
                  this[i] = prop;
              } else {
                  this['_' + i] = prop;
              }
          }
      }
      this._config = config;
      // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.
      this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
              '|' +
              /\d{1,2}/.source
      );
  }

  function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;
      for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
              if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                  res[prop] = {};
                  extend(res[prop], parentConfig[prop]);
                  extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                  res[prop] = childConfig[prop];
              } else {
                  delete res[prop];
              }
          }
      }
      for (prop in parentConfig) {
          if (
              hasOwnProp(parentConfig, prop) &&
              !hasOwnProp(childConfig, prop) &&
              isObject(parentConfig[prop])
          ) {
              // make sure changes to properties don't modify parent config
              res[prop] = extend({}, res[prop]);
          }
      }
      return res;
  }

  function Locale(config) {
      if (config != null) {
          this.set(config);
      }
  }

  var keys;

  if (Object.keys) {
      keys = Object.keys;
  } else {
      keys = function (obj) {
          var i,
              res = [];
          for (i in obj) {
              if (hasOwnProp(obj, i)) {
                  res.push(i);
              }
          }
          return res;
      };
  }

  var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L',
  };

  function calendar(key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
  }

  function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (
          (sign ? (forceSign ? '+' : '') : '-') +
          Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
          absNumber
      );
  }

  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
      localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
      formatFunctions = {},
      formatTokenFunctions = {};

  // token:    'M'
  // padded:   ['MM', 2]
  // ordinal:  'Mo'
  // callback: function () { this.month() + 1 }
  function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;
      if (typeof callback === 'string') {
          func = function () {
              return this[callback]();
          };
      }
      if (token) {
          formatTokenFunctions[token] = func;
      }
      if (padded) {
          formatTokenFunctions[padded[0]] = function () {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
      }
      if (ordinal) {
          formatTokenFunctions[ordinal] = function () {
              return this.localeData().ordinal(
                  func.apply(this, arguments),
                  token
              );
          };
      }
  }

  function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, '');
      }
      return input.replace(/\\/g, '');
  }

  function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;

      for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
          } else {
              array[i] = removeFormattingTokens(array[i]);
          }
      }

      return function (mom) {
          var output = '',
              i;
          for (i = 0; i < length; i++) {
              output += isFunction(array[i])
                  ? array[i].call(mom, format)
                  : array[i];
          }
          return output;
      };
  }

  // format date using native date object
  function formatMoment(m, format) {
      if (!m.isValid()) {
          return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] =
          formatFunctions[format] || makeFormatFunction(format);

      return formatFunctions[format](m);
  }

  function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
          return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format)) {
          format = format.replace(
              localFormattingTokens,
              replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
      }

      return format;
  }

  var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A',
  };

  function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
          return format;
      }

      this._longDateFormat[key] = formatUpper
          .match(formattingTokens)
          .map(function (tok) {
              if (
                  tok === 'MMMM' ||
                  tok === 'MM' ||
                  tok === 'DD' ||
                  tok === 'dddd'
              ) {
                  return tok.slice(1);
              }
              return tok;
          })
          .join('');

      return this._longDateFormat[key];
  }

  var defaultInvalidDate = 'Invalid date';

  function invalidDate() {
      return this._invalidDate;
  }

  var defaultOrdinal = '%d',
      defaultDayOfMonthOrdinalParse = /\d{1,2}/;

  function ordinal(number) {
      return this._ordinal.replace('%d', number);
  }

  var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      w: 'a week',
      ww: '%d weeks',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years',
  };

  function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output)
          ? output(number, withoutSuffix, string, isFuture)
          : output.replace(/%d/i, number);
  }

  function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }

  var aliases = {};

  function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }

  function normalizeUnits(units) {
      return typeof units === 'string'
          ? aliases[units] || aliases[units.toLowerCase()]
          : undefined;
  }

  function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                  normalizedInput[normalizedProp] = inputObject[prop];
              }
          }
      }

      return normalizedInput;
  }

  var priorities = {};

  function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
  }

  function getPrioritizedUnits(unitsObj) {
      var units = [],
          u;
      for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
              units.push({ unit: u, priority: priorities[u] });
          }
      }
      units.sort(function (a, b) {
          return a.priority - b.priority;
      });
      return units;
  }

  function isLeapYear(year) {
      return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
  }

  function absFloor(number) {
      if (number < 0) {
          // -0 -> 0
          return Math.ceil(number) || 0;
      } else {
          return Math.floor(number);
      }
  }

  function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
      }

      return value;
  }

  function makeGetSet(unit, keepTime) {
      return function (value) {
          if (value != null) {
              set$1(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
          } else {
              return get(this, unit);
          }
      };
  }

  function get(mom, unit) {
      return mom.isValid()
          ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
          : NaN;
  }

  function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
          if (
              unit === 'FullYear' &&
              isLeapYear(mom.year()) &&
              mom.month() === 1 &&
              mom.date() === 29
          ) {
              value = toInt(value);
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                  value,
                  mom.month(),
                  daysInMonth(value, mom.month())
              );
          } else {
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
          }
      }
  }

  // MOMENTS

  function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
          return this[units]();
      }
      return this;
  }

  function stringSet(units, value) {
      if (typeof units === 'object') {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units),
              i;
          for (i = 0; i < prioritized.length; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
          }
      } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
              return this[units](value);
          }
      }
      return this;
  }

  var match1 = /\d/, //       0 - 9
      match2 = /\d\d/, //      00 - 99
      match3 = /\d{3}/, //     000 - 999
      match4 = /\d{4}/, //    0000 - 9999
      match6 = /[+-]?\d{6}/, // -999999 - 999999
      match1to2 = /\d\d?/, //       0 - 99
      match3to4 = /\d\d\d\d?/, //     999 - 9999
      match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
      match1to3 = /\d{1,3}/, //       0 - 999
      match1to4 = /\d{1,4}/, //       0 - 9999
      match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
      matchUnsigned = /\d+/, //       0 - inf
      matchSigned = /[+-]?\d+/, //    -inf - inf
      matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
      matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
      matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
      // any word (or two) characters or numbers including two/three word month in arabic.
      // includes scottish gaelic two word and hyphenated months
      matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
      regexes;

  regexes = {};

  function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex)
          ? regex
          : function (isStrict, localeData) {
                return isStrict && strictRegex ? strictRegex : regex;
            };
  }

  function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
          return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
  }

  // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
  function unescapeFormat(s) {
      return regexEscape(
          s
              .replace('\\', '')
              .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                  matched,
                  p1,
                  p2,
                  p3,
                  p4
              ) {
                  return p1 || p2 || p3 || p4;
              })
      );
  }

  function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }

  var tokens = {};

  function addParseToken(token, callback) {
      var i,
          func = callback;
      if (typeof token === 'string') {
          token = [token];
      }
      if (isNumber(callback)) {
          func = function (input, array) {
              array[callback] = toInt(input);
          };
      }
      for (i = 0; i < token.length; i++) {
          tokens[token[i]] = func;
      }
  }

  function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
          config._w = config._w || {};
          callback(input, config._w, config, token);
      });
  }

  function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
          tokens[token](input, config._a, config, token);
      }
  }

  var YEAR = 0,
      MONTH = 1,
      DATE = 2,
      HOUR = 3,
      MINUTE = 4,
      SECOND = 5,
      MILLISECOND = 6,
      WEEK = 7,
      WEEKDAY = 8;

  function mod(n, x) {
      return ((n % x) + x) % x;
  }

  var indexOf;

  if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
  } else {
      indexOf = function (o) {
          // I know
          var i;
          for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                  return i;
              }
          }
          return -1;
      };
  }

  function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
          return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1
          ? isLeapYear(year)
              ? 29
              : 28
          : 31 - ((modMonth % 7) % 2);
  }

  // FORMATTING

  addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
  });

  addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
  });

  addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
  });

  // ALIASES

  addUnitAlias('month', 'M');

  // PRIORITY

  addUnitPriority('month', 8);

  // PARSING

  addRegexToken('M', match1to2);
  addRegexToken('MM', match1to2, match2);
  addRegexToken('MMM', function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
  });
  addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
  });

  addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
  });

  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict);
      // if we didn't find a month name, mark the date as invalid.
      if (month != null) {
          array[MONTH] = month;
      } else {
          getParsingFlags(config).invalidMonth = input;
      }
  });

  // LOCALES

  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
          '_'
      ),
      defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
          '_'
      ),
      MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
      defaultMonthsShortRegex = matchWord,
      defaultMonthsRegex = matchWord;

  function localeMonths(m, format) {
      if (!m) {
          return isArray(this._months)
              ? this._months
              : this._months['standalone'];
      }
      return isArray(this._months)
          ? this._months[m.month()]
          : this._months[
                (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                    ? 'format'
                    : 'standalone'
            ][m.month()];
  }

  function localeMonthsShort(m, format) {
      if (!m) {
          return isArray(this._monthsShort)
              ? this._monthsShort
              : this._monthsShort['standalone'];
      }
      return isArray(this._monthsShort)
          ? this._monthsShort[m.month()]
          : this._monthsShort[
                MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
            ][m.month()];
  }

  function handleStrictParse(monthName, format, strict) {
      var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
          // this is not used
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
              mom = createUTC([2000, i]);
              this._shortMonthsParse[i] = this.monthsShort(
                  mom,
                  ''
              ).toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
          }
      }

      if (strict) {
          if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
          } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
          }
      } else {
          if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
          } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
          }
      }
  }

  function localeMonthsParse(monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
      }

      // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse
      for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, i]);
          if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp(
                  '^' + this.months(mom, '').replace('.', '') + '$',
                  'i'
              );
              this._shortMonthsParse[i] = new RegExp(
                  '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                  'i'
              );
          }
          if (!strict && !this._monthsParse[i]) {
              regex =
                  '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
              this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          // test the regex
          if (
              strict &&
              format === 'MMMM' &&
              this._longMonthsParse[i].test(monthName)
          ) {
              return i;
          } else if (
              strict &&
              format === 'MMM' &&
              this._shortMonthsParse[i].test(monthName)
          ) {
              return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
          }
      }
  }

  // MOMENTS

  function setMonth(mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
          // No op
          return mom;
      }

      if (typeof value === 'string') {
          if (/^\d+$/.test(value)) {
              value = toInt(value);
          } else {
              value = mom.localeData().monthsParse(value);
              // TODO: Another silent failure?
              if (!isNumber(value)) {
                  return mom;
              }
          }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
      return mom;
  }

  function getSetMonth(value) {
      if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
      } else {
          return get(this, 'Month');
      }
  }

  function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
  }

  function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
          }
          if (isStrict) {
              return this._monthsShortStrictRegex;
          } else {
              return this._monthsShortRegex;
          }
      } else {
          if (!hasOwnProp(this, '_monthsShortRegex')) {
              this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict
              ? this._monthsShortStrictRegex
              : this._monthsShortRegex;
      }
  }

  function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
          }
          if (isStrict) {
              return this._monthsStrictRegex;
          } else {
              return this._monthsRegex;
          }
      } else {
          if (!hasOwnProp(this, '_monthsRegex')) {
              this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict
              ? this._monthsStrictRegex
              : this._monthsRegex;
      }
  }

  function computeMonthsParse() {
      function cmpLenRev(a, b) {
          return b.length - a.length;
      }

      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;
      for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, i]);
          shortPieces.push(this.monthsShort(mom, ''));
          longPieces.push(this.months(mom, ''));
          mixedPieces.push(this.months(mom, ''));
          mixedPieces.push(this.monthsShort(mom, ''));
      }
      // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
      }
      for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
          '^(' + longPieces.join('|') + ')',
          'i'
      );
      this._monthsShortStrictRegex = new RegExp(
          '^(' + shortPieces.join('|') + ')',
          'i'
      );
  }

  // FORMATTING

  addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? zeroFill(y, 4) : '+' + y;
  });

  addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
  });

  addFormatToken(0, ['YYYY', 4], 0, 'year');
  addFormatToken(0, ['YYYYY', 5], 0, 'year');
  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

  // ALIASES

  addUnitAlias('year', 'y');

  // PRIORITIES

  addUnitPriority('year', 1);

  // PARSING

  addRegexToken('Y', matchSigned);
  addRegexToken('YY', match1to2, match2);
  addRegexToken('YYYY', match1to4, match4);
  addRegexToken('YYYYY', match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);

  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
  addParseToken('YYYY', function (input, array) {
      array[YEAR] =
          input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
  });

  // HELPERS

  function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
  }

  // HOOKS

  hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };

  // MOMENTS

  var getSetYear = makeGetSet('FullYear', true);

  function getIsLeapYear() {
      return isLeapYear(this.year());
  }

  function createDate(y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date;
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
          }
      } else {
          date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
  }

  function createUTCDate(y) {
      var date, args;
      // the Date.UTC function remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          // preserve leap years using a full 400 year cycle, then reset
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
          }
      } else {
          date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
  }

  // start-of-first-week - start-of-year
  function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
          fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
          fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

      return -fwdlw + fwd - 1;
  }

  // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;

      if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
      } else {
          resYear = year;
          resDayOfYear = dayOfYear;
      }

      return {
          year: resYear,
          dayOfYear: resDayOfYear,
      };
  }

  function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;

      if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
      } else {
          resYear = mom.year();
          resWeek = week;
      }

      return {
          week: resWeek,
          year: resYear,
      };
  }

  function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }

  // FORMATTING

  addFormatToken('w', ['ww', 2], 'wo', 'week');
  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

  // ALIASES

  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W');

  // PRIORITIES

  addUnitPriority('week', 5);
  addUnitPriority('isoWeek', 5);

  // PARSING

  addRegexToken('w', match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W', match1to2);
  addRegexToken('WW', match1to2, match2);

  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
      input,
      week,
      config,
      token
  ) {
      week[token.substr(0, 1)] = toInt(input);
  });

  // HELPERS

  // LOCALES

  function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }

  var defaultLocaleWeek = {
      dow: 0, // Sunday is the first day of the week.
      doy: 6, // The week that contains Jan 6th is the first week of the year.
  };

  function localeFirstDayOfWeek() {
      return this._week.dow;
  }

  function localeFirstDayOfYear() {
      return this._week.doy;
  }

  // MOMENTS

  function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
  }

  function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
  }

  // FORMATTING

  addFormatToken('d', 0, 'do', 'day');

  addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
  });

  addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
  });

  addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
  });

  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday');

  // ALIASES

  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E');

  // PRIORITY
  addUnitPriority('day', 11);
  addUnitPriority('weekday', 11);
  addUnitPriority('isoWeekday', 11);

  // PARSING

  addRegexToken('d', match1to2);
  addRegexToken('e', match1to2);
  addRegexToken('E', match1to2);
  addRegexToken('dd', function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken('ddd', function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken('dddd', function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
  });

  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict);
      // if we didn't get a weekday name, mark the date as invalid
      if (weekday != null) {
          week.d = weekday;
      } else {
          getParsingFlags(config).invalidWeekday = input;
      }
  });

  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
  });

  // HELPERS

  function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
          return input;
      }

      if (!isNaN(input)) {
          return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);
      if (typeof input === 'number') {
          return input;
      }

      return null;
  }

  function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
          return locale.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
  }

  // LOCALES
  function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
  }

  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
          '_'
      ),
      defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      defaultWeekdaysRegex = matchWord,
      defaultWeekdaysShortRegex = matchWord,
      defaultWeekdaysMinRegex = matchWord;

  function localeWeekdays(m, format) {
      var weekdays = isArray(this._weekdays)
          ? this._weekdays
          : this._weekdays[
                m && m !== true && this._weekdays.isFormat.test(format)
                    ? 'format'
                    : 'standalone'
            ];
      return m === true
          ? shiftWeekdays(weekdays, this._week.dow)
          : m
          ? weekdays[m.day()]
          : weekdays;
  }

  function localeWeekdaysShort(m) {
      return m === true
          ? shiftWeekdays(this._weekdaysShort, this._week.dow)
          : m
          ? this._weekdaysShort[m.day()]
          : this._weekdaysShort;
  }

  function localeWeekdaysMin(m) {
      return m === true
          ? shiftWeekdays(this._weekdaysMin, this._week.dow)
          : m
          ? this._weekdaysMin[m.day()]
          : this._weekdaysMin;
  }

  function handleStrictParse$1(weekdayName, format, strict) {
      var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];

          for (i = 0; i < 7; ++i) {
              mom = createUTC([2000, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(
                  mom,
                  ''
              ).toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(
                  mom,
                  ''
              ).toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
          }
      }

      if (strict) {
          if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
          } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
          }
      } else {
          if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
          } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
          }
      }
  }

  function localeWeekdaysParse(weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already

          mom = createUTC([2000, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp(
                  '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                  'i'
              );
              this._shortWeekdaysParse[i] = new RegExp(
                  '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                  'i'
              );
              this._minWeekdaysParse[i] = new RegExp(
                  '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                  'i'
              );
          }
          if (!this._weekdaysParse[i]) {
              regex =
                  '^' +
                  this.weekdays(mom, '') +
                  '|^' +
                  this.weekdaysShort(mom, '') +
                  '|^' +
                  this.weekdaysMin(mom, '');
              this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          // test the regex
          if (
              strict &&
              format === 'dddd' &&
              this._fullWeekdaysParse[i].test(weekdayName)
          ) {
              return i;
          } else if (
              strict &&
              format === 'ddd' &&
              this._shortWeekdaysParse[i].test(weekdayName)
          ) {
              return i;
          } else if (
              strict &&
              format === 'dd' &&
              this._minWeekdaysParse[i].test(weekdayName)
          ) {
              return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
          }
      }
  }

  // MOMENTS

  function getSetDayOfWeek(input) {
      if (!this.isValid()) {
          return input != null ? this : NaN;
      }
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, 'd');
      } else {
          return day;
      }
  }

  function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
          return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
  }

  function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
          return input != null ? this : NaN;
      }

      // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.

      if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
          return this.day() || 7;
      }
  }

  function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
          }
          if (isStrict) {
              return this._weekdaysStrictRegex;
          } else {
              return this._weekdaysRegex;
          }
      } else {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
              this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict
              ? this._weekdaysStrictRegex
              : this._weekdaysRegex;
      }
  }

  function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
          }
          if (isStrict) {
              return this._weekdaysShortStrictRegex;
          } else {
              return this._weekdaysShortRegex;
          }
      } else {
          if (!hasOwnProp(this, '_weekdaysShortRegex')) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict
              ? this._weekdaysShortStrictRegex
              : this._weekdaysShortRegex;
      }
  }

  function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
          }
          if (isStrict) {
              return this._weekdaysMinStrictRegex;
          } else {
              return this._weekdaysMinRegex;
          }
      } else {
          if (!hasOwnProp(this, '_weekdaysMinRegex')) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict
              ? this._weekdaysMinStrictRegex
              : this._weekdaysMinRegex;
      }
  }

  function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
          return b.length - a.length;
      }

      var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;
      for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ''));
          shortp = regexEscape(this.weekdaysShort(mom, ''));
          longp = regexEscape(this.weekdays(mom, ''));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
      }
      // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;

      this._weekdaysStrictRegex = new RegExp(
          '^(' + longPieces.join('|') + ')',
          'i'
      );
      this._weekdaysShortStrictRegex = new RegExp(
          '^(' + shortPieces.join('|') + ')',
          'i'
      );
      this._weekdaysMinStrictRegex = new RegExp(
          '^(' + minPieces.join('|') + ')',
          'i'
      );
  }

  // FORMATTING

  function hFormat() {
      return this.hours() % 12 || 12;
  }

  function kFormat() {
      return this.hours() || 24;
  }

  addFormatToken('H', ['HH', 2], 0, 'hour');
  addFormatToken('h', ['hh', 2], 0, hFormat);
  addFormatToken('k', ['kk', 2], 0, kFormat);

  addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });

  addFormatToken('hmmss', 0, 0, function () {
      return (
          '' +
          hFormat.apply(this) +
          zeroFill(this.minutes(), 2) +
          zeroFill(this.seconds(), 2)
      );
  });

  addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
  });

  addFormatToken('Hmmss', 0, 0, function () {
      return (
          '' +
          this.hours() +
          zeroFill(this.minutes(), 2) +
          zeroFill(this.seconds(), 2)
      );
  });

  function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
          return this.localeData().meridiem(
              this.hours(),
              this.minutes(),
              lowercase
          );
      });
  }

  meridiem('a', true);
  meridiem('A', false);

  // ALIASES

  addUnitAlias('hour', 'h');

  // PRIORITY
  addUnitPriority('hour', 13);

  // PARSING

  function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
  }

  addRegexToken('a', matchMeridiem);
  addRegexToken('A', matchMeridiem);
  addRegexToken('H', match1to2);
  addRegexToken('h', match1to2);
  addRegexToken('k', match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addRegexToken('kk', match1to2, match2);

  addRegexToken('hmm', match3to4);
  addRegexToken('hmmss', match5to6);
  addRegexToken('Hmm', match3to4);
  addRegexToken('Hmmss', match5to6);

  addParseToken(['H', 'HH'], HOUR);
  addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
  });
  addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4,
          pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
  });
  addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4,
          pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
  });

  // LOCALES

  function localeIsPM(input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return (input + '').toLowerCase().charAt(0) === 'p';
  }

  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
      // Setting the hour should keep the time, because the user explicitly
      // specified which hour they want. So trying to maintain the same hour (in
      // a new timezone) makes sense. Adding/subtracting hours does not follow
      // this rule.
      getSetHour = makeGetSet('Hours', true);

  function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
          return isLower ? 'pm' : 'PM';
      } else {
          return isLower ? 'am' : 'AM';
      }
  }

  var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,

      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,

      week: defaultLocaleWeek,

      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,

      meridiemParse: defaultLocaleMeridiemParse,
  };

  // internal storage for locale config files
  var locales = {},
      localeFamilies = {},
      globalLocale;

  function commonPrefix(arr1, arr2) {
      var i,
          minl = Math.min(arr1.length, arr2.length);
      for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
              return i;
          }
      }
      return minl;
  }

  function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
  }

  // pick the locale from the array
  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
  function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;

      while (i < names.length) {
          split = normalizeLocale(names[i]).split('-');
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split('-') : null;
          while (j > 0) {
              locale = loadLocale(split.slice(0, j).join('-'));
              if (locale) {
                  return locale;
              }
              if (
                  next &&
                  next.length >= j &&
                  commonPrefix(split, next) >= j - 1
              ) {
                  //the next array item is better than a shallower substring of this one
                  break;
              }
              j--;
          }
          i++;
      }
      return globalLocale;
  }

  function loadLocale(name) {
      var oldLocale = null,
          aliasedRequire;
      // TODO: Find a better way to register and load all the locales in Node
      if (
          locales[name] === undefined &&
          typeof module !== 'undefined' &&
          module &&
          module.exports
      ) {
          try {
              oldLocale = globalLocale._abbr;
              aliasedRequire = require;
              aliasedRequire('./locale/' + name);
              getSetGlobalLocale(oldLocale);
          } catch (e) {
              // mark as not found to avoid repeating expensive file require call causing high CPU
              // when trying to find en-US, en_US, en-us for every format call
              locales[name] = null; // null means not found
          }
      }
      return locales[name];
  }

  // This function will load locale and then set the global locale.  If
  // no arguments are passed in, it will simply return the current global
  // locale key.
  function getSetGlobalLocale(key, values) {
      var data;
      if (key) {
          if (isUndefined(values)) {
              data = getLocale(key);
          } else {
              data = defineLocale(key, values);
          }

          if (data) {
              // moment.duration._locale = moment._locale = data;
              globalLocale = data;
          } else {
              if (typeof console !== 'undefined' && console.warn) {
                  //warn user if arguments are passed but the locale could not be set
                  console.warn(
                      'Locale ' + key + ' not found. Did you forget to load it?'
                  );
              }
          }
      }

      return globalLocale._abbr;
  }

  function defineLocale(name, config) {
      if (config !== null) {
          var locale,
              parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
              deprecateSimple(
                  'defineLocaleOverride',
                  'use moment.updateLocale(localeName, config) to change ' +
                      'an existing locale. moment.defineLocale(localeName, ' +
                      'config) should only be used for creating a new locale ' +
                      'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
              );
              parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                  parentConfig = locales[config.parentLocale]._config;
              } else {
                  locale = loadLocale(config.parentLocale);
                  if (locale != null) {
                      parentConfig = locale._config;
                  } else {
                      if (!localeFamilies[config.parentLocale]) {
                          localeFamilies[config.parentLocale] = [];
                      }
                      localeFamilies[config.parentLocale].push({
                          name: name,
                          config: config,
                      });
                      return null;
                  }
              }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));

          if (localeFamilies[name]) {
              localeFamilies[name].forEach(function (x) {
                  defineLocale(x.name, x.config);
              });
          }

          // backwards compat for now: also set the locale
          // make sure we set the locale AFTER all child locales have been
          // created, so we won't end up with the child locale set.
          getSetGlobalLocale(name);

          return locales[name];
      } else {
          // useful for testing
          delete locales[name];
          return null;
      }
  }

  function updateLocale(name, config) {
      if (config != null) {
          var locale,
              tmpLocale,
              parentConfig = baseConfig;

          if (locales[name] != null && locales[name].parentLocale != null) {
              // Update existing child locale in-place to avoid memory-leaks
              locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
              // MERGE
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                  parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              if (tmpLocale == null) {
                  // updateLocale is called for creating a new locale
                  // Set abbr so it will have a name (getters return
                  // undefined otherwise).
                  config.abbr = name;
              }
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;
          }

          // backwards compat for now: also set the locale
          getSetGlobalLocale(name);
      } else {
          // pass null for config to unupdate, useful for tests
          if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                  locales[name] = locales[name].parentLocale;
                  if (name === getSetGlobalLocale()) {
                      getSetGlobalLocale(name);
                  }
              } else if (locales[name] != null) {
                  delete locales[name];
              }
          }
      }
      return locales[name];
  }

  // returns locale data
  function getLocale(key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
      }

      if (!key) {
          return globalLocale;
      }

      if (!isArray(key)) {
          //short-circuit everything else
          locale = loadLocale(key);
          if (locale) {
              return locale;
          }
          key = [key];
      }

      return chooseLocale(key);
  }

  function listLocales() {
      return keys(locales);
  }

  function checkOverflow(m) {
      var overflow,
          a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
          overflow =
              a[MONTH] < 0 || a[MONTH] > 11
                  ? MONTH
                  : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                  ? DATE
                  : a[HOUR] < 0 ||
                    a[HOUR] > 24 ||
                    (a[HOUR] === 24 &&
                        (a[MINUTE] !== 0 ||
                            a[SECOND] !== 0 ||
                            a[MILLISECOND] !== 0))
                  ? HOUR
                  : a[MINUTE] < 0 || a[MINUTE] > 59
                  ? MINUTE
                  : a[SECOND] < 0 || a[SECOND] > 59
                  ? SECOND
                  : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                  ? MILLISECOND
                  : -1;

          if (
              getParsingFlags(m)._overflowDayOfYear &&
              (overflow < YEAR || overflow > DATE)
          ) {
              overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
          }

          getParsingFlags(m).overflow = overflow;
      }

      return m;
  }

  // iso 8601 regex
  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
      basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
      tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
      isoDates = [
          ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
          ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
          ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
          ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
          ['YYYY-DDD', /\d{4}-\d{3}/],
          ['YYYY-MM', /\d{4}-\d\d/, false],
          ['YYYYYYMMDD', /[+-]\d{10}/],
          ['YYYYMMDD', /\d{8}/],
          ['GGGG[W]WWE', /\d{4}W\d{3}/],
          ['GGGG[W]WW', /\d{4}W\d{2}/, false],
          ['YYYYDDD', /\d{7}/],
          ['YYYYMM', /\d{6}/, false],
          ['YYYY', /\d{4}/, false],
      ],
      // iso time formats and regexes
      isoTimes = [
          ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
          ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
          ['HH:mm:ss', /\d\d:\d\d:\d\d/],
          ['HH:mm', /\d\d:\d\d/],
          ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
          ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
          ['HHmmss', /\d\d\d\d\d\d/],
          ['HHmm', /\d\d\d\d/],
          ['HH', /\d\d/],
      ],
      aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
      // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
      rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
      obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60,
      };

  // date from iso format
  function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;

      if (match) {
          getParsingFlags(config).iso = true;

          for (i = 0, l = isoDates.length; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                  dateFormat = isoDates[i][0];
                  allowTime = isoDates[i][2] !== false;
                  break;
              }
          }
          if (dateFormat == null) {
              config._isValid = false;
              return;
          }
          if (match[3]) {
              for (i = 0, l = isoTimes.length; i < l; i++) {
                  if (isoTimes[i][1].exec(match[3])) {
                      // match[2] should be 'T' or space
                      timeFormat = (match[2] || ' ') + isoTimes[i][0];
                      break;
                  }
              }
              if (timeFormat == null) {
                  config._isValid = false;
                  return;
              }
          }
          if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
          }
          if (match[4]) {
              if (tzRegex.exec(match[4])) {
                  tzFormat = 'Z';
              } else {
                  config._isValid = false;
                  return;
              }
          }
          config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
          configFromStringAndFormat(config);
      } else {
          config._isValid = false;
      }
  }

  function extractFromRFC2822Strings(
      yearStr,
      monthStr,
      dayStr,
      hourStr,
      minuteStr,
      secondStr
  ) {
      var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10),
      ];

      if (secondStr) {
          result.push(parseInt(secondStr, 10));
      }

      return result;
  }

  function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
          return 2000 + year;
      } else if (year <= 999) {
          return 1900 + year;
      }
      return year;
  }

  function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s
          .replace(/\([^)]*\)|[\n\t]/g, ' ')
          .replace(/(\s\s+)/g, ' ')
          .replace(/^\s\s*/, '')
          .replace(/\s\s*$/, '');
  }

  function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
          // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
              weekdayActual = new Date(
                  parsedInput[0],
                  parsedInput[1],
                  parsedInput[2]
              ).getDay();
          if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
          }
      }
      return true;
  }

  function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
          return obsOffsets[obsOffset];
      } else if (militaryOffset) {
          // the only allowed military tz is Z
          return 0;
      } else {
          var hm = parseInt(numOffset, 10),
              m = hm % 100,
              h = (hm - m) / 100;
          return h * 60 + m;
      }
  }

  // date and time from ref 2822 format
  function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i)),
          parsedArray;
      if (match) {
          parsedArray = extractFromRFC2822Strings(
              match[4],
              match[3],
              match[2],
              match[5],
              match[6],
              match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
              return;
          }

          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);

          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

          getParsingFlags(config).rfc2822 = true;
      } else {
          config._isValid = false;
      }
  }

  // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
  function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
      }

      configFromISO(config);
      if (config._isValid === false) {
          delete config._isValid;
      } else {
          return;
      }

      configFromRFC2822(config);
      if (config._isValid === false) {
          delete config._isValid;
      } else {
          return;
      }

      if (config._strict) {
          config._isValid = false;
      } else {
          // Final attempt, use Input Fallback
          hooks.createFromInputFallback(config);
      }
  }

  hooks.createFromInputFallback = deprecate(
      'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
          'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
          'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
      function (config) {
          config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
      }
  );

  // Pick the first defined of two or three arguments.
  function defaults(a, b, c) {
      if (a != null) {
          return a;
      }
      if (b != null) {
          return b;
      }
      return c;
  }

  function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
          return [
              nowValue.getUTCFullYear(),
              nowValue.getUTCMonth(),
              nowValue.getUTCDate(),
          ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }

  // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]
  function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;

      if (config._d) {
          return;
      }

      currentDate = currentDateArray(config);

      //compute day of the year from weeks and weekdays
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
      }

      //if the day of the year is set, figure out what it is
      if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

          if (
              config._dayOfYear > daysInYear(yearToUse) ||
              config._dayOfYear === 0
          ) {
              getParsingFlags(config)._overflowDayOfYear = true;
          }

          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
      }

      // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
      }

      // Zero out whatever was not defaulted, including time
      for (; i < 7; i++) {
          config._a[i] = input[i] =
              config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
      }

      // Check for 24:00:00.000
      if (
          config._a[HOUR] === 24 &&
          config._a[MINUTE] === 0 &&
          config._a[SECOND] === 0 &&
          config._a[MILLISECOND] === 0
      ) {
          config._nextDay = true;
          config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
      );
      expectedWeekday = config._useUTC
          ? config._d.getUTCDay()
          : config._d.getDay();

      // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.
      if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
          config._a[HOUR] = 24;
      }

      // check for mismatching day of week
      if (
          config._w &&
          typeof config._w.d !== 'undefined' &&
          config._w.d !== expectedWeekday
      ) {
          getParsingFlags(config).weekdayMismatch = true;
      }
  }

  function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;

          // TODO: We need to take the current isoWeekYear, but that depends on
          // how we interpret now (local, utc, fixed offset). So create
          // a now version of current config (take local/utc/offset flags, and
          // create now).
          weekYear = defaults(
              w.GG,
              config._a[YEAR],
              weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
          }
      } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;

          curWeek = weekOfYear(createLocal(), dow, doy);

          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

          // Default to current week.
          week = defaults(w.w, curWeek.week);

          if (w.d != null) {
              // weekday -- low day numbers are considered next week
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                  weekdayOverflow = true;
              }
          } else if (w.e != null) {
              // local weekday -- counting starts from beginning of week
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                  weekdayOverflow = true;
              }
          } else {
              // default to beginning of week
              weekday = dow;
          }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
      } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
      }
  }

  // constant that refers to the ISO standard
  hooks.ISO_8601 = function () {};

  // constant that refers to the RFC 2822 form
  hooks.RFC_2822 = function () {};

  // date from string and format string
  function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
      }
      if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;

      // This array is used to make a Date, either with `new Date` or `Date.UTC`
      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0,
          era;

      tokens =
          expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          parsedInput = (string.match(getParseRegexForToken(token, config)) ||
              [])[0];
          if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                  getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(
                  string.indexOf(parsedInput) + parsedInput.length
              );
              totalParsedInputLength += parsedInput.length;
          }
          // don't parse if it's not a known token
          if (formatTokenFunctions[token]) {
              if (parsedInput) {
                  getParsingFlags(config).empty = false;
              } else {
                  getParsingFlags(config).unusedTokens.push(token);
              }
              addTimeToArrayFromToken(token, parsedInput, config);
          } else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token);
          }
      }

      // add remaining unparsed input length to the string
      getParsingFlags(config).charsLeftOver =
          stringLength - totalParsedInputLength;
      if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
      }

      // clear _12h flag if hour is <= 12
      if (
          config._a[HOUR] <= 12 &&
          getParsingFlags(config).bigHour === true &&
          config._a[HOUR] > 0
      ) {
          getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      // handle meridiem
      config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
      );

      // handle era
      era = getParsingFlags(config).era;
      if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }

      configFromArray(config);
      checkOverflow(config);
  }

  function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
          // nothing to do
          return hour;
      }
      if (locale.meridiemHour != null) {
          return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
          // Fallback
          isPm = locale.isPM(meridiem);
          if (isPm && hour < 12) {
              hour += 12;
          }
          if (!isPm && hour === 12) {
              hour = 0;
          }
          return hour;
      } else {
          // this is not supposed to happen
          return hour;
      }
  }

  // date from string and array of format strings
  function configFromStringAndArray(config) {
      var tempConfig,
          bestMoment,
          scoreToBeat,
          i,
          currentScore,
          validFormatFound,
          bestFormatIsValid = false;

      if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
      }

      for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);

          if (isValid(tempConfig)) {
              validFormatFound = true;
          }

          // if there is any input that was not parsed add a penalty for that format
          currentScore += getParsingFlags(tempConfig).charsLeftOver;

          //or tokens
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

          getParsingFlags(tempConfig).score = currentScore;

          if (!bestFormatIsValid) {
              if (
                  scoreToBeat == null ||
                  currentScore < scoreToBeat ||
                  validFormatFound
              ) {
                  scoreToBeat = currentScore;
                  bestMoment = tempConfig;
                  if (validFormatFound) {
                      bestFormatIsValid = true;
                  }
              }
          } else {
              if (currentScore < scoreToBeat) {
                  scoreToBeat = currentScore;
                  bestMoment = tempConfig;
              }
          }
      }

      extend(config, bestMoment || tempConfig);
  }

  function configFromObject(config) {
      if (config._d) {
          return;
      }

      var i = normalizeObjectUnits(config._i),
          dayOrDate = i.day === undefined ? i.date : i.day;
      config._a = map(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function (obj) {
              return obj && parseInt(obj, 10);
          }
      );

      configFromArray(config);
  }

  function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
          // Adding is smart enough around DST
          res.add(1, 'd');
          res._nextDay = undefined;
      }

      return res;
  }

  function prepareConfig(config) {
      var input = config._i,
          format = config._f;

      config._locale = config._locale || getLocale(config._l);

      if (input === null || (format === undefined && input === '')) {
          return createInvalid({ nullInput: true });
      }

      if (typeof input === 'string') {
          config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
          return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
          config._d = input;
      } else if (isArray(format)) {
          configFromStringAndArray(config);
      } else if (format) {
          configFromStringAndFormat(config);
      } else {
          configFromInput(config);
      }

      if (!isValid(config)) {
          config._d = null;
      }

      return config;
  }

  function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
          config._d = new Date(hooks.now());
      } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
          configFromString(config);
      } else if (isArray(input)) {
          config._a = map(input.slice(0), function (obj) {
              return parseInt(obj, 10);
          });
          configFromArray(config);
      } else if (isObject(input)) {
          configFromObject(config);
      } else if (isNumber(input)) {
          // from milliseconds
          config._d = new Date(input);
      } else {
          hooks.createFromInputFallback(config);
      }
  }

  function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};

      if (format === true || format === false) {
          strict = format;
          format = undefined;
      }

      if (locale === true || locale === false) {
          strict = locale;
          locale = undefined;
      }

      if (
          (isObject(input) && isObjectEmpty(input)) ||
          (isArray(input) && input.length === 0)
      ) {
          input = undefined;
      }
      // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;

      return createFromConfig(c);
  }

  function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
  }

  var prototypeMin = deprecate(
          'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
          function () {
              var other = createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other < this ? this : other;
              } else {
                  return createInvalid();
              }
          }
      ),
      prototypeMax = deprecate(
          'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
          function () {
              var other = createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other > this ? this : other;
              } else {
                  return createInvalid();
              }
          }
      );

  // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.
  function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
      }
      if (!moments.length) {
          return createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
          }
      }
      return res;
  }

  // TODO: Use [].sort instead?
  function min() {
      var args = [].slice.call(arguments, 0);

      return pickBy('isBefore', args);
  }

  function max() {
      var args = [].slice.call(arguments, 0);

      return pickBy('isAfter', args);
  }

  var now = function () {
      return Date.now ? Date.now() : +new Date();
  };

  var ordering = [
      'year',
      'quarter',
      'month',
      'week',
      'day',
      'hour',
      'minute',
      'second',
      'millisecond',
  ];

  function isDurationValid(m) {
      var key,
          unitHasDecimal = false,
          i;
      for (key in m) {
          if (
              hasOwnProp(m, key) &&
              !(
                  indexOf.call(ordering, key) !== -1 &&
                  (m[key] == null || !isNaN(m[key]))
              )
          ) {
              return false;
          }
      }

      for (i = 0; i < ordering.length; ++i) {
          if (m[ordering[i]]) {
              if (unitHasDecimal) {
                  return false; // only allow non-integers for smallest unit
              }
              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                  unitHasDecimal = true;
              }
          }
      }

      return true;
  }

  function isValid$1() {
      return this._isValid;
  }

  function createInvalid$1() {
      return createDuration(NaN);
  }

  function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;

      this._isValid = isDurationValid(normalizedInput);

      // representation for dateAddRemove
      this._milliseconds =
          +milliseconds +
          seconds * 1e3 + // 1000
          minutes * 6e4 + // 1000 * 60
          hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately
      this._days = +days + weeks * 7;
      // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.
      this._months = +months + quarters * 3 + years * 12;

      this._data = {};

      this._locale = getLocale();

      this._bubble();
  }

  function isDuration(obj) {
      return obj instanceof Duration;
  }

  function absRound(number) {
      if (number < 0) {
          return Math.round(-1 * number) * -1;
      } else {
          return Math.round(number);
      }
  }

  // compare two arrays, return the number of differences
  function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;
      for (i = 0; i < len; i++) {
          if (
              (dontConvert && array1[i] !== array2[i]) ||
              (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
          ) {
              diffs++;
          }
      }
      return diffs + lengthDiff;
  }

  // FORMATTING

  function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
          var offset = this.utcOffset(),
              sign = '+';
          if (offset < 0) {
              offset = -offset;
              sign = '-';
          }
          return (
              sign +
              zeroFill(~~(offset / 60), 2) +
              separator +
              zeroFill(~~offset % 60, 2)
          );
      });
  }

  offset('Z', ':');
  offset('ZZ', '');

  // PARSING

  addRegexToken('Z', matchShortOffset);
  addRegexToken('ZZ', matchShortOffset);
  addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
  });

  // HELPERS

  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']
  var chunkOffset = /([\+\-]|\d\d)/gi;

  function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher),
          chunk,
          parts,
          minutes;

      if (matches === null) {
          return null;
      }

      chunk = matches[matches.length - 1] || [];
      parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      minutes = +(parts[1] * 60) + toInt(parts[2]);

      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
  }

  // Return a moment from input, that is local/utc/zone equivalent to model.
  function cloneWithOffset(input, model) {
      var res, diff;
      if (model._isUTC) {
          res = model.clone();
          diff =
              (isMoment(input) || isDate(input)
                  ? input.valueOf()
                  : createLocal(input).valueOf()) - res.valueOf();
          // Use low-level api, because this fn is low-level api.
          res._d.setTime(res._d.valueOf() + diff);
          hooks.updateOffset(res, false);
          return res;
      } else {
          return createLocal(input).local();
      }
  }

  function getDateOffset(m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset());
  }

  // HOOKS

  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.
  hooks.updateOffset = function () {};

  // MOMENTS

  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.
  function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;
      if (!this.isValid()) {
          return input != null ? this : NaN;
      }
      if (input != null) {
          if (typeof input === 'string') {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                  return this;
              }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
              this.add(localAdjust, 'm');
          }
          if (offset !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                  addSubtract(
                      this,
                      createDuration(input - offset, 'm'),
                      1,
                      false
                  );
              } else if (!this._changeInProgress) {
                  this._changeInProgress = true;
                  hooks.updateOffset(this, true);
                  this._changeInProgress = null;
              }
          }
          return this;
      } else {
          return this._isUTC ? offset : getDateOffset(this);
      }
  }

  function getSetZone(input, keepLocalTime) {
      if (input != null) {
          if (typeof input !== 'string') {
              input = -input;
          }

          this.utcOffset(input, keepLocalTime);

          return this;
      } else {
          return -this.utcOffset();
      }
  }

  function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
  }

  function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;

          if (keepLocalTime) {
              this.subtract(getDateOffset(this), 'm');
          }
      }
      return this;
  }

  function setOffsetToParsedOffset() {
      if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
              this.utcOffset(tZone);
          } else {
              this.utcOffset(0, true);
          }
      }
      return this;
  }

  function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
          return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;

      return (this.utcOffset() - input) % 60 === 0;
  }

  function isDaylightSavingTime() {
      return (
          this.utcOffset() > this.clone().month(0).utcOffset() ||
          this.utcOffset() > this.clone().month(5).utcOffset()
      );
  }

  function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
      }

      var c = {},
          other;

      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted =
              this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
          this._isDSTShifted = false;
      }

      return this._isDSTShifted;
  }

  function isLocal() {
      return this.isValid() ? !this._isUTC : false;
  }

  function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
  }

  function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }

  // ASP.NET json date format regex
  var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
      // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
      // and further modified to allow for strings containing both week and day
      isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

  function createDuration(input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
          match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
          duration = {
              ms: input._milliseconds,
              d: input._days,
              M: input._months,
          };
      } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
              duration[key] = +input;
          } else {
              duration.milliseconds = +input;
          }
      } else if ((match = aspNetRegex.exec(input))) {
          sign = match[1] === '-' ? -1 : 1;
          duration = {
              y: 0,
              d: toInt(match[DATE]) * sign,
              h: toInt(match[HOUR]) * sign,
              m: toInt(match[MINUTE]) * sign,
              s: toInt(match[SECOND]) * sign,
              ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
          };
      } else if ((match = isoRegex.exec(input))) {
          sign = match[1] === '-' ? -1 : 1;
          duration = {
              y: parseIso(match[2], sign),
              M: parseIso(match[3], sign),
              w: parseIso(match[4], sign),
              d: parseIso(match[5], sign),
              h: parseIso(match[6], sign),
              m: parseIso(match[7], sign),
              s: parseIso(match[8], sign),
          };
      } else if (duration == null) {
          // checks for null or undefined
          duration = {};
      } else if (
          typeof duration === 'object' &&
          ('from' in duration || 'to' in duration)
      ) {
          diffRes = momentsDifference(
              createLocal(duration.from),
              createLocal(duration.to)
          );

          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
          ret._locale = input._locale;
      }

      if (isDuration(input) && hasOwnProp(input, '_isValid')) {
          ret._isValid = input._isValid;
      }

      return ret;
  }

  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;

  function parseIso(inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.'));
      // apply sign while we're at it
      return (isNaN(res) ? 0 : res) * sign;
  }

  function positiveMomentsDifference(base, other) {
      var res = {};

      res.months =
          other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, 'M').isAfter(other)) {
          --res.months;
      }

      res.milliseconds = +other - +base.clone().add(res.months, 'M');

      return res;
  }

  function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
      }

      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
      } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
      }

      return res;
  }

  // TODO: remove 'name' arg after deprecation is removed
  function createAdder(direction, name) {
      return function (val, period) {
          var dur, tmp;
          //invert the arguments, but complain about it
          if (period !== null && !isNaN(+period)) {
              deprecateSimple(
                  name,
                  'moment().' +
                      name +
                      '(period, number) is deprecated. Please use moment().' +
                      name +
                      '(number, period). ' +
                      'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
              );
              tmp = val;
              val = period;
              period = tmp;
          }

          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
      };
  }

  function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
          // No op
          return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
          setMonth(mom, get(mom, 'Month') + months * isAdding);
      }
      if (days) {
          set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
      }
      if (milliseconds) {
          mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }
      if (updateOffset) {
          hooks.updateOffset(mom, days || months);
      }
  }

  var add = createAdder(1, 'add'),
      subtract = createAdder(-1, 'subtract');

  function isString(input) {
      return typeof input === 'string' || input instanceof String;
  }

  // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
  function isMomentInput(input) {
      return (
          isMoment(input) ||
          isDate(input) ||
          isString(input) ||
          isNumber(input) ||
          isNumberOrStringArray(input) ||
          isMomentInputObject(input) ||
          input === null ||
          input === undefined
      );
  }

  function isMomentInputObject(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input),
          propertyTest = false,
          properties = [
              'years',
              'year',
              'y',
              'months',
              'month',
              'M',
              'days',
              'day',
              'd',
              'dates',
              'date',
              'D',
              'hours',
              'hour',
              'h',
              'minutes',
              'minute',
              'm',
              'seconds',
              'second',
              's',
              'milliseconds',
              'millisecond',
              'ms',
          ],
          i,
          property;

      for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
      }

      return objectTest && propertyTest;
  }

  function isNumberOrStringArray(input) {
      var arrayTest = isArray(input),
          dataTypeTest = false;
      if (arrayTest) {
          dataTypeTest =
              input.filter(function (item) {
                  return !isNumber(item) && isString(input);
              }).length === 0;
      }
      return arrayTest && dataTypeTest;
  }

  function isCalendarSpec(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input),
          propertyTest = false,
          properties = [
              'sameDay',
              'nextDay',
              'lastDay',
              'nextWeek',
              'lastWeek',
              'sameElse',
          ],
          i,
          property;

      for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
      }

      return objectTest && propertyTest;
  }

  function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6
          ? 'sameElse'
          : diff < -1
          ? 'lastWeek'
          : diff < 0
          ? 'lastDay'
          : diff < 1
          ? 'sameDay'
          : diff < 2
          ? 'nextDay'
          : diff < 7
          ? 'nextWeek'
          : 'sameElse';
  }

  function calendar$1(time, formats) {
      // Support for single parameter, formats only overload to the calendar function
      if (arguments.length === 1) {
          if (!arguments[0]) {
              time = undefined;
              formats = undefined;
          } else if (isMomentInput(arguments[0])) {
              time = arguments[0];
              formats = undefined;
          } else if (isCalendarSpec(arguments[0])) {
              formats = arguments[0];
              time = undefined;
          }
      }
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse',
          output =
              formats &&
              (isFunction(formats[format])
                  ? formats[format].call(this, now)
                  : formats[format]);

      return this.format(
          output || this.localeData().calendar(format, this, createLocal(now))
      );
  }

  function clone() {
      return new Moment(this);
  }

  function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
          return false;
      }
      units = normalizeUnits(units) || 'millisecond';
      if (units === 'millisecond') {
          return this.valueOf() > localInput.valueOf();
      } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
  }

  function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
          return false;
      }
      units = normalizeUnits(units) || 'millisecond';
      if (units === 'millisecond') {
          return this.valueOf() < localInput.valueOf();
      } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
  }

  function isBetween(from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
      }
      inclusivity = inclusivity || '()';
      return (
          (inclusivity[0] === '('
              ? this.isAfter(localFrom, units)
              : !this.isBefore(localFrom, units)) &&
          (inclusivity[1] === ')'
              ? this.isBefore(localTo, units)
              : !this.isAfter(localTo, units))
      );
  }

  function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;
      if (!(this.isValid() && localInput.isValid())) {
          return false;
      }
      units = normalizeUnits(units) || 'millisecond';
      if (units === 'millisecond') {
          return this.valueOf() === localInput.valueOf();
      } else {
          inputMs = localInput.valueOf();
          return (
              this.clone().startOf(units).valueOf() <= inputMs &&
              inputMs <= this.clone().endOf(units).valueOf()
          );
      }
  }

  function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
  }

  function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
  }

  function diff(input, units, asFloat) {
      var that, zoneDelta, output;

      if (!this.isValid()) {
          return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
          return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

      units = normalizeUnits(units);

      switch (units) {
          case 'year':
              output = monthDiff(this, that) / 12;
              break;
          case 'month':
              output = monthDiff(this, that);
              break;
          case 'quarter':
              output = monthDiff(this, that) / 3;
              break;
          case 'second':
              output = (this - that) / 1e3;
              break; // 1000
          case 'minute':
              output = (this - that) / 6e4;
              break; // 1000 * 60
          case 'hour':
              output = (this - that) / 36e5;
              break; // 1000 * 60 * 60
          case 'day':
              output = (this - that - zoneDelta) / 864e5;
              break; // 1000 * 60 * 60 * 24, negate dst
          case 'week':
              output = (this - that - zoneDelta) / 6048e5;
              break; // 1000 * 60 * 60 * 24 * 7, negate dst
          default:
              output = this - that;
      }

      return asFloat ? output : absFloor(output);
  }

  function monthDiff(a, b) {
      if (a.date() < b.date()) {
          // end-of-month calculations work correct when the start month has more
          // days than the end month.
          return -monthDiff(b, a);
      }
      // difference in months
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
          anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;

      if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
          // linear across the month
          adjust = (b - anchor) / (anchor - anchor2);
      } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
          // linear across the month
          adjust = (b - anchor) / (anchor2 - anchor);
      }

      //check for negative zero, return zero if negative zero
      return -(wholeMonthDiff + adjust) || 0;
  }

  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

  function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }

  function toISOString(keepOffset) {
      if (!this.isValid()) {
          return null;
      }
      var utc = keepOffset !== true,
          m = utc ? this.clone().utc() : this;
      if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
              m,
              utc
                  ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                  : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
          );
      }
      if (isFunction(Date.prototype.toISOString)) {
          // native implementation is ~50x faster, use it when we can
          if (utc) {
              return this.toDate().toISOString();
          } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                  .toISOString()
                  .replace('Z', formatMoment(m, 'Z'));
          }
      }
      return formatMoment(
          m,
          utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
      );
  }

  /**
   * Return a human readable representation of a moment that can
   * also be evaluated to get a new moment which is the same
   *
   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
   */
  function inspect() {
      if (!this.isValid()) {
          return 'moment.invalid(/* ' + this._i + ' */)';
      }
      var func = 'moment',
          zone = '',
          prefix,
          year,
          datetime,
          suffix;
      if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
          zone = 'Z';
      }
      prefix = '[' + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
      datetime = '-MM-DD[T]HH:mm:ss.SSS';
      suffix = zone + '[")]';

      return this.format(prefix + year + datetime + suffix);
  }

  function format(inputString) {
      if (!inputString) {
          inputString = this.isUtc()
              ? hooks.defaultFormatUtc
              : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
  }

  function from(time, withoutSuffix) {
      if (
          this.isValid() &&
          ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
      ) {
          return createDuration({ to: this, from: time })
              .locale(this.locale())
              .humanize(!withoutSuffix);
      } else {
          return this.localeData().invalidDate();
      }
  }

  function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
  }

  function to(time, withoutSuffix) {
      if (
          this.isValid() &&
          ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
      ) {
          return createDuration({ from: this, to: time })
              .locale(this.locale())
              .humanize(!withoutSuffix);
      } else {
          return this.localeData().invalidDate();
      }
  }

  function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
  }

  // If passed a locale key, it will set the locale for this
  // instance.  Otherwise, it will return the locale configuration
  // variables for this instance.
  function locale(key) {
      var newLocaleData;

      if (key === undefined) {
          return this._locale._abbr;
      } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
              this._locale = newLocaleData;
          }
          return this;
      }
  }

  var lang = deprecate(
      'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
      function (key) {
          if (key === undefined) {
              return this.localeData();
          } else {
              return this.locale(key);
          }
      }
  );

  function localeData() {
      return this._locale;
  }

  var MS_PER_SECOND = 1000,
      MS_PER_MINUTE = 60 * MS_PER_SECOND,
      MS_PER_HOUR = 60 * MS_PER_MINUTE,
      MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

  // actual modulo - handles negative numbers (for dates before 1970):
  function mod$1(dividend, divisor) {
      return ((dividend % divisor) + divisor) % divisor;
  }

  function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
          return new Date(y, m, d).valueOf();
      }
  }

  function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
          return Date.UTC(y, m, d);
      }
  }

  function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === undefined || units === 'millisecond' || !this.isValid()) {
          return this;
      }

      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
          case 'year':
              time = startOfDate(this.year(), 0, 1);
              break;
          case 'quarter':
              time = startOfDate(
                  this.year(),
                  this.month() - (this.month() % 3),
                  1
              );
              break;
          case 'month':
              time = startOfDate(this.year(), this.month(), 1);
              break;
          case 'week':
              time = startOfDate(
                  this.year(),
                  this.month(),
                  this.date() - this.weekday()
              );
              break;
          case 'isoWeek':
              time = startOfDate(
                  this.year(),
                  this.month(),
                  this.date() - (this.isoWeekday() - 1)
              );
              break;
          case 'day':
          case 'date':
              time = startOfDate(this.year(), this.month(), this.date());
              break;
          case 'hour':
              time = this._d.valueOf();
              time -= mod$1(
                  time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                  MS_PER_HOUR
              );
              break;
          case 'minute':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
          case 'second':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
      }

      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
  }

  function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === undefined || units === 'millisecond' || !this.isValid()) {
          return this;
      }

      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
          case 'year':
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
          case 'quarter':
              time =
                  startOfDate(
                      this.year(),
                      this.month() - (this.month() % 3) + 3,
                      1
                  ) - 1;
              break;
          case 'month':
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
          case 'week':
              time =
                  startOfDate(
                      this.year(),
                      this.month(),
                      this.date() - this.weekday() + 7
                  ) - 1;
              break;
          case 'isoWeek':
              time =
                  startOfDate(
                      this.year(),
                      this.month(),
                      this.date() - (this.isoWeekday() - 1) + 7
                  ) - 1;
              break;
          case 'day':
          case 'date':
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
          case 'hour':
              time = this._d.valueOf();
              time +=
                  MS_PER_HOUR -
                  mod$1(
                      time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                      MS_PER_HOUR
                  ) -
                  1;
              break;
          case 'minute':
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
          case 'second':
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
      }

      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
  }

  function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
  }

  function unix() {
      return Math.floor(this.valueOf() / 1000);
  }

  function toDate() {
      return new Date(this.valueOf());
  }

  function toArray() {
      var m = this;
      return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond(),
      ];
  }

  function toObject() {
      var m = this;
      return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds(),
      };
  }

  function toJSON() {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
  }

  function isValid$2() {
      return isValid(this);
  }

  function parsingFlags() {
      return extend({}, getParsingFlags(this));
  }

  function invalidAt() {
      return getParsingFlags(this).overflow;
  }

  function creationData() {
      return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict,
      };
  }

  addFormatToken('N', 0, 0, 'eraAbbr');
  addFormatToken('NN', 0, 0, 'eraAbbr');
  addFormatToken('NNN', 0, 0, 'eraAbbr');
  addFormatToken('NNNN', 0, 0, 'eraName');
  addFormatToken('NNNNN', 0, 0, 'eraNarrow');

  addFormatToken('y', ['y', 1], 'yo', 'eraYear');
  addFormatToken('y', ['yy', 2], 0, 'eraYear');
  addFormatToken('y', ['yyy', 3], 0, 'eraYear');
  addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

  addRegexToken('N', matchEraAbbr);
  addRegexToken('NN', matchEraAbbr);
  addRegexToken('NNN', matchEraAbbr);
  addRegexToken('NNNN', matchEraName);
  addRegexToken('NNNNN', matchEraNarrow);

  addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
      input,
      array,
      config,
      token
  ) {
      var era = config._locale.erasParse(input, token, config._strict);
      if (era) {
          getParsingFlags(config).era = era;
      } else {
          getParsingFlags(config).invalidEra = input;
      }
  });

  addRegexToken('y', matchUnsigned);
  addRegexToken('yy', matchUnsigned);
  addRegexToken('yyy', matchUnsigned);
  addRegexToken('yyyy', matchUnsigned);
  addRegexToken('yo', matchEraYearOrdinal);

  addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
  addParseToken(['yo'], function (input, array, config, token) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
      }

      if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
          array[YEAR] = parseInt(input, 10);
      }
  });

  function localeEras(m, format) {
      var i,
          l,
          date,
          eras = this._eras || getLocale('en')._eras;
      for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
              case 'string':
                  // truncate time
                  date = hooks(eras[i].since).startOf('day');
                  eras[i].since = date.valueOf();
                  break;
          }

          switch (typeof eras[i].until) {
              case 'undefined':
                  eras[i].until = +Infinity;
                  break;
              case 'string':
                  // truncate time
                  date = hooks(eras[i].until).startOf('day').valueOf();
                  eras[i].until = date.valueOf();
                  break;
          }
      }
      return eras;
  }

  function localeErasParse(eraName, format, strict) {
      var i,
          l,
          eras = this.eras(),
          name,
          abbr,
          narrow;
      eraName = eraName.toUpperCase();

      for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();

          if (strict) {
              switch (format) {
                  case 'N':
                  case 'NN':
                  case 'NNN':
                      if (abbr === eraName) {
                          return eras[i];
                      }
                      break;

                  case 'NNNN':
                      if (name === eraName) {
                          return eras[i];
                      }
                      break;

                  case 'NNNNN':
                      if (narrow === eraName) {
                          return eras[i];
                      }
                      break;
              }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
              return eras[i];
          }
      }
  }

  function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? +1 : -1;
      if (year === undefined) {
          return hooks(era.since).year();
      } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
      }
  }

  function getEraName() {
      var i,
          l,
          val,
          eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
          // truncate time
          val = this.clone().startOf('day').valueOf();

          if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].name;
          }
      }

      return '';
  }

  function getEraNarrow() {
      var i,
          l,
          val,
          eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
          // truncate time
          val = this.clone().startOf('day').valueOf();

          if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].narrow;
          }
      }

      return '';
  }

  function getEraAbbr() {
      var i,
          l,
          val,
          eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
          // truncate time
          val = this.clone().startOf('day').valueOf();

          if (eras[i].since <= val && val <= eras[i].until) {
              return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
              return eras[i].abbr;
          }
      }

      return '';
  }

  function getEraYear() {
      var i,
          l,
          dir,
          val,
          eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? +1 : -1;

          // truncate time
          val = this.clone().startOf('day').valueOf();

          if (
              (eras[i].since <= val && val <= eras[i].until) ||
              (eras[i].until <= val && val <= eras[i].since)
          ) {
              return (
                  (this.year() - hooks(eras[i].since).year()) * dir +
                  eras[i].offset
              );
          }
      }

      return this.year();
  }

  function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, '_erasNameRegex')) {
          computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
  }

  function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, '_erasAbbrRegex')) {
          computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
  }

  function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, '_erasNarrowRegex')) {
          computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
  }

  function matchEraAbbr(isStrict, locale) {
      return locale.erasAbbrRegex(isStrict);
  }

  function matchEraName(isStrict, locale) {
      return locale.erasNameRegex(isStrict);
  }

  function matchEraNarrow(isStrict, locale) {
      return locale.erasNarrowRegex(isStrict);
  }

  function matchEraYearOrdinal(isStrict, locale) {
      return locale._eraYearOrdinalRegex || matchUnsigned;
  }

  function computeErasParse() {
      var abbrPieces = [],
          namePieces = [],
          narrowPieces = [],
          mixedPieces = [],
          i,
          l,
          eras = this.eras();

      for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));

          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
      }

      this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
      this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
      this._erasNarrowRegex = new RegExp(
          '^(' + narrowPieces.join('|') + ')',
          'i'
      );
  }

  // FORMATTING

  addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
  });

  addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
  });

  function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
  }

  addWeekYearFormatToken('gggg', 'weekYear');
  addWeekYearFormatToken('ggggg', 'weekYear');
  addWeekYearFormatToken('GGGG', 'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear');

  // ALIASES

  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG');

  // PRIORITY

  addUnitPriority('weekYear', 1);
  addUnitPriority('isoWeekYear', 1);

  // PARSING

  addRegexToken('G', matchSigned);
  addRegexToken('g', matchSigned);
  addRegexToken('GG', match1to2, match2);
  addRegexToken('gg', match1to2, match2);
  addRegexToken('GGGG', match1to4, match4);
  addRegexToken('gggg', match1to4, match4);
  addRegexToken('GGGGG', match1to6, match6);
  addRegexToken('ggggg', match1to6, match6);

  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
      input,
      week,
      config,
      token
  ) {
      week[token.substr(0, 2)] = toInt(input);
  });

  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
  });

  // MOMENTS

  function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
      );
  }

  function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
      );
  }

  function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
  }

  function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
  }

  function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }

  function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
  }

  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
          return weekOfYear(this, dow, doy).year;
      } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
              week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
  }

  function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
  }

  // FORMATTING

  addFormatToken('Q', 0, 'Qo', 'quarter');

  // ALIASES

  addUnitAlias('quarter', 'Q');

  // PRIORITY

  addUnitPriority('quarter', 7);

  // PARSING

  addRegexToken('Q', match1);
  addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
  });

  // MOMENTS

  function getSetQuarter(input) {
      return input == null
          ? Math.ceil((this.month() + 1) / 3)
          : this.month((input - 1) * 3 + (this.month() % 3));
  }

  // FORMATTING

  addFormatToken('D', ['DD', 2], 'Do', 'date');

  // ALIASES

  addUnitAlias('date', 'D');

  // PRIORITY
  addUnitPriority('date', 9);

  // PARSING

  addRegexToken('D', match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict
          ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
          : locale._dayOfMonthOrdinalParseLenient;
  });

  addParseToken(['D', 'DD'], DATE);
  addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
  });

  // MOMENTS

  var getSetDayOfMonth = makeGetSet('Date', true);

  // FORMATTING

  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

  // ALIASES

  addUnitAlias('dayOfYear', 'DDD');

  // PRIORITY
  addUnitPriority('dayOfYear', 4);

  // PARSING

  addRegexToken('DDD', match1to3);
  addRegexToken('DDDD', match3);
  addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
  });

  // HELPERS

  // MOMENTS

  function getSetDayOfYear(input) {
      var dayOfYear =
          Math.round(
              (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
          ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
  }

  // FORMATTING

  addFormatToken('m', ['mm', 2], 0, 'minute');

  // ALIASES

  addUnitAlias('minute', 'm');

  // PRIORITY

  addUnitPriority('minute', 14);

  // PARSING

  addRegexToken('m', match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken(['m', 'mm'], MINUTE);

  // MOMENTS

  var getSetMinute = makeGetSet('Minutes', false);

  // FORMATTING

  addFormatToken('s', ['ss', 2], 0, 'second');

  // ALIASES

  addUnitAlias('second', 's');

  // PRIORITY

  addUnitPriority('second', 15);

  // PARSING

  addRegexToken('s', match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken(['s', 'ss'], SECOND);

  // MOMENTS

  var getSetSecond = makeGetSet('Seconds', false);

  // FORMATTING

  addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
  });

  addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
  });

  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
  addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
  });
  addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
  });
  addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
  });
  addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
  });
  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
  });
  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
  });

  // ALIASES

  addUnitAlias('millisecond', 'ms');

  // PRIORITY

  addUnitPriority('millisecond', 16);

  // PARSING

  addRegexToken('S', match1to3, match1);
  addRegexToken('SS', match1to3, match2);
  addRegexToken('SSS', match1to3, match3);

  var token, getSetMillisecond;
  for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
  }

  function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
  }

  for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
  }

  getSetMillisecond = makeGetSet('Milliseconds', false);

  // FORMATTING

  addFormatToken('z', 0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName');

  // MOMENTS

  function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
  }

  function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
  }

  var proto = Moment.prototype;

  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;
  if (typeof Symbol !== 'undefined' && Symbol.for != null) {
      proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
          return 'Moment<' + this.format() + '>';
      };
  }
  proto.toJSON = toJSON;
  proto.toString = toString;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.eraName = getEraName;
  proto.eraNarrow = getEraNarrow;
  proto.eraAbbr = getEraAbbr;
  proto.eraYear = getEraYear;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.weeksInWeekYear = getWeeksInWeekYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate(
      'dates accessor is deprecated. Use date instead.',
      getSetDayOfMonth
  );
  proto.months = deprecate(
      'months accessor is deprecated. Use month instead',
      getSetMonth
  );
  proto.years = deprecate(
      'years accessor is deprecated. Use year instead',
      getSetYear
  );
  proto.zone = deprecate(
      'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
      getSetZone
  );
  proto.isDSTShifted = deprecate(
      'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
      isDaylightSavingTimeShifted
  );

  function createUnix(input) {
      return createLocal(input * 1000);
  }

  function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
  }

  function preParsePostFormat(string) {
      return string;
  }

  var proto$1 = Locale.prototype;

  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set;
  proto$1.eras = localeEras;
  proto$1.erasParse = localeErasParse;
  proto$1.erasConvertYear = localeErasConvertYear;
  proto$1.erasAbbrRegex = erasAbbrRegex;
  proto$1.erasNameRegex = erasNameRegex;
  proto$1.erasNarrowRegex = erasNarrowRegex;

  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;

  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;

  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;

  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;

  function get$1(format, index, field, setter) {
      var locale = getLocale(),
          utc = createUTC().set(setter, index);
      return locale[field](utc, format);
  }

  function listMonthsImpl(format, index, field) {
      if (isNumber(format)) {
          index = format;
          format = undefined;
      }

      format = format || '';

      if (index != null) {
          return get$1(format, index, field, 'month');
      }

      var i,
          out = [];
      for (i = 0; i < 12; i++) {
          out[i] = get$1(format, i, field, 'month');
      }
      return out;
  }

  // ()
  // (5)
  // (fmt, 5)
  // (fmt)
  // (true)
  // (true, 5)
  // (true, fmt, 5)
  // (true, fmt)
  function listWeekdaysImpl(localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
          if (isNumber(format)) {
              index = format;
              format = undefined;
          }

          format = format || '';
      } else {
          format = localeSorted;
          index = format;
          localeSorted = false;

          if (isNumber(format)) {
              index = format;
              format = undefined;
          }

          format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0,
          i,
          out = [];

      if (index != null) {
          return get$1(format, (index + shift) % 7, field, 'day');
      }

      for (i = 0; i < 7; i++) {
          out[i] = get$1(format, (i + shift) % 7, field, 'day');
      }
      return out;
  }

  function listMonths(format, index) {
      return listMonthsImpl(format, index, 'months');
  }

  function listMonthsShort(format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
  }

  function listWeekdays(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
  }

  function listWeekdaysShort(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
  }

  function listWeekdaysMin(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
  }

  getSetGlobalLocale('en', {
      eras: [
          {
              since: '0001-01-01',
              until: +Infinity,
              offset: 1,
              name: 'Anno Domini',
              narrow: 'AD',
              abbr: 'AD',
          },
          {
              since: '0000-12-31',
              until: -Infinity,
              offset: 1,
              name: 'Before Christ',
              narrow: 'BC',
              abbr: 'BC',
          },
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  toInt((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
  });

  // Side effect imports

  hooks.lang = deprecate(
      'moment.lang is deprecated. Use moment.locale instead.',
      getSetGlobalLocale
  );
  hooks.langData = deprecate(
      'moment.langData is deprecated. Use moment.localeData instead.',
      getLocale
  );

  var mathAbs = Math.abs;

  function abs() {
      var data = this._data;

      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);

      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);

      return this;
  }

  function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);

      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;

      return duration._bubble();
  }

  // supports only 2.0-style add(1, 's') or add(duration)
  function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
  }

  // supports only 2.0-style subtract(1, 's') or subtract(duration)
  function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
  }

  function absCeil(number) {
      if (number < 0) {
          return Math.floor(number);
      } else {
          return Math.ceil(number);
      }
  }

  function bubble() {
      var milliseconds = this._milliseconds,
          days = this._days,
          months = this._months,
          data = this._data,
          seconds,
          minutes,
          hours,
          years,
          monthsFromDays;

      // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166
      if (
          !(
              (milliseconds >= 0 && days >= 0 && months >= 0) ||
              (milliseconds <= 0 && days <= 0 && months <= 0)
          )
      ) {
          milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
          days = 0;
          months = 0;
      }

      // The following code bubbles up values, see the tests for
      // examples of what that means.
      data.milliseconds = milliseconds % 1000;

      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;

      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;

      hours = absFloor(minutes / 60);
      data.hours = hours % 24;

      days += absFloor(hours / 24);

      // convert days to months
      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays));

      // 12 months -> 1 year
      years = absFloor(months / 12);
      months %= 12;

      data.days = days;
      data.months = months;
      data.years = years;

      return this;
  }

  function daysToMonths(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return (days * 4800) / 146097;
  }

  function monthsToDays(months) {
      // the reverse of daysToMonths
      return (months * 146097) / 4800;
  }

  function as(units) {
      if (!this.isValid()) {
          return NaN;
      }
      var days,
          months,
          milliseconds = this._milliseconds;

      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
          days = this._days + milliseconds / 864e5;
          months = this._months + daysToMonths(days);
          switch (units) {
              case 'month':
                  return months;
              case 'quarter':
                  return months / 3;
              case 'year':
                  return months / 12;
          }
      } else {
          // handle milliseconds separately because of floating point math errors (issue #1867)
          days = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
              case 'week':
                  return days / 7 + milliseconds / 6048e5;
              case 'day':
                  return days + milliseconds / 864e5;
              case 'hour':
                  return days * 24 + milliseconds / 36e5;
              case 'minute':
                  return days * 1440 + milliseconds / 6e4;
              case 'second':
                  return days * 86400 + milliseconds / 1000;
              // Math.floor prevents floating point math errors here
              case 'millisecond':
                  return Math.floor(days * 864e5) + milliseconds;
              default:
                  throw new Error('Unknown unit ' + units);
          }
      }
  }

  // TODO: Use this.as('ms')?
  function valueOf$1() {
      if (!this.isValid()) {
          return NaN;
      }
      return (
          this._milliseconds +
          this._days * 864e5 +
          (this._months % 12) * 2592e6 +
          toInt(this._months / 12) * 31536e6
      );
  }

  function makeAs(alias) {
      return function () {
          return this.as(alias);
      };
  }

  var asMilliseconds = makeAs('ms'),
      asSeconds = makeAs('s'),
      asMinutes = makeAs('m'),
      asHours = makeAs('h'),
      asDays = makeAs('d'),
      asWeeks = makeAs('w'),
      asMonths = makeAs('M'),
      asQuarters = makeAs('Q'),
      asYears = makeAs('y');

  function clone$1() {
      return createDuration(this);
  }

  function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
  }

  function makeGetter(name) {
      return function () {
          return this.isValid() ? this._data[name] : NaN;
      };
  }

  var milliseconds = makeGetter('milliseconds'),
      seconds = makeGetter('seconds'),
      minutes = makeGetter('minutes'),
      hours = makeGetter('hours'),
      days = makeGetter('days'),
      months = makeGetter('months'),
      years = makeGetter('years');

  function weeks() {
      return absFloor(this.days() / 7);
  }

  var round = Math.round,
      thresholds = {
          ss: 44, // a few seconds to seconds
          s: 45, // seconds to minute
          m: 45, // minutes to hour
          h: 22, // hours to day
          d: 26, // days to month/week
          w: null, // weeks to month
          M: 11, // months to year
      };

  // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }

  function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
      var duration = createDuration(posNegDuration).abs(),
          seconds = round(duration.as('s')),
          minutes = round(duration.as('m')),
          hours = round(duration.as('h')),
          days = round(duration.as('d')),
          months = round(duration.as('M')),
          weeks = round(duration.as('w')),
          years = round(duration.as('y')),
          a =
              (seconds <= thresholds.ss && ['s', seconds]) ||
              (seconds < thresholds.s && ['ss', seconds]) ||
              (minutes <= 1 && ['m']) ||
              (minutes < thresholds.m && ['mm', minutes]) ||
              (hours <= 1 && ['h']) ||
              (hours < thresholds.h && ['hh', hours]) ||
              (days <= 1 && ['d']) ||
              (days < thresholds.d && ['dd', days]);

      if (thresholds.w != null) {
          a =
              a ||
              (weeks <= 1 && ['w']) ||
              (weeks < thresholds.w && ['ww', weeks]);
      }
      a = a ||
          (months <= 1 && ['M']) ||
          (months < thresholds.M && ['MM', months]) ||
          (years <= 1 && ['y']) || ['yy', years];

      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
  }

  // This function allows you to set the rounding function for relative time strings
  function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
          return round;
      }
      if (typeof roundingFunction === 'function') {
          round = roundingFunction;
          return true;
      }
      return false;
  }

  // This function allows you to set a threshold for relative time strings
  function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
          return false;
      }
      if (limit === undefined) {
          return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === 's') {
          thresholds.ss = limit - 1;
      }
      return true;
  }

  function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
          return this.localeData().invalidDate();
      }

      var withSuffix = false,
          th = thresholds,
          locale,
          output;

      if (typeof argWithSuffix === 'object') {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
      }
      if (typeof argWithSuffix === 'boolean') {
          withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === 'object') {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
              th.ss = argThresholds.s - 1;
          }
      }

      locale = this.localeData();
      output = relativeTime$1(this, !withSuffix, th, locale);

      if (withSuffix) {
          output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
  }

  var abs$1 = Math.abs;

  function sign(x) {
      return (x > 0) - (x < 0) || +x;
  }

  function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
          return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000,
          days = abs$1(this._days),
          months = abs$1(this._months),
          minutes,
          hours,
          years,
          s,
          total = this.asSeconds(),
          totalSign,
          ymSign,
          daysSign,
          hmsSign;

      if (!total) {
          // this is the same as C#'s (Noda) and python (isodate)...
          // but not other JS (goog.date)
          return 'P0D';
      }

      // 3600 seconds -> 60 minutes -> 1 hour
      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60;

      // 12 months -> 1 year
      years = absFloor(months / 12);
      months %= 12;

      // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
      s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

      totalSign = total < 0 ? '-' : '';
      ymSign = sign(this._months) !== sign(total) ? '-' : '';
      daysSign = sign(this._days) !== sign(total) ? '-' : '';
      hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

      return (
          totalSign +
          'P' +
          (years ? ymSign + years + 'Y' : '') +
          (months ? ymSign + months + 'M' : '') +
          (days ? daysSign + days + 'D' : '') +
          (hours || minutes || seconds ? 'T' : '') +
          (hours ? hmsSign + hours + 'H' : '') +
          (minutes ? hmsSign + minutes + 'M' : '') +
          (seconds ? hmsSign + s + 'S' : '')
      );
  }

  var proto$2 = Duration.prototype;

  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asQuarters = asQuarters;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;

  proto$2.toIsoString = deprecate(
      'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
      toISOString$1
  );
  proto$2.lang = lang;

  // FORMATTING

  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf');

  // PARSING

  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input) * 1000);
  });
  addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
  });

  //! moment.js

  hooks.version = '2.29.1';

  setHookCallback(createLocal);

  hooks.fn = proto;
  hooks.min = min;
  hooks.max = max;
  hooks.now = now;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto;

  // currently HTML5 input type only supports 24-hour formats
  hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD', // <input type="date" />
      TIME: 'HH:mm', // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW', // <input type="week" />
      MONTH: 'YYYY-MM', // <input type="month" />
  };

  //! moment.js locale configuration

  hooks.defineLocale('af', {
      months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
      weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split(
          '_'
      ),
      weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
      weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
      meridiemParse: /vm|nm/i,
      isPM: function (input) {
          return /^nm$/i.test(input);
      },
      meridiem: function (hours, minutes, isLower) {
          if (hours < 12) {
              return isLower ? 'vm' : 'VM';
          } else {
              return isLower ? 'nm' : 'NM';
          }
      },
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Vandag om] LT',
          nextDay: '[Mre om] LT',
          nextWeek: 'dddd [om] LT',
          lastDay: '[Gister om] LT',
          lastWeek: '[Laas] dddd [om] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'oor %s',
          past: '%s gelede',
          s: "'n paar sekondes",
          ss: '%d sekondes',
          m: "'n minuut",
          mm: '%d minute',
          h: "'n uur",
          hh: '%d ure',
          d: "'n dag",
          dd: '%d dae',
          M: "'n maand",
          MM: '%d maande',
          y: "'n jaar",
          yy: '%d jaar',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function (number) {
          return (
              number +
              (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
          ); // Thanks to Joris Rling : https://github.com/jjupiter
      },
      week: {
          dow: 1, // Maandag is die eerste dag van die week.
          doy: 4, // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
      },
  });

  //! moment.js locale configuration

  var pluralForm = function (n) {
          return n === 0
              ? 0
              : n === 1
              ? 1
              : n === 2
              ? 2
              : n % 100 >= 3 && n % 100 <= 10
              ? 3
              : n % 100 >= 11
              ? 4
              : 5;
      },
      plurals = {
          s: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          m: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          h: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          d: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          M: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          y: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
      },
      pluralize = function (u) {
          return function (number, withoutSuffix, string, isFuture) {
              var f = pluralForm(number),
                  str = plurals[u][pluralForm(number)];
              if (f === 2) {
                  str = str[withoutSuffix ? 0 : 1];
              }
              return str.replace(/%d/i, number);
          };
      },
      months$1 = [
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
      ];

  hooks.defineLocale('ar-dz', {
      months: months$1,
      monthsShort: months$1,
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'D/\u200FM/\u200FYYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return '' === input;
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[  ] LT',
          nextDay: '[  ] LT',
          nextWeek: 'dddd [ ] LT',
          lastDay: '[  ] LT',
          lastWeek: 'dddd [ ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: pluralize('s'),
          ss: pluralize('s'),
          m: pluralize('m'),
          mm: pluralize('m'),
          h: pluralize('h'),
          hh: pluralize('h'),
          d: pluralize('d'),
          dd: pluralize('d'),
          M: pluralize('M'),
          MM: pluralize('M'),
          y: pluralize('y'),
          yy: pluralize('y'),
      },
      postformat: function (string) {
          return string.replace(/,/g, '');
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ar-kw', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[  ] LT',
          nextDay: '[  ] LT',
          nextWeek: 'dddd [ ] LT',
          lastDay: '[  ] LT',
          lastWeek: 'dddd [ ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: '',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d ',
          M: '',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 12, // The week that contains Jan 12th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap = {
          1: '1',
          2: '2',
          3: '3',
          4: '4',
          5: '5',
          6: '6',
          7: '7',
          8: '8',
          9: '9',
          0: '0',
      },
      pluralForm$1 = function (n) {
          return n === 0
              ? 0
              : n === 1
              ? 1
              : n === 2
              ? 2
              : n % 100 >= 3 && n % 100 <= 10
              ? 3
              : n % 100 >= 11
              ? 4
              : 5;
      },
      plurals$1 = {
          s: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          m: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          h: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          d: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          M: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          y: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
      },
      pluralize$1 = function (u) {
          return function (number, withoutSuffix, string, isFuture) {
              var f = pluralForm$1(number),
                  str = plurals$1[u][pluralForm$1(number)];
              if (f === 2) {
                  str = str[withoutSuffix ? 0 : 1];
              }
              return str.replace(/%d/i, number);
          };
      },
      months$2 = [
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
      ];

  hooks.defineLocale('ar-ly', {
      months: months$2,
      monthsShort: months$2,
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'D/\u200FM/\u200FYYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return '' === input;
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[  ] LT',
          nextDay: '[  ] LT',
          nextWeek: 'dddd [ ] LT',
          lastDay: '[  ] LT',
          lastWeek: 'dddd [ ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: pluralize$1('s'),
          ss: pluralize$1('s'),
          m: pluralize$1('m'),
          mm: pluralize$1('m'),
          h: pluralize$1('h'),
          hh: pluralize$1('h'),
          d: pluralize$1('d'),
          dd: pluralize$1('d'),
          M: pluralize$1('M'),
          MM: pluralize$1('M'),
          y: pluralize$1('y'),
          yy: pluralize$1('y'),
      },
      preparse: function (string) {
          return string.replace(//g, ',');
      },
      postformat: function (string) {
          return string
              .replace(/\d/g, function (match) {
                  return symbolMap[match];
              })
              .replace(/,/g, '');
      },
      week: {
          dow: 6, // Saturday is the first day of the week.
          doy: 12, // The week that contains Jan 12th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ar-ma', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[  ] LT',
          nextDay: '[  ] LT',
          nextWeek: 'dddd [ ] LT',
          lastDay: '[  ] LT',
          lastWeek: 'dddd [ ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: '',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d ',
          M: '',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$1 = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('ar-sa', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return '' === input;
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[  ] LT',
          nextDay: '[  ] LT',
          nextWeek: 'dddd [ ] LT',
          lastDay: '[  ] LT',
          lastWeek: 'dddd [ ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: '',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d ',
          M: '',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      preparse: function (string) {
          return string
              .replace(/[]/g, function (match) {
                  return numberMap[match];
              })
              .replace(//g, ',');
      },
      postformat: function (string) {
          return string
              .replace(/\d/g, function (match) {
                  return symbolMap$1[match];
              })
              .replace(/,/g, '');
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ar-tn', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[  ] LT',
          nextDay: '[  ] LT',
          nextWeek: 'dddd [ ] LT',
          lastDay: '[  ] LT',
          lastWeek: 'dddd [ ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: '',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d ',
          M: '',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$2 = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$1 = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      },
      pluralForm$2 = function (n) {
          return n === 0
              ? 0
              : n === 1
              ? 1
              : n === 2
              ? 2
              : n % 100 >= 3 && n % 100 <= 10
              ? 3
              : n % 100 >= 11
              ? 4
              : 5;
      },
      plurals$2 = {
          s: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          m: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          h: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          d: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          M: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
          y: [
              '  ',
              ' ',
              ['', ''],
              '%d ',
              '%d ',
              '%d ',
          ],
      },
      pluralize$2 = function (u) {
          return function (number, withoutSuffix, string, isFuture) {
              var f = pluralForm$2(number),
                  str = plurals$2[u][pluralForm$2(number)];
              if (f === 2) {
                  str = str[withoutSuffix ? 0 : 1];
              }
              return str.replace(/%d/i, number);
          };
      },
      months$3 = [
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
      ];

  hooks.defineLocale('ar', {
      months: months$3,
      monthsShort: months$3,
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'D/\u200FM/\u200FYYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return '' === input;
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[  ] LT',
          nextDay: '[  ] LT',
          nextWeek: 'dddd [ ] LT',
          lastDay: '[  ] LT',
          lastWeek: 'dddd [ ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: pluralize$2('s'),
          ss: pluralize$2('s'),
          m: pluralize$2('m'),
          mm: pluralize$2('m'),
          h: pluralize$2('h'),
          hh: pluralize$2('h'),
          d: pluralize$2('d'),
          dd: pluralize$2('d'),
          M: pluralize$2('M'),
          MM: pluralize$2('M'),
          y: pluralize$2('y'),
          yy: pluralize$2('y'),
      },
      preparse: function (string) {
          return string
              .replace(/[]/g, function (match) {
                  return numberMap$1[match];
              })
              .replace(//g, ',');
      },
      postformat: function (string) {
          return string
              .replace(/\d/g, function (match) {
                  return symbolMap$2[match];
              })
              .replace(/,/g, '');
      },
      week: {
          dow: 6, // Saturday is the first day of the week.
          doy: 12, // The week that contains Jan 12th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var suffixes = {
      1: '-inci',
      5: '-inci',
      8: '-inci',
      70: '-inci',
      80: '-inci',
      2: '-nci',
      7: '-nci',
      20: '-nci',
      50: '-nci',
      3: '-nc',
      4: '-nc',
      100: '-nc',
      6: '-nc',
      9: '-uncu',
      10: '-uncu',
      30: '-uncu',
      60: '-nc',
      90: '-nc',
  };

  hooks.defineLocale('az', {
      months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split(
          '_'
      ),
      monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
      weekdays: 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split(
          '_'
      ),
      weekdaysShort: 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
      weekdaysMin: 'Bz_BE_A__CA_C_'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[bugn saat] LT',
          nextDay: '[sabah saat] LT',
          nextWeek: '[gln hft] dddd [saat] LT',
          lastDay: '[dnn] LT',
          lastWeek: '[ken hft] dddd [saat] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s sonra',
          past: '%s vvl',
          s: 'bir ne saniy',
          ss: '%d saniy',
          m: 'bir dqiq',
          mm: '%d dqiq',
          h: 'bir saat',
          hh: '%d saat',
          d: 'bir gn',
          dd: '%d gn',
          M: 'bir ay',
          MM: '%d ay',
          y: 'bir il',
          yy: '%d il',
      },
      meridiemParse: /gec|shr|gndz|axam/,
      isPM: function (input) {
          return /^(gndz|axam)$/.test(input);
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return 'gec';
          } else if (hour < 12) {
              return 'shr';
          } else if (hour < 17) {
              return 'gndz';
          } else {
              return 'axam';
          }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
      ordinal: function (number) {
          if (number === 0) {
              // special case for zero
              return number + '-nc';
          }
          var a = number % 10,
              b = (number % 100) - a,
              c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function plural(word, num) {
      var forms = word.split('_');
      return num % 10 === 1 && num % 100 !== 11
          ? forms[0]
          : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
          ? forms[1]
          : forms[2];
  }
  function relativeTimeWithPlural(number, withoutSuffix, key) {
      var format = {
          ss: withoutSuffix ? '__' : '__',
          mm: withoutSuffix ? '__' : '__',
          hh: withoutSuffix ? '__' : '__',
          dd: '__',
          MM: '__',
          yy: '__',
      };
      if (key === 'm') {
          return withoutSuffix ? '' : '';
      } else if (key === 'h') {
          return withoutSuffix ? '' : '';
      } else {
          return number + ' ' + plural(format[key], +number);
      }
  }

  hooks.defineLocale('be', {
      months: {
          format: '___________'.split(
              '_'
          ),
          standalone: '___________'.split(
              '_'
          ),
      },
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: {
          format: '______'.split(
              '_'
          ),
          standalone: '______'.split(
              '_'
          ),
          isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/,
      },
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY .',
          LLL: 'D MMMM YYYY ., HH:mm',
          LLLL: 'dddd, D MMMM YYYY ., HH:mm',
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          lastDay: '[ ] LT',
          nextWeek: function () {
              return '[] dddd [] LT';
          },
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                  case 3:
                  case 5:
                  case 6:
                      return '[ ] dddd [] LT';
                  case 1:
                  case 2:
                  case 4:
                      return '[ ] dddd [] LT';
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: '%s ',
          s: ' ',
          m: relativeTimeWithPlural,
          mm: relativeTimeWithPlural,
          h: relativeTimeWithPlural,
          hh: relativeTimeWithPlural,
          d: '',
          dd: relativeTimeWithPlural,
          M: '',
          MM: relativeTimeWithPlural,
          y: '',
          yy: relativeTimeWithPlural,
      },
      meridiemParse: /|||/,
      isPM: function (input) {
          return /^(|)$/.test(input);
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 12) {
              return '';
          } else if (hour < 17) {
              return '';
          } else {
              return '';
          }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
      ordinal: function (number, period) {
          switch (period) {
              case 'M':
              case 'd':
              case 'DDD':
              case 'w':
              case 'W':
                  return (number % 10 === 2 || number % 10 === 3) &&
                      number % 100 !== 12 &&
                      number % 100 !== 13
                      ? number + '-'
                      : number + '-';
              case 'D':
                  return number + '-';
              default:
                  return number;
          }
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('bg', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split('_'),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'D.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY H:mm',
          LLLL: 'dddd, D MMMM YYYY H:mm',
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[ ] LT',
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                  case 3:
                  case 6:
                      return '[] dddd [] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[] dddd [] LT';
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: ' ',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d ',
          w: '',
          ww: '%d ',
          M: '',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
      ordinal: function (number) {
          var lastDigit = number % 10,
              last2Digits = number % 100;
          if (number === 0) {
              return number + '-';
          } else if (last2Digits === 0) {
              return number + '-';
          } else if (last2Digits > 10 && last2Digits < 20) {
              return number + '-';
          } else if (lastDigit === 1) {
              return number + '-';
          } else if (lastDigit === 2) {
              return number + '-';
          } else if (lastDigit === 7 || lastDigit === 8) {
              return number + '-';
          } else {
              return number + '-';
          }
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('bm', {
      months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split(
          '_'
      ),
      monthsShort: 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
      weekdays: 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
      weekdaysShort: 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
      weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'MMMM [tile] D [san] YYYY',
          LLL: 'MMMM [tile] D [san] YYYY [lr] HH:mm',
          LLLL: 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm',
      },
      calendar: {
          sameDay: '[Bi lr] LT',
          nextDay: '[Sini lr] LT',
          nextWeek: 'dddd [don lr] LT',
          lastDay: '[Kunu lr] LT',
          lastWeek: 'dddd [tmnen lr] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s kn',
          past: 'a b %s b',
          s: 'sanga dama dama',
          ss: 'sekondi %d',
          m: 'miniti kelen',
          mm: 'miniti %d',
          h: 'lr kelen',
          hh: 'lr %d',
          d: 'tile kelen',
          dd: 'tile %d',
          M: 'kalo kelen',
          MM: 'kalo %d',
          y: 'san kelen',
          yy: 'san %d',
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$3 = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$2 = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('bn-bd', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm ',
          LTS: 'A h:mm:ss ',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm ',
          LLLL: 'dddd, D MMMM YYYY, A h:mm ',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$2[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$3[match];
          });
      },

      meridiemParse: /||||||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '') {
              return hour < 4 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 3 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour + 12;
          } else if (meridiem === '') {
              return hour + 12;
          }
      },

      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 6) {
              return '';
          } else if (hour < 12) {
              return '';
          } else if (hour < 15) {
              return '';
          } else if (hour < 18) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$4 = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$3 = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('bn', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm ',
          LTS: 'A h:mm:ss ',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm ',
          LLLL: 'dddd, D MMMM YYYY, A h:mm ',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$3[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$4[match];
          });
      },
      meridiemParse: /||||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (
              (meridiem === '' && hour >= 4) ||
              (meridiem === '' && hour < 5) ||
              meridiem === ''
          ) {
              return hour + 12;
          } else {
              return hour;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 10) {
              return '';
          } else if (hour < 17) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$5 = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$4 = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('bo', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split(
          '_'
      ),
      monthsShortRegex: /^(\d{1,2})/,
      monthsParseExact: true,
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split(
          '_'
      ),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm',
          LTS: 'A h:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm',
          LLLL: 'dddd, D MMMM YYYY, A h:mm',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: '[], LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: '',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d ',
          M: '',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$4[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$5[match];
          });
      },
      meridiemParse: /||||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (
              (meridiem === '' && hour >= 4) ||
              (meridiem === '' && hour < 5) ||
              meridiem === ''
          ) {
              return hour + 12;
          } else {
              return hour;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 10) {
              return '';
          } else if (hour < 17) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function relativeTimeWithMutation(number, withoutSuffix, key) {
      var format = {
          mm: 'munutenn',
          MM: 'miz',
          dd: 'devezh',
      };
      return number + ' ' + mutation(format[key], number);
  }
  function specialMutationForYears(number) {
      switch (lastNumber(number)) {
          case 1:
          case 3:
          case 4:
          case 5:
          case 9:
              return number + ' bloaz';
          default:
              return number + ' vloaz';
      }
  }
  function lastNumber(number) {
      if (number > 9) {
          return lastNumber(number % 10);
      }
      return number;
  }
  function mutation(text, number) {
      if (number === 2) {
          return softMutation(text);
      }
      return text;
  }
  function softMutation(text) {
      var mutationTable = {
          m: 'v',
          b: 'v',
          d: 'z',
      };
      if (mutationTable[text.charAt(0)] === undefined) {
          return text;
      }
      return mutationTable[text.charAt(0)] + text.substring(1);
  }

  var monthsParse = [
          /^gen/i,
          /^c[\']hwe/i,
          /^meu/i,
          /^ebr/i,
          /^mae/i,
          /^(mez|eve)/i,
          /^gou/i,
          /^eos/i,
          /^gwe/i,
          /^her/i,
          /^du/i,
          /^ker/i,
      ],
      monthsRegex$1 = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
      monthsStrictRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,
      monthsShortStrictRegex = /^(gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
      fullWeekdaysParse = [
          /^sul/i,
          /^lun/i,
          /^meurzh/i,
          /^merc[\']her/i,
          /^yaou/i,
          /^gwener/i,
          /^sadorn/i,
      ],
      shortWeekdaysParse = [
          /^Sul/i,
          /^Lun/i,
          /^Meu/i,
          /^Mer/i,
          /^Yao/i,
          /^Gwe/i,
          /^Sad/i,
      ],
      minWeekdaysParse = [
          /^Su/i,
          /^Lu/i,
          /^Me([^r]|$)/i,
          /^Mer/i,
          /^Ya/i,
          /^Gw/i,
          /^Sa/i,
      ];

  hooks.defineLocale('br', {
      months: 'Genver_Chwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split(
          '_'
      ),
      monthsShort: 'Gen_Chwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
      weekdays: 'Sul_Lun_Meurzh_Mercher_Yaou_Gwener_Sadorn'.split('_'),
      weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
      weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
      weekdaysParse: minWeekdaysParse,
      fullWeekdaysParse: fullWeekdaysParse,
      shortWeekdaysParse: shortWeekdaysParse,
      minWeekdaysParse: minWeekdaysParse,

      monthsRegex: monthsRegex$1,
      monthsShortRegex: monthsRegex$1,
      monthsStrictRegex: monthsStrictRegex,
      monthsShortStrictRegex: monthsShortStrictRegex,
      monthsParse: monthsParse,
      longMonthsParse: monthsParse,
      shortMonthsParse: monthsParse,

      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [a viz] MMMM YYYY',
          LLL: 'D [a viz] MMMM YYYY HH:mm',
          LLLL: 'dddd, D [a viz] MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Hiziv da] LT',
          nextDay: '[Warchoazh da] LT',
          nextWeek: 'dddd [da] LT',
          lastDay: '[Dech da] LT',
          lastWeek: 'dddd [paset da] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'a-benn %s',
          past: '%s zo',
          s: 'un nebeud segondenno',
          ss: '%d eilenn',
          m: 'ur vunutenn',
          mm: relativeTimeWithMutation,
          h: 'un eur',
          hh: '%d eur',
          d: 'un devezh',
          dd: relativeTimeWithMutation,
          M: 'ur miz',
          MM: relativeTimeWithMutation,
          y: 'ur bloaz',
          yy: specialMutationForYears,
      },
      dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
      ordinal: function (number) {
          var output = number === 1 ? 'a' : 'vet';
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
      meridiemParse: /a.m.|g.m./, // goude merenn | a-raok merenn
      isPM: function (token) {
          return token === 'g.m.';
      },
      meridiem: function (hour, minute, isLower) {
          return hour < 12 ? 'a.m.' : 'g.m.';
      },
  });

  //! moment.js locale configuration

  function translate(number, withoutSuffix, key) {
      var result = number + ' ';
      switch (key) {
          case 'ss':
              if (number === 1) {
                  result += 'sekunda';
              } else if (number === 2 || number === 3 || number === 4) {
                  result += 'sekunde';
              } else {
                  result += 'sekundi';
              }
              return result;
          case 'm':
              return withoutSuffix ? 'jedna minuta' : 'jedne minute';
          case 'mm':
              if (number === 1) {
                  result += 'minuta';
              } else if (number === 2 || number === 3 || number === 4) {
                  result += 'minute';
              } else {
                  result += 'minuta';
              }
              return result;
          case 'h':
              return withoutSuffix ? 'jedan sat' : 'jednog sata';
          case 'hh':
              if (number === 1) {
                  result += 'sat';
              } else if (number === 2 || number === 3 || number === 4) {
                  result += 'sata';
              } else {
                  result += 'sati';
              }
              return result;
          case 'dd':
              if (number === 1) {
                  result += 'dan';
              } else {
                  result += 'dana';
              }
              return result;
          case 'MM':
              if (number === 1) {
                  result += 'mjesec';
              } else if (number === 2 || number === 3 || number === 4) {
                  result += 'mjeseca';
              } else {
                  result += 'mjeseci';
              }
              return result;
          case 'yy':
              if (number === 1) {
                  result += 'godina';
              } else if (number === 2 || number === 3 || number === 4) {
                  result += 'godine';
              } else {
                  result += 'godina';
              }
              return result;
      }
  }

  hooks.defineLocale('bs', {
      months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split(
          '_'
      ),
      monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split(
          '_'
      ),
      weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
      weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm',
      },
      calendar: {
          sameDay: '[danas u] LT',
          nextDay: '[sutra u] LT',
          nextWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[u] [nedjelju] [u] LT';
                  case 3:
                      return '[u] [srijedu] [u] LT';
                  case 6:
                      return '[u] [subotu] [u] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[u] dddd [u] LT';
              }
          },
          lastDay: '[juer u] LT',
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                  case 3:
                      return '[prolu] dddd [u] LT';
                  case 6:
                      return '[prole] [subote] [u] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[proli] dddd [u] LT';
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'za %s',
          past: 'prije %s',
          s: 'par sekundi',
          ss: translate,
          m: translate,
          mm: translate,
          h: translate,
          hh: translate,
          d: 'dan',
          dd: translate,
          M: 'mjesec',
          MM: translate,
          y: 'godinu',
          yy: translate,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ca', {
      months: {
          standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split(
              '_'
          ),
          format: "de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split(
              '_'
          ),
          isFormat: /D[oD]?(\s)+MMMM/,
      },
      monthsShort: 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split(
          '_'
      ),
      weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
      weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM [de] YYYY',
          ll: 'D MMM YYYY',
          LLL: 'D MMMM [de] YYYY [a les] H:mm',
          lll: 'D MMM YYYY, H:mm',
          LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
          llll: 'ddd D MMM YYYY, H:mm',
      },
      calendar: {
          sameDay: function () {
              return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
          },
          nextDay: function () {
              return '[dem a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
          },
          nextWeek: function () {
              return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
          },
          lastDay: function () {
              return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
          },
          lastWeek: function () {
              return (
                  '[el] dddd [passat a ' +
                  (this.hours() !== 1 ? 'les' : 'la') +
                  '] LT'
              );
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: "d'aqu %s",
          past: 'fa %s',
          s: 'uns segons',
          ss: '%d segons',
          m: 'un minut',
          mm: '%d minuts',
          h: 'una hora',
          hh: '%d hores',
          d: 'un dia',
          dd: '%d dies',
          M: 'un mes',
          MM: '%d mesos',
          y: 'un any',
          yy: '%d anys',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
      ordinal: function (number, period) {
          var output =
              number === 1
                  ? 'r'
                  : number === 2
                  ? 'n'
                  : number === 3
                  ? 'r'
                  : number === 4
                  ? 't'
                  : '';
          if (period === 'w' || period === 'W') {
              output = 'a';
          }
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var months$4 = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split(
          '_'
      ),
      monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_'),
      monthsParse$1 = [
          /^led/i,
          /^no/i,
          /^be/i,
          /^dub/i,
          /^kv/i,
          /^(vn|erven$|ervna)/i,
          /^(vc|ervenec|ervence)/i,
          /^srp/i,
          /^z/i,
          /^j/i,
          /^lis/i,
          /^pro/i,
      ],
      // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
      // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
      monthsRegex$2 = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;

  function plural$1(n) {
      return n > 1 && n < 5 && ~~(n / 10) !== 1;
  }
  function translate$1(number, withoutSuffix, key, isFuture) {
      var result = number + ' ';
      switch (key) {
          case 's': // a few seconds / in a few seconds / a few seconds ago
              return withoutSuffix || isFuture ? 'pr sekund' : 'pr sekundami';
          case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$1(number) ? 'sekundy' : 'sekund');
              } else {
                  return result + 'sekundami';
              }
          case 'm': // a minute / in a minute / a minute ago
              return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';
          case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$1(number) ? 'minuty' : 'minut');
              } else {
                  return result + 'minutami';
              }
          case 'h': // an hour / in an hour / an hour ago
              return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
          case 'hh': // 9 hours / in 9 hours / 9 hours ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$1(number) ? 'hodiny' : 'hodin');
              } else {
                  return result + 'hodinami';
              }
          case 'd': // a day / in a day / a day ago
              return withoutSuffix || isFuture ? 'den' : 'dnem';
          case 'dd': // 9 days / in 9 days / 9 days ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$1(number) ? 'dny' : 'dn');
              } else {
                  return result + 'dny';
              }
          case 'M': // a month / in a month / a month ago
              return withoutSuffix || isFuture ? 'msc' : 'mscem';
          case 'MM': // 9 months / in 9 months / 9 months ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$1(number) ? 'msce' : 'msc');
              } else {
                  return result + 'msci';
              }
          case 'y': // a year / in a year / a year ago
              return withoutSuffix || isFuture ? 'rok' : 'rokem';
          case 'yy': // 9 years / in 9 years / 9 years ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$1(number) ? 'roky' : 'let');
              } else {
                  return result + 'lety';
              }
      }
  }

  hooks.defineLocale('cs', {
      months: months$4,
      monthsShort: monthsShort,
      monthsRegex: monthsRegex$2,
      monthsShortRegex: monthsRegex$2,
      // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
      // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
      monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
      monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
      monthsParse: monthsParse$1,
      longMonthsParse: monthsParse$1,
      shortMonthsParse: monthsParse$1,
      weekdays: 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
      weekdaysShort: 'ne_po_t_st_t_p_so'.split('_'),
      weekdaysMin: 'ne_po_t_st_t_p_so'.split('_'),
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd D. MMMM YYYY H:mm',
          l: 'D. M. YYYY',
      },
      calendar: {
          sameDay: '[dnes v] LT',
          nextDay: '[ztra v] LT',
          nextWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[v nedli v] LT';
                  case 1:
                  case 2:
                      return '[v] dddd [v] LT';
                  case 3:
                      return '[ve stedu v] LT';
                  case 4:
                      return '[ve tvrtek v] LT';
                  case 5:
                      return '[v ptek v] LT';
                  case 6:
                      return '[v sobotu v] LT';
              }
          },
          lastDay: '[vera v] LT',
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[minulou nedli v] LT';
                  case 1:
                  case 2:
                      return '[minul] dddd [v] LT';
                  case 3:
                      return '[minulou stedu v] LT';
                  case 4:
                  case 5:
                      return '[minul] dddd [v] LT';
                  case 6:
                      return '[minulou sobotu v] LT';
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'za %s',
          past: 'ped %s',
          s: translate$1,
          ss: translate$1,
          m: translate$1,
          mm: translate$1,
          h: translate$1,
          hh: translate$1,
          d: translate$1,
          dd: translate$1,
          M: translate$1,
          MM: translate$1,
          y: translate$1,
          yy: translate$1,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('cv', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split('_'),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD-MM-YYYY',
          LL: 'YYYY [] MMMM [] D[-]',
          LLL: 'YYYY [] MMMM [] D[-], HH:mm',
          LLLL: 'dddd, YYYY [] MMMM [] D[-], HH:mm',
      },
      calendar: {
          sameDay: '[] LT []',
          nextDay: '[] LT []',
          lastDay: '[] LT []',
          nextWeek: '[] dddd LT []',
          lastWeek: '[] dddd LT []',
          sameElse: 'L',
      },
      relativeTime: {
          future: function (output) {
              var affix = /$/i.exec(output)
                  ? ''
                  : /$/i.exec(output)
                  ? ''
                  : '';
              return output + affix;
          },
          past: '%s ',
          s: '- ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /\d{1,2}-/,
      ordinal: '%d-',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('cy', {
      months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split(
          '_'
      ),
      monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split(
          '_'
      ),
      weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split(
          '_'
      ),
      weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
      weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
      weekdaysParseExact: true,
      // time formats are the same as en-gb
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Heddiw am] LT',
          nextDay: '[Yfory am] LT',
          nextWeek: 'dddd [am] LT',
          lastDay: '[Ddoe am] LT',
          lastWeek: 'dddd [diwethaf am] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'mewn %s',
          past: '%s yn l',
          s: 'ychydig eiliadau',
          ss: '%d eiliad',
          m: 'munud',
          mm: '%d munud',
          h: 'awr',
          hh: '%d awr',
          d: 'diwrnod',
          dd: '%d diwrnod',
          M: 'mis',
          MM: '%d mis',
          y: 'blwyddyn',
          yy: '%d flynedd',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
      // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
      ordinal: function (number) {
          var b = number,
              output = '',
              lookup = [
                  '',
                  'af',
                  'il',
                  'ydd',
                  'ydd',
                  'ed',
                  'ed',
                  'ed',
                  'fed',
                  'fed',
                  'fed', // 1af to 10fed
                  'eg',
                  'fed',
                  'eg',
                  'eg',
                  'fed',
                  'eg',
                  'eg',
                  'fed',
                  'eg',
                  'fed', // 11eg to 20fed
              ];
          if (b > 20) {
              if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                  output = 'fed'; // not 30ain, 70ain or 90ain
              } else {
                  output = 'ain';
              }
          } else if (b > 0) {
              output = lookup[b];
          }
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('da', {
      months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split(
          '_'
      ),
      monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
      weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
      weekdaysShort: 'sn_man_tir_ons_tor_fre_lr'.split('_'),
      weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm',
      },
      calendar: {
          sameDay: '[i dag kl.] LT',
          nextDay: '[i morgen kl.] LT',
          nextWeek: 'p dddd [kl.] LT',
          lastDay: '[i gr kl.] LT',
          lastWeek: '[i] dddd[s kl.] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'om %s',
          past: '%s siden',
          s: 'f sekunder',
          ss: '%d sekunder',
          m: 'et minut',
          mm: '%d minutter',
          h: 'en time',
          hh: '%d timer',
          d: 'en dag',
          dd: '%d dage',
          M: 'en mned',
          MM: '%d mneder',
          y: 'et r',
          yy: '%d r',
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
      var format = {
          m: ['eine Minute', 'einer Minute'],
          h: ['eine Stunde', 'einer Stunde'],
          d: ['ein Tag', 'einem Tag'],
          dd: [number + ' Tage', number + ' Tagen'],
          w: ['eine Woche', 'einer Woche'],
          M: ['ein Monat', 'einem Monat'],
          MM: [number + ' Monate', number + ' Monaten'],
          y: ['ein Jahr', 'einem Jahr'],
          yy: [number + ' Jahre', number + ' Jahren'],
      };
      return withoutSuffix ? format[key][0] : format[key][1];
  }

  hooks.defineLocale('de-at', {
      months: 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
          '_'
      ),
      monthsShort: 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
          '_'
      ),
      weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
      weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd, D. MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[heute um] LT [Uhr]',
          sameElse: 'L',
          nextDay: '[morgen um] LT [Uhr]',
          nextWeek: 'dddd [um] LT [Uhr]',
          lastDay: '[gestern um] LT [Uhr]',
          lastWeek: '[letzten] dddd [um] LT [Uhr]',
      },
      relativeTime: {
          future: 'in %s',
          past: 'vor %s',
          s: 'ein paar Sekunden',
          ss: '%d Sekunden',
          m: processRelativeTime,
          mm: '%d Minuten',
          h: processRelativeTime,
          hh: '%d Stunden',
          d: processRelativeTime,
          dd: processRelativeTime,
          w: processRelativeTime,
          ww: '%d Wochen',
          M: processRelativeTime,
          MM: processRelativeTime,
          y: processRelativeTime,
          yy: processRelativeTime,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function processRelativeTime$1(number, withoutSuffix, key, isFuture) {
      var format = {
          m: ['eine Minute', 'einer Minute'],
          h: ['eine Stunde', 'einer Stunde'],
          d: ['ein Tag', 'einem Tag'],
          dd: [number + ' Tage', number + ' Tagen'],
          w: ['eine Woche', 'einer Woche'],
          M: ['ein Monat', 'einem Monat'],
          MM: [number + ' Monate', number + ' Monaten'],
          y: ['ein Jahr', 'einem Jahr'],
          yy: [number + ' Jahre', number + ' Jahren'],
      };
      return withoutSuffix ? format[key][0] : format[key][1];
  }

  hooks.defineLocale('de-ch', {
      months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
          '_'
      ),
      monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
          '_'
      ),
      weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
      weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd, D. MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[heute um] LT [Uhr]',
          sameElse: 'L',
          nextDay: '[morgen um] LT [Uhr]',
          nextWeek: 'dddd [um] LT [Uhr]',
          lastDay: '[gestern um] LT [Uhr]',
          lastWeek: '[letzten] dddd [um] LT [Uhr]',
      },
      relativeTime: {
          future: 'in %s',
          past: 'vor %s',
          s: 'ein paar Sekunden',
          ss: '%d Sekunden',
          m: processRelativeTime$1,
          mm: '%d Minuten',
          h: processRelativeTime$1,
          hh: '%d Stunden',
          d: processRelativeTime$1,
          dd: processRelativeTime$1,
          w: processRelativeTime$1,
          ww: '%d Wochen',
          M: processRelativeTime$1,
          MM: processRelativeTime$1,
          y: processRelativeTime$1,
          yy: processRelativeTime$1,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function processRelativeTime$2(number, withoutSuffix, key, isFuture) {
      var format = {
          m: ['eine Minute', 'einer Minute'],
          h: ['eine Stunde', 'einer Stunde'],
          d: ['ein Tag', 'einem Tag'],
          dd: [number + ' Tage', number + ' Tagen'],
          w: ['eine Woche', 'einer Woche'],
          M: ['ein Monat', 'einem Monat'],
          MM: [number + ' Monate', number + ' Monaten'],
          y: ['ein Jahr', 'einem Jahr'],
          yy: [number + ' Jahre', number + ' Jahren'],
      };
      return withoutSuffix ? format[key][0] : format[key][1];
  }

  hooks.defineLocale('de', {
      months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
          '_'
      ),
      monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
          '_'
      ),
      weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
      weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY HH:mm',
          LLLL: 'dddd, D. MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[heute um] LT [Uhr]',
          sameElse: 'L',
          nextDay: '[morgen um] LT [Uhr]',
          nextWeek: 'dddd [um] LT [Uhr]',
          lastDay: '[gestern um] LT [Uhr]',
          lastWeek: '[letzten] dddd [um] LT [Uhr]',
      },
      relativeTime: {
          future: 'in %s',
          past: 'vor %s',
          s: 'ein paar Sekunden',
          ss: '%d Sekunden',
          m: processRelativeTime$2,
          mm: '%d Minuten',
          h: processRelativeTime$2,
          hh: '%d Stunden',
          d: processRelativeTime$2,
          dd: processRelativeTime$2,
          w: processRelativeTime$2,
          ww: '%d Wochen',
          M: processRelativeTime$2,
          MM: processRelativeTime$2,
          y: processRelativeTime$2,
          yy: processRelativeTime$2,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var months$5 = [
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
      ],
      weekdays = [
          '',
          '',
          '',
          '',
          '',
          '',
          '',
      ];

  hooks.defineLocale('dv', {
      months: months$5,
      monthsShort: months$5,
      weekdays: weekdays,
      weekdaysShort: weekdays,
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'D/M/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return '' === input;
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: '',
          ss: 'd% ',
          m: '',
          mm: ' %d',
          h: '',
          hh: ' %d',
          d: '',
          dd: ' %d',
          M: '',
          MM: ' %d',
          y: '',
          yy: ' %d',
      },
      preparse: function (string) {
          return string.replace(//g, ',');
      },
      postformat: function (string) {
          return string.replace(/,/g, '');
      },
      week: {
          dow: 7, // Sunday is the first day of the week.
          doy: 12, // The week that contains Jan 12th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function isFunction$1(input) {
      return (
          (typeof Function !== 'undefined' && input instanceof Function) ||
          Object.prototype.toString.call(input) === '[object Function]'
      );
  }

  hooks.defineLocale('el', {
      monthsNominativeEl: '___________'.split(
          '_'
      ),
      monthsGenitiveEl: '___________'.split(
          '_'
      ),
      months: function (momentToFormat, format) {
          if (!momentToFormat) {
              return this._monthsNominativeEl;
          } else if (
              typeof format === 'string' &&
              /D/.test(format.substring(0, format.indexOf('MMMM')))
          ) {
              // if there is a day number before 'MMMM'
              return this._monthsGenitiveEl[momentToFormat.month()];
          } else {
              return this._monthsNominativeEl[momentToFormat.month()];
          }
      },
      monthsShort: '___________'.split('_'),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      meridiem: function (hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? '' : '';
          } else {
              return isLower ? '' : '';
          }
      },
      isPM: function (input) {
          return (input + '').toLowerCase()[0] === '';
      },
      meridiemParse: /[]\.??\.?/i,
      longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
      },
      calendarEl: {
          sameDay: '[ {}] LT',
          nextDay: '[ {}] LT',
          nextWeek: 'dddd [{}] LT',
          lastDay: '[ {}] LT',
          lastWeek: function () {
              switch (this.day()) {
                  case 6:
                      return '[ ] dddd [{}] LT';
                  default:
                      return '[ ] dddd [{}] LT';
              }
          },
          sameElse: 'L',
      },
      calendar: function (key, mom) {
          var output = this._calendarEl[key],
              hours = mom && mom.hours();
          if (isFunction$1(output)) {
              output = output.apply(mom);
          }
          return output.replace('{}', hours % 12 === 1 ? '' : '');
      },
      relativeTime: {
          future: ' %s',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4st is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('en-au', {
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
          '_'
      ),
      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
      },
      calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('en-ca', {
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
          '_'
      ),
      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'YYYY-MM-DD',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A',
      },
      calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('en-gb', {
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
          '_'
      ),
      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('en-ie', {
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
          '_'
      ),
      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('en-il', {
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
          '_'
      ),
      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('en-in', {
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
          '_'
      ),
      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
      },
      calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 1st is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('en-nz', {
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
          '_'
      ),
      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
      },
      calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('en-sg', {
      months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
          '_'
      ),
      weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('eo', {
      months: 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split(
          '_'
      ),
      monthsShort: 'jan_feb_mart_apr_maj_jun_jul_ag_sept_okt_nov_dec'.split('_'),
      weekdays: 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
      weekdaysShort: 'dim_lun_mard_merk_a_ven_sab'.split('_'),
      weekdaysMin: 'di_lu_ma_me_a_ve_sa'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: '[la] D[-an de] MMMM, YYYY',
          LLL: '[la] D[-an de] MMMM, YYYY HH:mm',
          LLLL: 'dddd[n], [la] D[-an de] MMMM, YYYY HH:mm',
          llll: 'ddd, [la] D[-an de] MMM, YYYY HH:mm',
      },
      meridiemParse: /[ap]\.t\.m/i,
      isPM: function (input) {
          return input.charAt(0).toLowerCase() === 'p';
      },
      meridiem: function (hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? 'p.t.m.' : 'P.T.M.';
          } else {
              return isLower ? 'a.t.m.' : 'A.T.M.';
          }
      },
      calendar: {
          sameDay: '[Hodia je] LT',
          nextDay: '[Morga je] LT',
          nextWeek: 'dddd[n je] LT',
          lastDay: '[Hiera je] LT',
          lastWeek: '[pasintan] dddd[n je] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'post %s',
          past: 'anta %s',
          s: 'kelkaj sekundoj',
          ss: '%d sekundoj',
          m: 'unu minuto',
          mm: '%d minutoj',
          h: 'unu horo',
          hh: '%d horoj',
          d: 'unu tago', //ne 'diurno', ar estas uzita por proksimumo
          dd: '%d tagoj',
          M: 'unu monato',
          MM: '%d monatoj',
          y: 'unu jaro',
          yy: '%d jaroj',
      },
      dayOfMonthOrdinalParse: /\d{1,2}a/,
      ordinal: '%da',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
          '_'
      ),
      monthsShort$1 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse$2 = [
          /^ene/i,
          /^feb/i,
          /^mar/i,
          /^abr/i,
          /^may/i,
          /^jun/i,
          /^jul/i,
          /^ago/i,
          /^sep/i,
          /^oct/i,
          /^nov/i,
          /^dic/i,
      ],
      monthsRegex$3 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

  hooks.defineLocale('es-do', {
      months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
          '_'
      ),
      monthsShort: function (m, format) {
          if (!m) {
              return monthsShortDot;
          } else if (/-MMM-/.test(format)) {
              return monthsShort$1[m.month()];
          } else {
              return monthsShortDot[m.month()];
          }
      },
      monthsRegex: monthsRegex$3,
      monthsShortRegex: monthsRegex$3,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$2,
      longMonthsParse: monthsParse$2,
      shortMonthsParse: monthsParse$2,
      weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
      weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
      weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY h:mm A',
          LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
      },
      calendar: {
          sameDay: function () {
              return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextDay: function () {
              return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextWeek: function () {
              return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastDay: function () {
              return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastWeek: function () {
              return (
                  '[el] dddd [pasado a la' +
                  (this.hours() !== 1 ? 's' : '') +
                  '] LT'
              );
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'en %s',
          past: 'hace %s',
          s: 'unos segundos',
          ss: '%d segundos',
          m: 'un minuto',
          mm: '%d minutos',
          h: 'una hora',
          hh: '%d horas',
          d: 'un da',
          dd: '%d das',
          w: 'una semana',
          ww: '%d semanas',
          M: 'un mes',
          MM: '%d meses',
          y: 'un ao',
          yy: '%d aos',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var monthsShortDot$1 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
          '_'
      ),
      monthsShort$2 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse$3 = [
          /^ene/i,
          /^feb/i,
          /^mar/i,
          /^abr/i,
          /^may/i,
          /^jun/i,
          /^jul/i,
          /^ago/i,
          /^sep/i,
          /^oct/i,
          /^nov/i,
          /^dic/i,
      ],
      monthsRegex$4 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

  hooks.defineLocale('es-mx', {
      months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
          '_'
      ),
      monthsShort: function (m, format) {
          if (!m) {
              return monthsShortDot$1;
          } else if (/-MMM-/.test(format)) {
              return monthsShort$2[m.month()];
          } else {
              return monthsShortDot$1[m.month()];
          }
      },
      monthsRegex: monthsRegex$4,
      monthsShortRegex: monthsRegex$4,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$3,
      longMonthsParse: monthsParse$3,
      shortMonthsParse: monthsParse$3,
      weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
      weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
      weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY H:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
      },
      calendar: {
          sameDay: function () {
              return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextDay: function () {
              return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextWeek: function () {
              return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastDay: function () {
              return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastWeek: function () {
              return (
                  '[el] dddd [pasado a la' +
                  (this.hours() !== 1 ? 's' : '') +
                  '] LT'
              );
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'en %s',
          past: 'hace %s',
          s: 'unos segundos',
          ss: '%d segundos',
          m: 'un minuto',
          mm: '%d minutos',
          h: 'una hora',
          hh: '%d horas',
          d: 'un da',
          dd: '%d das',
          w: 'una semana',
          ww: '%d semanas',
          M: 'un mes',
          MM: '%d meses',
          y: 'un ao',
          yy: '%d aos',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
      invalidDate: 'Fecha invlida',
  });

  //! moment.js locale configuration

  var monthsShortDot$2 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
          '_'
      ),
      monthsShort$3 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse$4 = [
          /^ene/i,
          /^feb/i,
          /^mar/i,
          /^abr/i,
          /^may/i,
          /^jun/i,
          /^jul/i,
          /^ago/i,
          /^sep/i,
          /^oct/i,
          /^nov/i,
          /^dic/i,
      ],
      monthsRegex$5 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

  hooks.defineLocale('es-us', {
      months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
          '_'
      ),
      monthsShort: function (m, format) {
          if (!m) {
              return monthsShortDot$2;
          } else if (/-MMM-/.test(format)) {
              return monthsShort$3[m.month()];
          } else {
              return monthsShortDot$2[m.month()];
          }
      },
      monthsRegex: monthsRegex$5,
      monthsShortRegex: monthsRegex$5,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$4,
      longMonthsParse: monthsParse$4,
      shortMonthsParse: monthsParse$4,
      weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
      weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
      weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'MM/DD/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY h:mm A',
          LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
      },
      calendar: {
          sameDay: function () {
              return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextDay: function () {
              return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextWeek: function () {
              return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastDay: function () {
              return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastWeek: function () {
              return (
                  '[el] dddd [pasado a la' +
                  (this.hours() !== 1 ? 's' : '') +
                  '] LT'
              );
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'en %s',
          past: 'hace %s',
          s: 'unos segundos',
          ss: '%d segundos',
          m: 'un minuto',
          mm: '%d minutos',
          h: 'una hora',
          hh: '%d horas',
          d: 'un da',
          dd: '%d das',
          w: 'una semana',
          ww: '%d semanas',
          M: 'un mes',
          MM: '%d meses',
          y: 'un ao',
          yy: '%d aos',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var monthsShortDot$3 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
          '_'
      ),
      monthsShort$4 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse$5 = [
          /^ene/i,
          /^feb/i,
          /^mar/i,
          /^abr/i,
          /^may/i,
          /^jun/i,
          /^jul/i,
          /^ago/i,
          /^sep/i,
          /^oct/i,
          /^nov/i,
          /^dic/i,
      ],
      monthsRegex$6 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

  hooks.defineLocale('es', {
      months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
          '_'
      ),
      monthsShort: function (m, format) {
          if (!m) {
              return monthsShortDot$3;
          } else if (/-MMM-/.test(format)) {
              return monthsShort$4[m.month()];
          } else {
              return monthsShortDot$3[m.month()];
          }
      },
      monthsRegex: monthsRegex$6,
      monthsShortRegex: monthsRegex$6,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$5,
      longMonthsParse: monthsParse$5,
      shortMonthsParse: monthsParse$5,
      weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
      weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
      weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY H:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
      },
      calendar: {
          sameDay: function () {
              return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextDay: function () {
              return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextWeek: function () {
              return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastDay: function () {
              return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          lastWeek: function () {
              return (
                  '[el] dddd [pasado a la' +
                  (this.hours() !== 1 ? 's' : '') +
                  '] LT'
              );
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'en %s',
          past: 'hace %s',
          s: 'unos segundos',
          ss: '%d segundos',
          m: 'un minuto',
          mm: '%d minutos',
          h: 'una hora',
          hh: '%d horas',
          d: 'un da',
          dd: '%d das',
          w: 'una semana',
          ww: '%d semanas',
          M: 'un mes',
          MM: '%d meses',
          y: 'un ao',
          yy: '%d aos',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
      invalidDate: 'Fecha invlida',
  });

  //! moment.js locale configuration

  function processRelativeTime$3(number, withoutSuffix, key, isFuture) {
      var format = {
          s: ['mne sekundi', 'mni sekund', 'paar sekundit'],
          ss: [number + 'sekundi', number + 'sekundit'],
          m: ['he minuti', 'ks minut'],
          mm: [number + ' minuti', number + ' minutit'],
          h: ['he tunni', 'tund aega', 'ks tund'],
          hh: [number + ' tunni', number + ' tundi'],
          d: ['he peva', 'ks pev'],
          M: ['kuu aja', 'kuu aega', 'ks kuu'],
          MM: [number + ' kuu', number + ' kuud'],
          y: ['he aasta', 'aasta', 'ks aasta'],
          yy: [number + ' aasta', number + ' aastat'],
      };
      if (withoutSuffix) {
          return format[key][2] ? format[key][2] : format[key][1];
      }
      return isFuture ? format[key][0] : format[key][1];
  }

  hooks.defineLocale('et', {
      months: 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split(
          '_'
      ),
      monthsShort: 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split(
          '_'
      ),
      weekdays: 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split(
          '_'
      ),
      weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
      weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm',
      },
      calendar: {
          sameDay: '[Tna,] LT',
          nextDay: '[Homme,] LT',
          nextWeek: '[Jrgmine] dddd LT',
          lastDay: '[Eile,] LT',
          lastWeek: '[Eelmine] dddd LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s prast',
          past: '%s tagasi',
          s: processRelativeTime$3,
          ss: processRelativeTime$3,
          m: processRelativeTime$3,
          mm: processRelativeTime$3,
          h: processRelativeTime$3,
          hh: processRelativeTime$3,
          d: processRelativeTime$3,
          dd: '%d peva',
          M: processRelativeTime$3,
          MM: processRelativeTime$3,
          y: processRelativeTime$3,
          yy: processRelativeTime$3,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('eu', {
      months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split(
          '_'
      ),
      monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split(
          '_'
      ),
      weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
      weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'YYYY[ko] MMMM[ren] D[a]',
          LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
          LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
          l: 'YYYY-M-D',
          ll: 'YYYY[ko] MMM D[a]',
          lll: 'YYYY[ko] MMM D[a] HH:mm',
          llll: 'ddd, YYYY[ko] MMM D[a] HH:mm',
      },
      calendar: {
          sameDay: '[gaur] LT[etan]',
          nextDay: '[bihar] LT[etan]',
          nextWeek: 'dddd LT[etan]',
          lastDay: '[atzo] LT[etan]',
          lastWeek: '[aurreko] dddd LT[etan]',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s barru',
          past: 'duela %s',
          s: 'segundo batzuk',
          ss: '%d segundo',
          m: 'minutu bat',
          mm: '%d minutu',
          h: 'ordu bat',
          hh: '%d ordu',
          d: 'egun bat',
          dd: '%d egun',
          M: 'hilabete bat',
          MM: '%d hilabete',
          y: 'urte bat',
          yy: '%d urte',
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$6 = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$5 = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('fa', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '\u200c__\u200c__\u200c__'.split(
          '_'
      ),
      weekdaysShort: '\u200c__\u200c__\u200c__'.split(
          '_'
      ),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      meridiemParse: /  |  /,
      isPM: function (input) {
          return /  /.test(input);
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '  ';
          } else {
              return '  ';
          }
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[ ] LT',
          lastWeek: 'dddd [] [] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      preparse: function (string) {
          return string
              .replace(/[-]/g, function (match) {
                  return numberMap$5[match];
              })
              .replace(//g, ',');
      },
      postformat: function (string) {
          return string
              .replace(/\d/g, function (match) {
                  return symbolMap$6[match];
              })
              .replace(/,/g, '');
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 6, // Saturday is the first day of the week.
          doy: 12, // The week that contains Jan 12th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(
          ' '
      ),
      numbersFuture = [
          'nolla',
          'yhden',
          'kahden',
          'kolmen',
          'neljn',
          'viiden',
          'kuuden',
          numbersPast[7],
          numbersPast[8],
          numbersPast[9],
      ];
  function translate$2(number, withoutSuffix, key, isFuture) {
      var result = '';
      switch (key) {
          case 's':
              return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
          case 'ss':
              result = isFuture ? 'sekunnin' : 'sekuntia';
              break;
          case 'm':
              return isFuture ? 'minuutin' : 'minuutti';
          case 'mm':
              result = isFuture ? 'minuutin' : 'minuuttia';
              break;
          case 'h':
              return isFuture ? 'tunnin' : 'tunti';
          case 'hh':
              result = isFuture ? 'tunnin' : 'tuntia';
              break;
          case 'd':
              return isFuture ? 'pivn' : 'piv';
          case 'dd':
              result = isFuture ? 'pivn' : 'piv';
              break;
          case 'M':
              return isFuture ? 'kuukauden' : 'kuukausi';
          case 'MM':
              result = isFuture ? 'kuukauden' : 'kuukautta';
              break;
          case 'y':
              return isFuture ? 'vuoden' : 'vuosi';
          case 'yy':
              result = isFuture ? 'vuoden' : 'vuotta';
              break;
      }
      result = verbalNumber(number, isFuture) + ' ' + result;
      return result;
  }
  function verbalNumber(number, isFuture) {
      return number < 10
          ? isFuture
              ? numbersFuture[number]
              : numbersPast[number]
          : number;
  }

  hooks.defineLocale('fi', {
      months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split(
          '_'
      ),
      monthsShort: 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split(
          '_'
      ),
      weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split(
          '_'
      ),
      weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
      weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
      longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD.MM.YYYY',
          LL: 'Do MMMM[ta] YYYY',
          LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
          LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
          l: 'D.M.YYYY',
          ll: 'Do MMM YYYY',
          lll: 'Do MMM YYYY, [klo] HH.mm',
          llll: 'ddd, Do MMM YYYY, [klo] HH.mm',
      },
      calendar: {
          sameDay: '[tnn] [klo] LT',
          nextDay: '[huomenna] [klo] LT',
          nextWeek: 'dddd [klo] LT',
          lastDay: '[eilen] [klo] LT',
          lastWeek: '[viime] dddd[na] [klo] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s pst',
          past: '%s sitten',
          s: translate$2,
          ss: translate$2,
          m: translate$2,
          mm: translate$2,
          h: translate$2,
          hh: translate$2,
          d: translate$2,
          dd: translate$2,
          M: translate$2,
          MM: translate$2,
          y: translate$2,
          yy: translate$2,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('fil', {
      months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split(
          '_'
      ),
      monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
      weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split(
          '_'
      ),
      weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
      weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'MM/D/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY HH:mm',
          LLLL: 'dddd, MMMM DD, YYYY HH:mm',
      },
      calendar: {
          sameDay: 'LT [ngayong araw]',
          nextDay: '[Bukas ng] LT',
          nextWeek: 'LT [sa susunod na] dddd',
          lastDay: 'LT [kahapon]',
          lastWeek: 'LT [noong nakaraang] dddd',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'sa loob ng %s',
          past: '%s ang nakalipas',
          s: 'ilang segundo',
          ss: '%d segundo',
          m: 'isang minuto',
          mm: '%d minuto',
          h: 'isang oras',
          hh: '%d oras',
          d: 'isang araw',
          dd: '%d araw',
          M: 'isang buwan',
          MM: '%d buwan',
          y: 'isang taon',
          yy: '%d taon',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function (number) {
          return number;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('fo', {
      months: 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split(
          '_'
      ),
      monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
      weekdays: 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split(
          '_'
      ),
      weekdaysShort: 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
      weekdaysMin: 'su_m_t_mi_h_fr_le'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D. MMMM, YYYY HH:mm',
      },
      calendar: {
          sameDay: '[ dag kl.] LT',
          nextDay: '[ morgin kl.] LT',
          nextWeek: 'dddd [kl.] LT',
          lastDay: '[ gjr kl.] LT',
          lastWeek: '[sstu] dddd [kl] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'um %s',
          past: '%s sani',
          s: 'f sekund',
          ss: '%d sekundir',
          m: 'ein minuttur',
          mm: '%d minuttir',
          h: 'ein tmi',
          hh: '%d tmar',
          d: 'ein dagur',
          dd: '%d dagar',
          M: 'ein mnaur',
          MM: '%d mnair',
          y: 'eitt r',
          yy: '%d r',
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('fr-ca', {
      months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split(
          '_'
      ),
      monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
      weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
      weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Aujourdhui ] LT',
          nextDay: '[Demain ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[Hier ] LT',
          lastWeek: 'dddd [dernier ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'dans %s',
          past: 'il y a %s',
          s: 'quelques secondes',
          ss: '%d secondes',
          m: 'une minute',
          mm: '%d minutes',
          h: 'une heure',
          hh: '%d heures',
          d: 'un jour',
          dd: '%d jours',
          M: 'un mois',
          MM: '%d mois',
          y: 'un an',
          yy: '%d ans',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
      ordinal: function (number, period) {
          switch (period) {
              // Words with masculine grammatical gender: mois, trimestre, jour
              default:
              case 'M':
              case 'Q':
              case 'D':
              case 'DDD':
              case 'd':
                  return number + (number === 1 ? 'er' : 'e');

              // Words with feminine grammatical gender: semaine
              case 'w':
              case 'W':
                  return number + (number === 1 ? 're' : 'e');
          }
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('fr-ch', {
      months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split(
          '_'
      ),
      monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
      weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
      weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Aujourdhui ] LT',
          nextDay: '[Demain ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[Hier ] LT',
          lastWeek: 'dddd [dernier ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'dans %s',
          past: 'il y a %s',
          s: 'quelques secondes',
          ss: '%d secondes',
          m: 'une minute',
          mm: '%d minutes',
          h: 'une heure',
          hh: '%d heures',
          d: 'un jour',
          dd: '%d jours',
          M: 'un mois',
          MM: '%d mois',
          y: 'un an',
          yy: '%d ans',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
      ordinal: function (number, period) {
          switch (period) {
              // Words with masculine grammatical gender: mois, trimestre, jour
              default:
              case 'M':
              case 'Q':
              case 'D':
              case 'DDD':
              case 'd':
                  return number + (number === 1 ? 'er' : 'e');

              // Words with feminine grammatical gender: semaine
              case 'w':
              case 'W':
                  return number + (number === 1 ? 're' : 'e');
          }
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var monthsStrictRegex$1 = /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,
      monthsShortStrictRegex$1 = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i,
      monthsRegex$7 = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,
      monthsParse$6 = [
          /^janv/i,
          /^fvr/i,
          /^mars/i,
          /^avr/i,
          /^mai/i,
          /^juin/i,
          /^juil/i,
          /^aot/i,
          /^sept/i,
          /^oct/i,
          /^nov/i,
          /^dc/i,
      ];

  hooks.defineLocale('fr', {
      months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split(
          '_'
      ),
      monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split(
          '_'
      ),
      monthsRegex: monthsRegex$7,
      monthsShortRegex: monthsRegex$7,
      monthsStrictRegex: monthsStrictRegex$1,
      monthsShortStrictRegex: monthsShortStrictRegex$1,
      monthsParse: monthsParse$6,
      longMonthsParse: monthsParse$6,
      shortMonthsParse: monthsParse$6,
      weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
      weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
      weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Aujourdhui ] LT',
          nextDay: '[Demain ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[Hier ] LT',
          lastWeek: 'dddd [dernier ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'dans %s',
          past: 'il y a %s',
          s: 'quelques secondes',
          ss: '%d secondes',
          m: 'une minute',
          mm: '%d minutes',
          h: 'une heure',
          hh: '%d heures',
          d: 'un jour',
          dd: '%d jours',
          w: 'une semaine',
          ww: '%d semaines',
          M: 'un mois',
          MM: '%d mois',
          y: 'un an',
          yy: '%d ans',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
      ordinal: function (number, period) {
          switch (period) {
              // TODO: Return 'e' when day of month > 1. Move this case inside
              // block for masculine words below.
              // See https://github.com/moment/moment/issues/3375
              case 'D':
                  return number + (number === 1 ? 'er' : '');

              // Words with masculine grammatical gender: mois, trimestre, jour
              default:
              case 'M':
              case 'Q':
              case 'DDD':
              case 'd':
                  return number + (number === 1 ? 'er' : 'e');

              // Words with feminine grammatical gender: semaine
              case 'w':
              case 'W':
                  return number + (number === 1 ? 're' : 'e');
          }
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split(
          '_'
      ),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split(
          '_'
      );

  hooks.defineLocale('fy', {
      months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split(
          '_'
      ),
      monthsShort: function (m, format) {
          if (!m) {
              return monthsShortWithDots;
          } else if (/-MMM-/.test(format)) {
              return monthsShortWithoutDots[m.month()];
          } else {
              return monthsShortWithDots[m.month()];
          }
      },
      monthsParseExact: true,
      weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split(
          '_'
      ),
      weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
      weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD-MM-YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[hjoed om] LT',
          nextDay: '[moarn om] LT',
          nextWeek: 'dddd [om] LT',
          lastDay: '[juster om] LT',
          lastWeek: '[frne] dddd [om] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'oer %s',
          past: '%s lyn',
          s: 'in pear sekonden',
          ss: '%d sekonden',
          m: 'ien mint',
          mm: '%d minuten',
          h: 'ien oere',
          hh: '%d oeren',
          d: 'ien dei',
          dd: '%d dagen',
          M: 'ien moanne',
          MM: '%d moannen',
          y: 'ien jier',
          yy: '%d jierren',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function (number) {
          return (
              number +
              (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
          );
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var months$6 = [
          'Eanir',
          'Feabhra',
          'Mrta',
          'Aibren',
          'Bealtaine',
          'Meitheamh',
          'Iil',
          'Lnasa',
          'Men Fmhair',
          'Deireadh Fmhair',
          'Samhain',
          'Nollaig',
      ],
      monthsShort$5 = [
          'Ean',
          'Feabh',
          'Mrt',
          'Aib',
          'Beal',
          'Meith',
          'Iil',
          'Ln',
          'M.F.',
          'D.F.',
          'Samh',
          'Noll',
      ],
      weekdays$1 = [
          'D Domhnaigh',
          'D Luain',
          'D Mirt',
          'D Cadaoin',
          'Dardaoin',
          'D hAoine',
          'D Sathairn',
      ],
      weekdaysShort = ['Domh', 'Luan', 'Mirt', 'Cad', 'Dar', 'Aoine', 'Sath'],
      weekdaysMin = ['Do', 'Lu', 'M', 'C', 'D', 'A', 'Sa'];

  hooks.defineLocale('ga', {
      months: months$6,
      monthsShort: monthsShort$5,
      monthsParseExact: true,
      weekdays: weekdays$1,
      weekdaysShort: weekdaysShort,
      weekdaysMin: weekdaysMin,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Inniu ag] LT',
          nextDay: '[Amrach ag] LT',
          nextWeek: 'dddd [ag] LT',
          lastDay: '[Inn ag] LT',
          lastWeek: 'dddd [seo caite] [ag] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'i %s',
          past: '%s  shin',
          s: 'cpla soicind',
          ss: '%d soicind',
          m: 'nimad',
          mm: '%d nimad',
          h: 'uair an chloig',
          hh: '%d uair an chloig',
          d: 'l',
          dd: '%d l',
          M: 'm',
          MM: '%d monna',
          y: 'bliain',
          yy: '%d bliain',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
      ordinal: function (number) {
          var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var months$7 = [
          'Am Faoilleach',
          'An Gearran',
          'Am Mrt',
          'An Giblean',
          'An Citean',
          'An t-gmhios',
          'An t-Iuchar',
          'An Lnastal',
          'An t-Sultain',
          'An Dmhair',
          'An t-Samhain',
          'An Dbhlachd',
      ],
      monthsShort$6 = [
          'Faoi',
          'Gear',
          'Mrt',
          'Gibl',
          'Cit',
          'gmh',
          'Iuch',
          'Ln',
          'Sult',
          'Dmh',
          'Samh',
          'Dbh',
      ],
      weekdays$2 = [
          'Didmhnaich',
          'Diluain',
          'Dimirt',
          'Diciadain',
          'Diardaoin',
          'Dihaoine',
          'Disathairne',
      ],
      weekdaysShort$1 = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'],
      weekdaysMin$1 = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

  hooks.defineLocale('gd', {
      months: months$7,
      monthsShort: monthsShort$6,
      monthsParseExact: true,
      weekdays: weekdays$2,
      weekdaysShort: weekdaysShort$1,
      weekdaysMin: weekdaysMin$1,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[An-diugh aig] LT',
          nextDay: '[A-mireach aig] LT',
          nextWeek: 'dddd [aig] LT',
          lastDay: '[An-d aig] LT',
          lastWeek: 'dddd [seo chaidh] [aig] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'ann an %s',
          past: 'bho chionn %s',
          s: 'beagan diogan',
          ss: '%d diogan',
          m: 'mionaid',
          mm: '%d mionaidean',
          h: 'uair',
          hh: '%d uairean',
          d: 'latha',
          dd: '%d latha',
          M: 'mos',
          MM: '%d mosan',
          y: 'bliadhna',
          yy: '%d bliadhna',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
      ordinal: function (number) {
          var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('gl', {
      months: 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split(
          '_'
      ),
      monthsShort: 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
      weekdaysShort: 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
      weekdaysMin: 'do_lu_ma_m_xo_ve_s'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY H:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
      },
      calendar: {
          sameDay: function () {
              return '[hoxe ' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextDay: function () {
              return '[ma ' + (this.hours() !== 1 ? 's' : '') + '] LT';
          },
          nextWeek: function () {
              return 'dddd [' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
          },
          lastDay: function () {
              return '[onte ' + (this.hours() !== 1 ? '' : 'a') + '] LT';
          },
          lastWeek: function () {
              return (
                  '[o] dddd [pasado ' + (this.hours() !== 1 ? 's' : 'a') + '] LT'
              );
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: function (str) {
              if (str.indexOf('un') === 0) {
                  return 'n' + str;
              }
              return 'en ' + str;
          },
          past: 'hai %s',
          s: 'uns segundos',
          ss: '%d segundos',
          m: 'un minuto',
          mm: '%d minutos',
          h: 'unha hora',
          hh: '%d horas',
          d: 'un da',
          dd: '%d das',
          M: 'un mes',
          MM: '%d meses',
          y: 'un ano',
          yy: '%d anos',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function processRelativeTime$4(number, withoutSuffix, key, isFuture) {
      var format = {
          s: [' ', ' '],
          ss: [number + ' ', number + ' '],
          m: [' ', ' '],
          mm: [number + ' ', number + ' '],
          h: [' ', ' '],
          hh: [number + ' ', number + ' '],
          d: [' ', ' '],
          dd: [number + ' ', number + ' '],
          M: [' ', ' '],
          MM: [number + ' ', number + ' '],
          y: [' ', ' '],
          yy: [number + ' ', number + ' '],
      };
      return isFuture ? format[key][0] : format[key][1];
  }

  hooks.defineLocale('gom-deva', {
      months: {
          standalone: '___________'.split(
              '_'
          ),
          format: '___________'.split(
              '_'
          ),
          isFormat: /MMMM(\s)+D[oD]?/,
      },
      monthsShort: '._.__.___._._._._._.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: '______'.split('_'),
      weekdaysShort: '._._._._._._.'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'A h:mm []',
          LTS: 'A h:mm:ss []',
          L: 'DD-MM-YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY A h:mm []',
          LLLL: 'dddd, MMMM Do, YYYY, A h:mm []',
          llll: 'ddd, D MMM YYYY, A h:mm []',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: '[] dddd[,] LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd[,] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s',
          past: '%s ',
          s: processRelativeTime$4,
          ss: processRelativeTime$4,
          m: processRelativeTime$4,
          mm: processRelativeTime$4,
          h: processRelativeTime$4,
          hh: processRelativeTime$4,
          d: processRelativeTime$4,
          dd: processRelativeTime$4,
          M: processRelativeTime$4,
          MM: processRelativeTime$4,
          y: processRelativeTime$4,
          yy: processRelativeTime$4,
      },
      dayOfMonthOrdinalParse: /\d{1,2}()/,
      ordinal: function (number, period) {
          switch (period) {
              // the ordinal '' only applies to day of the month
              case 'D':
                  return number + '';
              default:
              case 'M':
              case 'Q':
              case 'DDD':
              case 'd':
              case 'w':
              case 'W':
                  return number;
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week
          doy: 3, // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
      },
      meridiemParse: /|||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '') {
              return hour < 4 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour > 12 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 12) {
              return '';
          } else if (hour < 16) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
  });

  //! moment.js locale configuration

  function processRelativeTime$5(number, withoutSuffix, key, isFuture) {
      var format = {
          s: ['thoddea sekondamni', 'thodde sekond'],
          ss: [number + ' sekondamni', number + ' sekond'],
          m: ['eka mintan', 'ek minut'],
          mm: [number + ' mintamni', number + ' mintam'],
          h: ['eka voran', 'ek vor'],
          hh: [number + ' voramni', number + ' voram'],
          d: ['eka disan', 'ek dis'],
          dd: [number + ' disamni', number + ' dis'],
          M: ['eka mhoinean', 'ek mhoino'],
          MM: [number + ' mhoineamni', number + ' mhoine'],
          y: ['eka vorsan', 'ek voros'],
          yy: [number + ' vorsamni', number + ' vorsam'],
      };
      return isFuture ? format[key][0] : format[key][1];
  }

  hooks.defineLocale('gom-latn', {
      months: {
          standalone: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split(
              '_'
          ),
          format: 'Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea'.split(
              '_'
          ),
          isFormat: /MMMM(\s)+D[oD]?/,
      },
      monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split('_'),
      weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
      weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'A h:mm [vazta]',
          LTS: 'A h:mm:ss [vazta]',
          L: 'DD-MM-YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY A h:mm [vazta]',
          LLLL: 'dddd, MMMM Do, YYYY, A h:mm [vazta]',
          llll: 'ddd, D MMM YYYY, A h:mm [vazta]',
      },
      calendar: {
          sameDay: '[Aiz] LT',
          nextDay: '[Faleam] LT',
          nextWeek: '[Fuddlo] dddd[,] LT',
          lastDay: '[Kal] LT',
          lastWeek: '[Fattlo] dddd[,] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s',
          past: '%s adim',
          s: processRelativeTime$5,
          ss: processRelativeTime$5,
          m: processRelativeTime$5,
          mm: processRelativeTime$5,
          h: processRelativeTime$5,
          hh: processRelativeTime$5,
          d: processRelativeTime$5,
          dd: processRelativeTime$5,
          M: processRelativeTime$5,
          MM: processRelativeTime$5,
          y: processRelativeTime$5,
          yy: processRelativeTime$5,
      },
      dayOfMonthOrdinalParse: /\d{1,2}(er)/,
      ordinal: function (number, period) {
          switch (period) {
              // the ordinal 'er' only applies to day of the month
              case 'D':
                  return number + 'er';
              default:
              case 'M':
              case 'Q':
              case 'DDD':
              case 'd':
              case 'w':
              case 'W':
                  return number;
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week
          doy: 3, // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
      },
      meridiemParse: /rati|sokallim|donparam|sanje/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === 'rati') {
              return hour < 4 ? hour : hour + 12;
          } else if (meridiem === 'sokallim') {
              return hour;
          } else if (meridiem === 'donparam') {
              return hour > 12 ? hour : hour + 12;
          } else if (meridiem === 'sanje') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return 'rati';
          } else if (hour < 12) {
              return 'sokallim';
          } else if (hour < 16) {
              return 'donparam';
          } else if (hour < 20) {
              return 'sanje';
          } else {
              return 'rati';
          }
      },
  });

  //! moment.js locale configuration

  var symbolMap$7 = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$6 = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('gu', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '._.__.___._._._._._.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm ',
          LTS: 'A h:mm:ss ',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm ',
          LLLL: 'dddd, D MMMM YYYY, A h:mm ',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$6[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$7[match];
          });
      },
      // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
      // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
      meridiemParse: /|||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '') {
              return hour < 4 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 10) {
              return '';
          } else if (hour < 17) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('he', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D []MMMM YYYY',
          LLL: 'D []MMMM YYYY HH:mm',
          LLLL: 'dddd, D []MMMM YYYY HH:mm',
          l: 'D/M/YYYY',
          ll: 'D MMM YYYY',
          lll: 'D MMM YYYY HH:mm',
          llll: 'ddd, D MMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[ ]LT',
          nextDay: '[ ]LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[ ]LT',
          lastWeek: '[] dddd [ ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: ' ',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: function (number) {
              if (number === 2) {
                  return '';
              }
              return number + ' ';
          },
          d: '',
          dd: function (number) {
              if (number === 2) {
                  return '';
              }
              return number + ' ';
          },
          M: '',
          MM: function (number) {
              if (number === 2) {
                  return '';
              }
              return number + ' ';
          },
          y: '',
          yy: function (number) {
              if (number === 2) {
                  return '';
              } else if (number % 10 === 0 && number !== 10) {
                  return number + ' ';
              }
              return number + ' ';
          },
      },
      meridiemParse: /"|"| | | ||/i,
      isPM: function (input) {
          return /^("| |)$/.test(input);
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 5) {
              return ' ';
          } else if (hour < 10) {
              return '';
          } else if (hour < 12) {
              return isLower ? '"' : ' ';
          } else if (hour < 18) {
              return isLower ? '"' : ' ';
          } else {
              return '';
          }
      },
  });

  //! moment.js locale configuration

  var symbolMap$8 = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$7 = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      },
      monthsParse$7 = [
          /^/i,
          /^|/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^|/i,
          /^/i,
          /^|/i,
          /^|/i,
      ],
      shortMonthsParse = [
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
          /^/i,
      ];

  hooks.defineLocale('hi', {
      months: {
          format: '___________'.split(
              '_'
          ),
          standalone: '___________'.split(
              '_'
          ),
      },
      monthsShort: '._.__.___._._._._._.'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm ',
          LTS: 'A h:mm:ss ',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm ',
          LLLL: 'dddd, D MMMM YYYY, A h:mm ',
      },

      monthsParse: monthsParse$7,
      longMonthsParse: monthsParse$7,
      shortMonthsParse: shortMonthsParse,

      monthsRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,

      monthsShortRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,

      monthsStrictRegex: /^(?||?|?|?|?|?|?|?|||?\.?||\.?||?||?)/i,

      monthsShortStrictRegex: /^(\.?|\.?|?|\.?|?|?|\.?|\.?|\.?|\.?|\.?|\.?)/i,

      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: '  ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$7[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$8[match];
          });
      },
      // Hindi notation for meridiems are quite fuzzy in practice. While there exists
      // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
      meridiemParse: /|||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '') {
              return hour < 4 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 10) {
              return '';
          } else if (hour < 17) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function translate$3(number, withoutSuffix, key) {
      var result = number + ' ';
      switch (key) {
          case 'ss':
              if (number === 1) {
                  result += 'sekunda';
              } else if (number === 2 || number === 3 || number === 4) {
                  result += 'sekunde';
              } else {
                  result += 'sekundi';
              }
              return result;
          case 'm':
              return withoutSuffix ? 'jedna minuta' : 'jedne minute';
          case 'mm':
              if (number === 1) {
                  result += 'minuta';
              } else if (number === 2 || number === 3 || number === 4) {
                  result += 'minute';
              } else {
                  result += 'minuta';
              }
              return result;
          case 'h':
              return withoutSuffix ? 'jedan sat' : 'jednog sata';
          case 'hh':
              if (number === 1) {
                  result += 'sat';
              } else if (number === 2 || number === 3 || number === 4) {
                  result += 'sata';
              } else {
                  result += 'sati';
              }
              return result;
          case 'dd':
              if (number === 1) {
                  result += 'dan';
              } else {
                  result += 'dana';
              }
              return result;
          case 'MM':
              if (number === 1) {
                  result += 'mjesec';
              } else if (number === 2 || number === 3 || number === 4) {
                  result += 'mjeseca';
              } else {
                  result += 'mjeseci';
              }
              return result;
          case 'yy':
              if (number === 1) {
                  result += 'godina';
              } else if (number === 2 || number === 3 || number === 4) {
                  result += 'godine';
              } else {
                  result += 'godina';
              }
              return result;
      }
  }

  hooks.defineLocale('hr', {
      months: {
          format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split(
              '_'
          ),
          standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split(
              '_'
          ),
      },
      monthsShort: 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split(
          '_'
      ),
      weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
      weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'Do MMMM YYYY',
          LLL: 'Do MMMM YYYY H:mm',
          LLLL: 'dddd, Do MMMM YYYY H:mm',
      },
      calendar: {
          sameDay: '[danas u] LT',
          nextDay: '[sutra u] LT',
          nextWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[u] [nedjelju] [u] LT';
                  case 3:
                      return '[u] [srijedu] [u] LT';
                  case 6:
                      return '[u] [subotu] [u] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[u] dddd [u] LT';
              }
          },
          lastDay: '[juer u] LT',
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[prolu] [nedjelju] [u] LT';
                  case 3:
                      return '[prolu] [srijedu] [u] LT';
                  case 6:
                      return '[prole] [subote] [u] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[proli] dddd [u] LT';
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'za %s',
          past: 'prije %s',
          s: 'par sekundi',
          ss: translate$3,
          m: translate$3,
          mm: translate$3,
          h: translate$3,
          hh: translate$3,
          d: 'dan',
          dd: translate$3,
          M: 'mjesec',
          MM: translate$3,
          y: 'godinu',
          yy: translate$3,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(
      ' '
  );
  function translate$4(number, withoutSuffix, key, isFuture) {
      var num = number;
      switch (key) {
          case 's':
              return isFuture || withoutSuffix
                  ? 'nhny msodperc'
                  : 'nhny msodperce';
          case 'ss':
              return num + (isFuture || withoutSuffix)
                  ? ' msodperc'
                  : ' msodperce';
          case 'm':
              return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
          case 'mm':
              return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
          case 'h':
              return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
          case 'hh':
              return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
          case 'd':
              return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
          case 'dd':
              return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
          case 'M':
              return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
          case 'MM':
              return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
          case 'y':
              return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
          case 'yy':
              return num + (isFuture || withoutSuffix ? ' v' : ' ve');
      }
      return '';
  }
  function week(isFuture) {
      return (
          (isFuture ? '' : '[mlt] ') +
          '[' +
          weekEndings[this.day()] +
          '] LT[-kor]'
      );
  }

  hooks.defineLocale('hu', {
      months: 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split(
          '_'
      ),
      monthsShort: 'jan._feb._mrc._pr._mj._jn._jl._aug._szept._okt._nov._dec.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
      weekdaysShort: 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
      weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'YYYY.MM.DD.',
          LL: 'YYYY. MMMM D.',
          LLL: 'YYYY. MMMM D. H:mm',
          LLLL: 'YYYY. MMMM D., dddd H:mm',
      },
      meridiemParse: /de|du/i,
      isPM: function (input) {
          return input.charAt(1).toLowerCase() === 'u';
      },
      meridiem: function (hours, minutes, isLower) {
          if (hours < 12) {
              return isLower === true ? 'de' : 'DE';
          } else {
              return isLower === true ? 'du' : 'DU';
          }
      },
      calendar: {
          sameDay: '[ma] LT[-kor]',
          nextDay: '[holnap] LT[-kor]',
          nextWeek: function () {
              return week.call(this, true);
          },
          lastDay: '[tegnap] LT[-kor]',
          lastWeek: function () {
              return week.call(this, false);
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s mlva',
          past: '%s',
          s: translate$4,
          ss: translate$4,
          m: translate$4,
          mm: translate$4,
          h: translate$4,
          hh: translate$4,
          d: translate$4,
          dd: translate$4,
          M: translate$4,
          MM: translate$4,
          y: translate$4,
          yy: translate$4,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('hy-am', {
      months: {
          format: '___________'.split(
              '_'
          ),
          standalone: '___________'.split(
              '_'
          ),
      },
      monthsShort: '___________'.split('_'),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY .',
          LLL: 'D MMMM YYYY ., HH:mm',
          LLLL: 'dddd, D MMMM YYYY ., HH:mm',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          lastDay: '[] LT',
          nextWeek: function () {
              return 'dddd [ ] LT';
          },
          lastWeek: function () {
              return '[] dddd [ ] LT';
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: '  ',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d ',
          M: '',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      meridiemParse: /|||/,
      isPM: function (input) {
          return /^(|)$/.test(input);
      },
      meridiem: function (hour) {
          if (hour < 4) {
              return '';
          } else if (hour < 12) {
              return '';
          } else if (hour < 17) {
              return '';
          } else {
              return '';
          }
      },
      dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
      ordinal: function (number, period) {
          switch (period) {
              case 'DDD':
              case 'w':
              case 'W':
              case 'DDDo':
                  if (number === 1) {
                      return number + '-';
                  }
                  return number + '-';
              default:
                  return number;
          }
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('id', {
      months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
      weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
      weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
      weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
      longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
      },
      meridiemParse: /pagi|siang|sore|malam/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === 'pagi') {
              return hour;
          } else if (meridiem === 'siang') {
              return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === 'sore' || meridiem === 'malam') {
              return hour + 12;
          }
      },
      meridiem: function (hours, minutes, isLower) {
          if (hours < 11) {
              return 'pagi';
          } else if (hours < 15) {
              return 'siang';
          } else if (hours < 19) {
              return 'sore';
          } else {
              return 'malam';
          }
      },
      calendar: {
          sameDay: '[Hari ini pukul] LT',
          nextDay: '[Besok pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kemarin pukul] LT',
          lastWeek: 'dddd [lalu pukul] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'dalam %s',
          past: '%s yang lalu',
          s: 'beberapa detik',
          ss: '%d detik',
          m: 'semenit',
          mm: '%d menit',
          h: 'sejam',
          hh: '%d jam',
          d: 'sehari',
          dd: '%d hari',
          M: 'sebulan',
          MM: '%d bulan',
          y: 'setahun',
          yy: '%d tahun',
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function plural$2(n) {
      if (n % 100 === 11) {
          return true;
      } else if (n % 10 === 1) {
          return false;
      }
      return true;
  }
  function translate$5(number, withoutSuffix, key, isFuture) {
      var result = number + ' ';
      switch (key) {
          case 's':
              return withoutSuffix || isFuture
                  ? 'nokkrar sekndur'
                  : 'nokkrum sekndum';
          case 'ss':
              if (plural$2(number)) {
                  return (
                      result +
                      (withoutSuffix || isFuture ? 'sekndur' : 'sekndum')
                  );
              }
              return result + 'seknda';
          case 'm':
              return withoutSuffix ? 'mnta' : 'mntu';
          case 'mm':
              if (plural$2(number)) {
                  return (
                      result + (withoutSuffix || isFuture ? 'mntur' : 'mntum')
                  );
              } else if (withoutSuffix) {
                  return result + 'mnta';
              }
              return result + 'mntu';
          case 'hh':
              if (plural$2(number)) {
                  return (
                      result +
                      (withoutSuffix || isFuture
                          ? 'klukkustundir'
                          : 'klukkustundum')
                  );
              }
              return result + 'klukkustund';
          case 'd':
              if (withoutSuffix) {
                  return 'dagur';
              }
              return isFuture ? 'dag' : 'degi';
          case 'dd':
              if (plural$2(number)) {
                  if (withoutSuffix) {
                      return result + 'dagar';
                  }
                  return result + (isFuture ? 'daga' : 'dgum');
              } else if (withoutSuffix) {
                  return result + 'dagur';
              }
              return result + (isFuture ? 'dag' : 'degi');
          case 'M':
              if (withoutSuffix) {
                  return 'mnuur';
              }
              return isFuture ? 'mnu' : 'mnui';
          case 'MM':
              if (plural$2(number)) {
                  if (withoutSuffix) {
                      return result + 'mnuir';
                  }
                  return result + (isFuture ? 'mnui' : 'mnuum');
              } else if (withoutSuffix) {
                  return result + 'mnuur';
              }
              return result + (isFuture ? 'mnu' : 'mnui');
          case 'y':
              return withoutSuffix || isFuture ? 'r' : 'ri';
          case 'yy':
              if (plural$2(number)) {
                  return result + (withoutSuffix || isFuture ? 'r' : 'rum');
              }
              return result + (withoutSuffix || isFuture ? 'r' : 'ri');
      }
  }

  hooks.defineLocale('is', {
      months: 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split(
          '_'
      ),
      monthsShort: 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
      weekdays: 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split(
          '_'
      ),
      weekdaysShort: 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
      weekdaysMin: 'Su_M_r_Mi_Fi_F_La'.split('_'),
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY [kl.] H:mm',
          LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm',
      },
      calendar: {
          sameDay: '[ dag kl.] LT',
          nextDay: '[ morgun kl.] LT',
          nextWeek: 'dddd [kl.] LT',
          lastDay: '[ gr kl.] LT',
          lastWeek: '[sasta] dddd [kl.] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'eftir %s',
          past: 'fyrir %s san',
          s: translate$5,
          ss: translate$5,
          m: translate$5,
          mm: translate$5,
          h: 'klukkustund',
          hh: translate$5,
          d: translate$5,
          dd: translate$5,
          M: translate$5,
          MM: translate$5,
          y: translate$5,
          yy: translate$5,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('it-ch', {
      months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
          '_'
      ),
      monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
      weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split(
          '_'
      ),
      weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
      weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Oggi alle] LT',
          nextDay: '[Domani alle] LT',
          nextWeek: 'dddd [alle] LT',
          lastDay: '[Ieri alle] LT',
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[la scorsa] dddd [alle] LT';
                  default:
                      return '[lo scorso] dddd [alle] LT';
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: function (s) {
              return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
          },
          past: '%s fa',
          s: 'alcuni secondi',
          ss: '%d secondi',
          m: 'un minuto',
          mm: '%d minuti',
          h: "un'ora",
          hh: '%d ore',
          d: 'un giorno',
          dd: '%d giorni',
          M: 'un mese',
          MM: '%d mesi',
          y: 'un anno',
          yy: '%d anni',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('it', {
      months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
          '_'
      ),
      monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
      weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split(
          '_'
      ),
      weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
      weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: function () {
              return (
                  '[Oggi a' +
                  (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                  ']LT'
              );
          },
          nextDay: function () {
              return (
                  '[Domani a' +
                  (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                  ']LT'
              );
          },
          nextWeek: function () {
              return (
                  'dddd [a' +
                  (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                  ']LT'
              );
          },
          lastDay: function () {
              return (
                  '[Ieri a' +
                  (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                  ']LT'
              );
          },
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                      return (
                          '[La scorsa] dddd [a' +
                          (this.hours() > 1
                              ? 'lle '
                              : this.hours() === 0
                              ? ' '
                              : "ll'") +
                          ']LT'
                      );
                  default:
                      return (
                          '[Lo scorso] dddd [a' +
                          (this.hours() > 1
                              ? 'lle '
                              : this.hours() === 0
                              ? ' '
                              : "ll'") +
                          ']LT'
                      );
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'tra %s',
          past: '%s fa',
          s: 'alcuni secondi',
          ss: '%d secondi',
          m: 'un minuto',
          mm: '%d minuti',
          h: "un'ora",
          hh: '%d ore',
          d: 'un giorno',
          dd: '%d giorni',
          w: 'una settimana',
          ww: '%d settimane',
          M: 'un mese',
          MM: '%d mesi',
          y: 'un anno',
          yy: '%d anni',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ja', {
      eras: [
          {
              since: '2019-05-01',
              offset: 1,
              name: '',
              narrow: '',
              abbr: 'R',
          },
          {
              since: '1989-01-08',
              until: '2019-04-30',
              offset: 1,
              name: '',
              narrow: '',
              abbr: 'H',
          },
          {
              since: '1926-12-25',
              until: '1989-01-07',
              offset: 1,
              name: '',
              narrow: '',
              abbr: 'S',
          },
          {
              since: '1912-07-30',
              until: '1926-12-24',
              offset: 1,
              name: '',
              narrow: '',
              abbr: 'T',
          },
          {
              since: '1873-01-01',
              until: '1912-07-29',
              offset: 6,
              name: '',
              narrow: '',
              abbr: 'M',
          },
          {
              since: '0001-01-01',
              until: '1873-12-31',
              offset: 1,
              name: '',
              narrow: 'AD',
              abbr: 'AD',
          },
          {
              since: '0000-12-31',
              until: -Infinity,
              offset: 1,
              name: '',
              narrow: 'BC',
              abbr: 'BC',
          },
      ],
      eraYearOrdinalRegex: /(|\d+)/,
      eraYearOrdinalParse: function (input, match) {
          return match[1] === '' ? 1 : parseInt(match[1] || input, 10);
      },
      months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
      monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYYMD',
          LLL: 'YYYYMD HH:mm',
          LLLL: 'YYYYMD dddd HH:mm',
          l: 'YYYY/MM/DD',
          ll: 'YYYYMD',
          lll: 'YYYYMD HH:mm',
          llll: 'YYYYMD(ddd) HH:mm',
      },
      meridiemParse: /|/i,
      isPM: function (input) {
          return input === '';
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: function (now) {
              if (now.week() !== this.week()) {
                  return '[]dddd LT';
              } else {
                  return 'dddd LT';
              }
          },
          lastDay: '[] LT',
          lastWeek: function (now) {
              if (this.week() !== now.week()) {
                  return '[]dddd LT';
              } else {
                  return 'dddd LT';
              }
          },
          sameElse: 'L',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function (number, period) {
          switch (period) {
              case 'y':
                  return number === 1 ? '' : number + '';
              case 'd':
              case 'D':
              case 'DDD':
                  return number + '';
              default:
                  return number;
          }
      },
      relativeTime: {
          future: '%s',
          past: '%s',
          s: '',
          ss: '%d',
          m: '1',
          mm: '%d',
          h: '1',
          hh: '%d',
          d: '1',
          dd: '%d',
          M: '1',
          MM: '%d',
          y: '1',
          yy: '%d',
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('jv', {
      months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
      weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
      weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
      weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
      longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
      },
      meridiemParse: /enjing|siyang|sonten|ndalu/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === 'enjing') {
              return hour;
          } else if (meridiem === 'siyang') {
              return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
              return hour + 12;
          }
      },
      meridiem: function (hours, minutes, isLower) {
          if (hours < 11) {
              return 'enjing';
          } else if (hours < 15) {
              return 'siyang';
          } else if (hours < 19) {
              return 'sonten';
          } else {
              return 'ndalu';
          }
      },
      calendar: {
          sameDay: '[Dinten puniko pukul] LT',
          nextDay: '[Mbenjang pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kala wingi pukul] LT',
          lastWeek: 'dddd [kepengker pukul] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'wonten ing %s',
          past: '%s ingkang kepengker',
          s: 'sawetawis detik',
          ss: '%d detik',
          m: 'setunggal menit',
          mm: '%d menit',
          h: 'setunggal jam',
          hh: '%d jam',
          d: 'sedinten',
          dd: '%d dinten',
          M: 'sewulan',
          MM: '%d wulan',
          y: 'setaun',
          yy: '%d taun',
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ka', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split('_'),
      weekdays: {
          standalone: '______'.split(
              '_'
          ),
          format: '______'.split(
              '_'
          ),
          isFormat: /(|)/,
      },
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[] LT[-]',
          nextDay: '[] LT[-]',
          lastDay: '[] LT[-]',
          nextWeek: '[] dddd LT[-]',
          lastWeek: '[] dddd LT-',
          sameElse: 'L',
      },
      relativeTime: {
          future: function (s) {
              return s.replace(/(|||||)(|)/, function (
                  $0,
                  $1,
                  $2
              ) {
                  return $2 === '' ? $1 + '' : $1 + $2 + '';
              });
          },
          past: function (s) {
              if (/(||||)/.test(s)) {
                  return s.replace(/(|)$/, ' ');
              }
              if (//.test(s)) {
                  return s.replace(/$/, ' ');
              }
              return s;
          },
          s: ' ',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d ',
          M: '',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
      ordinal: function (number) {
          if (number === 0) {
              return number;
          }
          if (number === 1) {
              return number + '-';
          }
          if (
              number < 20 ||
              (number <= 100 && number % 20 === 0) ||
              number % 100 === 0
          ) {
              return '-' + number;
          }
          return number + '-';
      },
      week: {
          dow: 1,
          doy: 7,
      },
  });

  //! moment.js locale configuration

  var suffixes$1 = {
      0: '-',
      1: '-',
      2: '-',
      3: '-',
      4: '-',
      5: '-',
      6: '-',
      7: '-',
      8: '-',
      9: '-',
      10: '-',
      20: '-',
      30: '-',
      40: '-',
      50: '-',
      60: '-',
      70: '-',
      80: '-',
      90: '-',
      100: '-',
  };

  hooks.defineLocale('kk', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split('_'),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[ ] LT',
          lastWeek: '[ ] dddd [] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
      ordinal: function (number) {
          var a = number % 10,
              b = number >= 100 ? 100 : null;
          return number + (suffixes$1[number] || suffixes$1[a] || suffixes$1[b]);
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$9 = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$8 = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('km', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return input === '';
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[ ] LT',
          lastWeek: 'dddd [] [] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s',
          past: '%s',
          s: '',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d ',
          M: '',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$8[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$9[match];
          });
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$a = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$9 = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('kn', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm',
          LTS: 'A h:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm',
          LLLL: 'dddd, D MMMM YYYY, A h:mm',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$9[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$a[match];
          });
      },
      meridiemParse: /|||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '') {
              return hour < 4 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 10) {
              return '';
          } else if (hour < 17) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
      dayOfMonthOrdinalParse: /\d{1,2}()/,
      ordinal: function (number) {
          return number + '';
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ko', {
      months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
      monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm',
          LTS: 'A h:mm:ss',
          L: 'YYYY.MM.DD.',
          LL: 'YYYY MMMM D',
          LLL: 'YYYY MMMM D A h:mm',
          LLLL: 'YYYY MMMM D dddd A h:mm',
          l: 'YYYY.MM.DD.',
          ll: 'YYYY MMMM D',
          lll: 'YYYY MMMM D A h:mm',
          llll: 'YYYY MMMM D dddd A h:mm',
      },
      calendar: {
          sameDay: ' LT',
          nextDay: ' LT',
          nextWeek: 'dddd LT',
          lastDay: ' LT',
          lastWeek: ' dddd LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d',
          m: '1',
          mm: '%d',
          h: ' ',
          hh: '%d',
          d: '',
          dd: '%d',
          M: ' ',
          MM: '%d',
          y: ' ',
          yy: '%d',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(||)/,
      ordinal: function (number, period) {
          switch (period) {
              case 'd':
              case 'D':
              case 'DDD':
                  return number + '';
              case 'M':
                  return number + '';
              case 'w':
              case 'W':
                  return number + '';
              default:
                  return number;
          }
      },
      meridiemParse: /|/,
      isPM: function (token) {
          return token === '';
      },
      meridiem: function (hour, minute, isUpper) {
          return hour < 12 ? '' : '';
      },
  });

  //! moment.js locale configuration

  var symbolMap$b = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$a = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      },
      months$8 = [
          ' ',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          ' ',
          ' ',
          ' ',
      ];

  hooks.defineLocale('ku', {
      months: months$8,
      monthsShort: months$8,
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split(
          '_'
      ),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return //.test(input);
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[ ] LT',
          lastWeek: 'dddd [] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: '%s',
          s: ' ',
          ss: ' %d',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      preparse: function (string) {
          return string
              .replace(/[]/g, function (match) {
                  return numberMap$a[match];
              })
              .replace(//g, ',');
      },
      postformat: function (string) {
          return string
              .replace(/\d/g, function (match) {
                  return symbolMap$b[match];
              })
              .replace(/,/g, '');
      },
      week: {
          dow: 6, // Saturday is the first day of the week.
          doy: 12, // The week that contains Jan 12th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var suffixes$2 = {
      0: '-',
      1: '-',
      2: '-',
      3: '-',
      4: '-',
      5: '-',
      6: '-',
      7: '-',
      8: '-',
      9: '-',
      10: '-',
      20: '-',
      30: '-',
      40: '-',
      50: '-',
      60: '-',
      70: '-',
      80: '-',
      90: '-',
      100: '-',
  };

  hooks.defineLocale('ky', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[ ] LT',
          lastWeek: '[ ] dddd [] [] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
      ordinal: function (number) {
          var a = number % 10,
              b = number >= 100 ? 100 : null;
          return number + (suffixes$2[number] || suffixes$2[a] || suffixes$2[b]);
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function processRelativeTime$6(number, withoutSuffix, key, isFuture) {
      var format = {
          m: ['eng Minutt', 'enger Minutt'],
          h: ['eng Stonn', 'enger Stonn'],
          d: ['een Dag', 'engem Dag'],
          M: ['ee Mount', 'engem Mount'],
          y: ['ee Joer', 'engem Joer'],
      };
      return withoutSuffix ? format[key][0] : format[key][1];
  }
  function processFutureTime(string) {
      var number = string.substr(0, string.indexOf(' '));
      if (eifelerRegelAppliesToNumber(number)) {
          return 'a ' + string;
      }
      return 'an ' + string;
  }
  function processPastTime(string) {
      var number = string.substr(0, string.indexOf(' '));
      if (eifelerRegelAppliesToNumber(number)) {
          return 'viru ' + string;
      }
      return 'virun ' + string;
  }
  /**
   * Returns true if the word before the given number loses the '-n' ending.
   * e.g. 'an 10 Deeg' but 'a 5 Deeg'
   *
   * @param number {integer}
   * @returns {boolean}
   */
  function eifelerRegelAppliesToNumber(number) {
      number = parseInt(number, 10);
      if (isNaN(number)) {
          return false;
      }
      if (number < 0) {
          // Negative Number --> always true
          return true;
      } else if (number < 10) {
          // Only 1 digit
          if (4 <= number && number <= 7) {
              return true;
          }
          return false;
      } else if (number < 100) {
          // 2 digits
          var lastDigit = number % 10,
              firstDigit = number / 10;
          if (lastDigit === 0) {
              return eifelerRegelAppliesToNumber(firstDigit);
          }
          return eifelerRegelAppliesToNumber(lastDigit);
      } else if (number < 10000) {
          // 3 or 4 digits --> recursively check first digit
          while (number >= 10) {
              number = number / 10;
          }
          return eifelerRegelAppliesToNumber(number);
      } else {
          // Anything larger than 4 digits: recursively check first n-3 digits
          number = number / 1000;
          return eifelerRegelAppliesToNumber(number);
      }
  }

  hooks.defineLocale('lb', {
      months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split(
          '_'
      ),
      monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split(
          '_'
      ),
      weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
      weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm [Auer]',
          LTS: 'H:mm:ss [Auer]',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm [Auer]',
          LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]',
      },
      calendar: {
          sameDay: '[Haut um] LT',
          sameElse: 'L',
          nextDay: '[Muer um] LT',
          nextWeek: 'dddd [um] LT',
          lastDay: '[Gschter um] LT',
          lastWeek: function () {
              // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
              switch (this.day()) {
                  case 2:
                  case 4:
                      return '[Leschten] dddd [um] LT';
                  default:
                      return '[Leschte] dddd [um] LT';
              }
          },
      },
      relativeTime: {
          future: processFutureTime,
          past: processPastTime,
          s: 'e puer Sekonnen',
          ss: '%d Sekonnen',
          m: processRelativeTime$6,
          mm: '%d Minutten',
          h: processRelativeTime$6,
          hh: '%d Stonnen',
          d: processRelativeTime$6,
          dd: '%d Deeg',
          M: processRelativeTime$6,
          MM: '%d Mint',
          y: processRelativeTime$6,
          yy: '%d Joer',
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('lo', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return input === '';
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: '[]dddd[] LT',
          lastDay: '[] LT',
          lastWeek: '[]dddd[] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: '%s',
          s: '',
          ss: '%d ',
          m: '1 ',
          mm: '%d ',
          h: '1 ',
          hh: '%d ',
          d: '1 ',
          dd: '%d ',
          M: '1 ',
          MM: '%d ',
          y: '1 ',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /()\d{1,2}/,
      ordinal: function (number) {
          return '' + number;
      },
  });

  //! moment.js locale configuration

  var units = {
      ss: 'sekund_sekundi_sekundes',
      m: 'minut_minuts_minut',
      mm: 'minuts_minui_minutes',
      h: 'valanda_valandos_valand',
      hh: 'valandos_valand_valandas',
      d: 'diena_dienos_dien',
      dd: 'dienos_dien_dienas',
      M: 'mnuo_mnesio_mnes',
      MM: 'mnesiai_mnesi_mnesius',
      y: 'metai_met_metus',
      yy: 'metai_met_metus',
  };
  function translateSeconds(number, withoutSuffix, key, isFuture) {
      if (withoutSuffix) {
          return 'kelios sekunds';
      } else {
          return isFuture ? 'keli sekundi' : 'kelias sekundes';
      }
  }
  function translateSingular(number, withoutSuffix, key, isFuture) {
      return withoutSuffix
          ? forms(key)[0]
          : isFuture
          ? forms(key)[1]
          : forms(key)[2];
  }
  function special(number) {
      return number % 10 === 0 || (number > 10 && number < 20);
  }
  function forms(key) {
      return units[key].split('_');
  }
  function translate$6(number, withoutSuffix, key, isFuture) {
      var result = number + ' ';
      if (number === 1) {
          return (
              result + translateSingular(number, withoutSuffix, key[0], isFuture)
          );
      } else if (withoutSuffix) {
          return result + (special(number) ? forms(key)[1] : forms(key)[0]);
      } else {
          if (isFuture) {
              return result + forms(key)[1];
          } else {
              return result + (special(number) ? forms(key)[1] : forms(key)[2]);
          }
      }
  }
  hooks.defineLocale('lt', {
      months: {
          format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split(
              '_'
          ),
          standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split(
              '_'
          ),
          isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/,
      },
      monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
      weekdays: {
          format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split(
              '_'
          ),
          standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split(
              '_'
          ),
          isFormat: /dddd HH:mm/,
      },
      weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
      weekdaysMin: 'S_P_A_T_K_Pn_'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'YYYY [m.] MMMM D [d.]',
          LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
          LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
          l: 'YYYY-MM-DD',
          ll: 'YYYY [m.] MMMM D [d.]',
          lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
          llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]',
      },
      calendar: {
          sameDay: '[iandien] LT',
          nextDay: '[Rytoj] LT',
          nextWeek: 'dddd LT',
          lastDay: '[Vakar] LT',
          lastWeek: '[Prajus] dddd LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'po %s',
          past: 'prie %s',
          s: translateSeconds,
          ss: translate$6,
          m: translateSingular,
          mm: translate$6,
          h: translateSingular,
          hh: translate$6,
          d: translateSingular,
          dd: translate$6,
          M: translateSingular,
          MM: translate$6,
          y: translateSingular,
          yy: translate$6,
      },
      dayOfMonthOrdinalParse: /\d{1,2}-oji/,
      ordinal: function (number) {
          return number + '-oji';
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var units$1 = {
      ss: 'sekundes_sekundm_sekunde_sekundes'.split('_'),
      m: 'mintes_mintm_minte_mintes'.split('_'),
      mm: 'mintes_mintm_minte_mintes'.split('_'),
      h: 'stundas_stundm_stunda_stundas'.split('_'),
      hh: 'stundas_stundm_stunda_stundas'.split('_'),
      d: 'dienas_dienm_diena_dienas'.split('_'),
      dd: 'dienas_dienm_diena_dienas'.split('_'),
      M: 'mnea_mneiem_mnesis_mnei'.split('_'),
      MM: 'mnea_mneiem_mnesis_mnei'.split('_'),
      y: 'gada_gadiem_gads_gadi'.split('_'),
      yy: 'gada_gadiem_gads_gadi'.split('_'),
  };
  /**
   * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
   */
  function format$1(forms, number, withoutSuffix) {
      if (withoutSuffix) {
          // E.g. "21 minte", "3 mintes".
          return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
      } else {
          // E.g. "21 mintes" as in "pc 21 mintes".
          // E.g. "3 mintm" as in "pc 3 mintm".
          return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
      }
  }
  function relativeTimeWithPlural$1(number, withoutSuffix, key) {
      return number + ' ' + format$1(units$1[key], number, withoutSuffix);
  }
  function relativeTimeWithSingular(number, withoutSuffix, key) {
      return format$1(units$1[key], number, withoutSuffix);
  }
  function relativeSeconds(number, withoutSuffix) {
      return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
  }

  hooks.defineLocale('lv', {
      months: 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split(
          '_'
      ),
      monthsShort: 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
      weekdays: 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split(
          '_'
      ),
      weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
      weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY.',
          LL: 'YYYY. [gada] D. MMMM',
          LLL: 'YYYY. [gada] D. MMMM, HH:mm',
          LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm',
      },
      calendar: {
          sameDay: '[odien pulksten] LT',
          nextDay: '[Rt pulksten] LT',
          nextWeek: 'dddd [pulksten] LT',
          lastDay: '[Vakar pulksten] LT',
          lastWeek: '[Pagju] dddd [pulksten] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'pc %s',
          past: 'pirms %s',
          s: relativeSeconds,
          ss: relativeTimeWithPlural$1,
          m: relativeTimeWithSingular,
          mm: relativeTimeWithPlural$1,
          h: relativeTimeWithSingular,
          hh: relativeTimeWithPlural$1,
          d: relativeTimeWithSingular,
          dd: relativeTimeWithPlural$1,
          M: relativeTimeWithSingular,
          MM: relativeTimeWithPlural$1,
          y: relativeTimeWithSingular,
          yy: relativeTimeWithPlural$1,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var translator = {
      words: {
          //Different grammatical cases
          ss: ['sekund', 'sekunda', 'sekundi'],
          m: ['jedan minut', 'jednog minuta'],
          mm: ['minut', 'minuta', 'minuta'],
          h: ['jedan sat', 'jednog sata'],
          hh: ['sat', 'sata', 'sati'],
          dd: ['dan', 'dana', 'dana'],
          MM: ['mjesec', 'mjeseca', 'mjeseci'],
          yy: ['godina', 'godine', 'godina'],
      },
      correctGrammaticalCase: function (number, wordKey) {
          return number === 1
              ? wordKey[0]
              : number >= 2 && number <= 4
              ? wordKey[1]
              : wordKey[2];
      },
      translate: function (number, withoutSuffix, key) {
          var wordKey = translator.words[key];
          if (key.length === 1) {
              return withoutSuffix ? wordKey[0] : wordKey[1];
          } else {
              return (
                  number +
                  ' ' +
                  translator.correctGrammaticalCase(number, wordKey)
              );
          }
      },
  };

  hooks.defineLocale('me', {
      months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
          '_'
      ),
      monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split(
          '_'
      ),
      weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
      weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm',
      },
      calendar: {
          sameDay: '[danas u] LT',
          nextDay: '[sjutra u] LT',

          nextWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[u] [nedjelju] [u] LT';
                  case 3:
                      return '[u] [srijedu] [u] LT';
                  case 6:
                      return '[u] [subotu] [u] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[u] dddd [u] LT';
              }
          },
          lastDay: '[jue u] LT',
          lastWeek: function () {
              var lastWeekDays = [
                  '[prole] [nedjelje] [u] LT',
                  '[prolog] [ponedjeljka] [u] LT',
                  '[prolog] [utorka] [u] LT',
                  '[prole] [srijede] [u] LT',
                  '[prolog] [etvrtka] [u] LT',
                  '[prolog] [petka] [u] LT',
                  '[prole] [subote] [u] LT',
              ];
              return lastWeekDays[this.day()];
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'za %s',
          past: 'prije %s',
          s: 'nekoliko sekundi',
          ss: translator.translate,
          m: translator.translate,
          mm: translator.translate,
          h: translator.translate,
          hh: translator.translate,
          d: 'dan',
          dd: translator.translate,
          M: 'mjesec',
          MM: translator.translate,
          y: 'godinu',
          yy: translator.translate,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('mi', {
      months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split(
          '_'
      ),
      monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split(
          '_'
      ),
      monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
      monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
      monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
      monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
      weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
      weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
      weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [i] HH:mm',
          LLLL: 'dddd, D MMMM YYYY [i] HH:mm',
      },
      calendar: {
          sameDay: '[i teie mahana, i] LT',
          nextDay: '[apopo i] LT',
          nextWeek: 'dddd [i] LT',
          lastDay: '[inanahi i] LT',
          lastWeek: 'dddd [whakamutunga i] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'i roto i %s',
          past: '%s i mua',
          s: 'te hkona ruarua',
          ss: '%d hkona',
          m: 'he meneti',
          mm: '%d meneti',
          h: 'te haora',
          hh: '%d haora',
          d: 'he ra',
          dd: '%d ra',
          M: 'he marama',
          MM: '%d marama',
          y: 'he tau',
          yy: '%d tau',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('mk', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split('_'),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: 'e_o_____a'.split('_'),
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'D.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY H:mm',
          LLLL: 'dddd, D MMMM YYYY H:mm',
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: '[] dddd [] LT',
          lastDay: '[ ] LT',
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                  case 3:
                  case 6:
                      return '[] dddd [] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[] dddd [] LT';
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
      ordinal: function (number) {
          var lastDigit = number % 10,
              last2Digits = number % 100;
          if (number === 0) {
              return number + '-';
          } else if (last2Digits === 0) {
              return number + '-';
          } else if (last2Digits > 10 && last2Digits < 20) {
              return number + '-';
          } else if (lastDigit === 1) {
              return number + '-';
          } else if (lastDigit === 2) {
              return number + '-';
          } else if (lastDigit === 7 || lastDigit === 8) {
              return number + '-';
          } else {
              return number + '-';
          }
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ml', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '._._._.___._._._._._.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm -',
          LTS: 'A h:mm:ss -',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm -',
          LLLL: 'dddd, D MMMM YYYY, A h:mm -',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      meridiemParse: /|| ||/i,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (
              (meridiem === '' && hour >= 4) ||
              meridiem === ' ' ||
              meridiem === ''
          ) {
              return hour + 12;
          } else {
              return hour;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 12) {
              return '';
          } else if (hour < 17) {
              return ' ';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
  });

  //! moment.js locale configuration

  function translate$7(number, withoutSuffix, key, isFuture) {
      switch (key) {
          case 's':
              return withoutSuffix ? ' ' : ' ';
          case 'ss':
              return number + (withoutSuffix ? ' ' : ' ');
          case 'm':
          case 'mm':
              return number + (withoutSuffix ? ' ' : ' ');
          case 'h':
          case 'hh':
              return number + (withoutSuffix ? ' ' : ' ');
          case 'd':
          case 'dd':
              return number + (withoutSuffix ? ' ' : ' ');
          case 'M':
          case 'MM':
              return number + (withoutSuffix ? ' ' : ' ');
          case 'y':
          case 'yy':
              return number + (withoutSuffix ? ' ' : ' ');
          default:
              return number;
      }
  }

  hooks.defineLocale('mn', {
      months: ' _ _ _ _ _ _ _ _ _ _  _  '.split(
          '_'
      ),
      monthsShort: '1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'YYYY  MMMM D',
          LLL: 'YYYY  MMMM D HH:mm',
          LLLL: 'dddd, YYYY  MMMM D HH:mm',
      },
      meridiemParse: /|/i,
      isPM: function (input) {
          return input === '';
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: '[] dddd LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: translate$7,
          ss: translate$7,
          m: translate$7,
          mm: translate$7,
          h: translate$7,
          hh: translate$7,
          d: translate$7,
          dd: translate$7,
          M: translate$7,
          MM: translate$7,
          y: translate$7,
          yy: translate$7,
      },
      dayOfMonthOrdinalParse: /\d{1,2} /,
      ordinal: function (number, period) {
          switch (period) {
              case 'd':
              case 'D':
              case 'DDD':
                  return number + ' ';
              default:
                  return number;
          }
      },
  });

  //! moment.js locale configuration

  var symbolMap$c = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$b = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  function relativeTimeMr(number, withoutSuffix, string, isFuture) {
      var output = '';
      if (withoutSuffix) {
          switch (string) {
              case 's':
                  output = ' ';
                  break;
              case 'ss':
                  output = '%d ';
                  break;
              case 'm':
                  output = ' ';
                  break;
              case 'mm':
                  output = '%d ';
                  break;
              case 'h':
                  output = ' ';
                  break;
              case 'hh':
                  output = '%d ';
                  break;
              case 'd':
                  output = ' ';
                  break;
              case 'dd':
                  output = '%d ';
                  break;
              case 'M':
                  output = ' ';
                  break;
              case 'MM':
                  output = '%d ';
                  break;
              case 'y':
                  output = ' ';
                  break;
              case 'yy':
                  output = '%d ';
                  break;
          }
      } else {
          switch (string) {
              case 's':
                  output = ' ';
                  break;
              case 'ss':
                  output = '%d ';
                  break;
              case 'm':
                  output = ' ';
                  break;
              case 'mm':
                  output = '%d ';
                  break;
              case 'h':
                  output = ' ';
                  break;
              case 'hh':
                  output = '%d ';
                  break;
              case 'd':
                  output = ' ';
                  break;
              case 'dd':
                  output = '%d ';
                  break;
              case 'M':
                  output = ' ';
                  break;
              case 'MM':
                  output = '%d ';
                  break;
              case 'y':
                  output = ' ';
                  break;
              case 'yy':
                  output = '%d ';
                  break;
          }
      }
      return output.replace(/%d/i, number);
  }

  hooks.defineLocale('mr', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '._._._._._._._._._._._.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm ',
          LTS: 'A h:mm:ss ',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm ',
          LLLL: 'dddd, D MMMM YYYY, A h:mm ',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s',
          past: '%s',
          s: relativeTimeMr,
          ss: relativeTimeMr,
          m: relativeTimeMr,
          mm: relativeTimeMr,
          h: relativeTimeMr,
          hh: relativeTimeMr,
          d: relativeTimeMr,
          dd: relativeTimeMr,
          M: relativeTimeMr,
          MM: relativeTimeMr,
          y: relativeTimeMr,
          yy: relativeTimeMr,
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$b[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$c[match];
          });
      },
      meridiemParse: /||||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '' || meridiem === '') {
              return hour;
          } else if (
              meridiem === '' ||
              meridiem === '' ||
              meridiem === ''
          ) {
              return hour >= 12 ? hour : hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour >= 0 && hour < 6) {
              return '';
          } else if (hour < 12) {
              return '';
          } else if (hour < 17) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ms-my', {
      months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
      weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
      weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
      weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
      longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
      },
      meridiemParse: /pagi|tengahari|petang|malam/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === 'pagi') {
              return hour;
          } else if (meridiem === 'tengahari') {
              return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === 'petang' || meridiem === 'malam') {
              return hour + 12;
          }
      },
      meridiem: function (hours, minutes, isLower) {
          if (hours < 11) {
              return 'pagi';
          } else if (hours < 15) {
              return 'tengahari';
          } else if (hours < 19) {
              return 'petang';
          } else {
              return 'malam';
          }
      },
      calendar: {
          sameDay: '[Hari ini pukul] LT',
          nextDay: '[Esok pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kelmarin pukul] LT',
          lastWeek: 'dddd [lepas pukul] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'dalam %s',
          past: '%s yang lepas',
          s: 'beberapa saat',
          ss: '%d saat',
          m: 'seminit',
          mm: '%d minit',
          h: 'sejam',
          hh: '%d jam',
          d: 'sehari',
          dd: '%d hari',
          M: 'sebulan',
          MM: '%d bulan',
          y: 'setahun',
          yy: '%d tahun',
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ms', {
      months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
      weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
      weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
      weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
      longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [pukul] HH.mm',
          LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
      },
      meridiemParse: /pagi|tengahari|petang|malam/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === 'pagi') {
              return hour;
          } else if (meridiem === 'tengahari') {
              return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === 'petang' || meridiem === 'malam') {
              return hour + 12;
          }
      },
      meridiem: function (hours, minutes, isLower) {
          if (hours < 11) {
              return 'pagi';
          } else if (hours < 15) {
              return 'tengahari';
          } else if (hours < 19) {
              return 'petang';
          } else {
              return 'malam';
          }
      },
      calendar: {
          sameDay: '[Hari ini pukul] LT',
          nextDay: '[Esok pukul] LT',
          nextWeek: 'dddd [pukul] LT',
          lastDay: '[Kelmarin pukul] LT',
          lastWeek: 'dddd [lepas pukul] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'dalam %s',
          past: '%s yang lepas',
          s: 'beberapa saat',
          ss: '%d saat',
          m: 'seminit',
          mm: '%d minit',
          h: 'sejam',
          hh: '%d jam',
          d: 'sehari',
          dd: '%d hari',
          M: 'sebulan',
          MM: '%d bulan',
          y: 'setahun',
          yy: '%d tahun',
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('mt', {
      months: 'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split(
          '_'
      ),
      monthsShort: 'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),
      weekdays: 'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split(
          '_'
      ),
      weekdaysShort: 'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),
      weekdaysMin: 'a_Tn_Tl_Er_a_i_Si'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Illum fil-]LT',
          nextDay: '[Gada fil-]LT',
          nextWeek: 'dddd [fil-]LT',
          lastDay: '[Il-biera fil-]LT',
          lastWeek: 'dddd [li gadda] [fil-]LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'f %s',
          past: '%s ilu',
          s: 'ftit sekondi',
          ss: '%d sekondi',
          m: 'minuta',
          mm: '%d minuti',
          h: 'siega',
          hh: '%d siegat',
          d: 'urnata',
          dd: '%d ranet',
          M: 'xahar',
          MM: '%d xhur',
          y: 'sena',
          yy: '%d sni',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$d = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$c = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('my', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split('_'),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),

      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[.] LT []',
          nextDay: '[] LT []',
          nextWeek: 'dddd LT []',
          lastDay: '[.] LT []',
          lastWeek: '[] dddd LT []',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s ',
          past: ' %s ',
          s: '.',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d ',
          M: '',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$c[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$d[match];
          });
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('nb', {
      months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split(
          '_'
      ),
      monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
      weekdaysShort: 's._ma._ti._on._to._fr._l.'.split('_'),
      weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY [kl.] HH:mm',
          LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
      },
      calendar: {
          sameDay: '[i dag kl.] LT',
          nextDay: '[i morgen kl.] LT',
          nextWeek: 'dddd [kl.] LT',
          lastDay: '[i gr kl.] LT',
          lastWeek: '[forrige] dddd [kl.] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'om %s',
          past: '%s siden',
          s: 'noen sekunder',
          ss: '%d sekunder',
          m: 'ett minutt',
          mm: '%d minutter',
          h: 'en time',
          hh: '%d timer',
          d: 'en dag',
          dd: '%d dager',
          w: 'en uke',
          ww: '%d uker',
          M: 'en mned',
          MM: '%d mneder',
          y: 'ett r',
          yy: '%d r',
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$e = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$d = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('ne', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '._.__.___._._._._._.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '._._._._._._.'.split('_'),
      weekdaysMin: '._._._._._._.'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'A h:mm ',
          LTS: 'A h:mm:ss ',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm ',
          LLLL: 'dddd, D MMMM YYYY, A h:mm ',
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$d[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$e[match];
          });
      },
      meridiemParse: /|||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '') {
              return hour < 4 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 3) {
              return '';
          } else if (hour < 12) {
              return '';
          } else if (hour < 16) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: '[] dddd[,] LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd[,] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var monthsShortWithDots$1 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split(
          '_'
      ),
      monthsShortWithoutDots$1 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split(
          '_'
      ),
      monthsParse$8 = [
          /^jan/i,
          /^feb/i,
          /^maart|mrt.?$/i,
          /^apr/i,
          /^mei$/i,
          /^jun[i.]?$/i,
          /^jul[i.]?$/i,
          /^aug/i,
          /^sep/i,
          /^okt/i,
          /^nov/i,
          /^dec/i,
      ],
      monthsRegex$8 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

  hooks.defineLocale('nl-be', {
      months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split(
          '_'
      ),
      monthsShort: function (m, format) {
          if (!m) {
              return monthsShortWithDots$1;
          } else if (/-MMM-/.test(format)) {
              return monthsShortWithoutDots$1[m.month()];
          } else {
              return monthsShortWithDots$1[m.month()];
          }
      },

      monthsRegex: monthsRegex$8,
      monthsShortRegex: monthsRegex$8,
      monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
      monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

      monthsParse: monthsParse$8,
      longMonthsParse: monthsParse$8,
      shortMonthsParse: monthsParse$8,

      weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split(
          '_'
      ),
      weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
      weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[vandaag om] LT',
          nextDay: '[morgen om] LT',
          nextWeek: 'dddd [om] LT',
          lastDay: '[gisteren om] LT',
          lastWeek: '[afgelopen] dddd [om] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'over %s',
          past: '%s geleden',
          s: 'een paar seconden',
          ss: '%d seconden',
          m: 'n minuut',
          mm: '%d minuten',
          h: 'n uur',
          hh: '%d uur',
          d: 'n dag',
          dd: '%d dagen',
          M: 'n maand',
          MM: '%d maanden',
          y: 'n jaar',
          yy: '%d jaar',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function (number) {
          return (
              number +
              (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
          );
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var monthsShortWithDots$2 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split(
          '_'
      ),
      monthsShortWithoutDots$2 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split(
          '_'
      ),
      monthsParse$9 = [
          /^jan/i,
          /^feb/i,
          /^maart|mrt.?$/i,
          /^apr/i,
          /^mei$/i,
          /^jun[i.]?$/i,
          /^jul[i.]?$/i,
          /^aug/i,
          /^sep/i,
          /^okt/i,
          /^nov/i,
          /^dec/i,
      ],
      monthsRegex$9 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

  hooks.defineLocale('nl', {
      months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split(
          '_'
      ),
      monthsShort: function (m, format) {
          if (!m) {
              return monthsShortWithDots$2;
          } else if (/-MMM-/.test(format)) {
              return monthsShortWithoutDots$2[m.month()];
          } else {
              return monthsShortWithDots$2[m.month()];
          }
      },

      monthsRegex: monthsRegex$9,
      monthsShortRegex: monthsRegex$9,
      monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
      monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

      monthsParse: monthsParse$9,
      longMonthsParse: monthsParse$9,
      shortMonthsParse: monthsParse$9,

      weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split(
          '_'
      ),
      weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
      weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD-MM-YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[vandaag om] LT',
          nextDay: '[morgen om] LT',
          nextWeek: 'dddd [om] LT',
          lastDay: '[gisteren om] LT',
          lastWeek: '[afgelopen] dddd [om] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'over %s',
          past: '%s geleden',
          s: 'een paar seconden',
          ss: '%d seconden',
          m: 'n minuut',
          mm: '%d minuten',
          h: 'n uur',
          hh: '%d uur',
          d: 'n dag',
          dd: '%d dagen',
          w: 'n week',
          ww: '%d weken',
          M: 'n maand',
          MM: '%d maanden',
          y: 'n jaar',
          yy: '%d jaar',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function (number) {
          return (
              number +
              (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
          );
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('nn', {
      months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split(
          '_'
      ),
      monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
      weekdaysShort: 'su._m._ty._on._to._fr._lau.'.split('_'),
      weekdaysMin: 'su_m_ty_on_to_fr_la'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY [kl.] H:mm',
          LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
      },
      calendar: {
          sameDay: '[I dag klokka] LT',
          nextDay: '[I morgon klokka] LT',
          nextWeek: 'dddd [klokka] LT',
          lastDay: '[I gr klokka] LT',
          lastWeek: '[Fregande] dddd [klokka] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'om %s',
          past: '%s sidan',
          s: 'nokre sekund',
          ss: '%d sekund',
          m: 'eit minutt',
          mm: '%d minutt',
          h: 'ein time',
          hh: '%d timar',
          d: 'ein dag',
          dd: '%d dagar',
          w: 'ei veke',
          ww: '%d veker',
          M: 'ein mnad',
          MM: '%d mnader',
          y: 'eit r',
          yy: '%d r',
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('oc-lnc', {
      months: {
          standalone: 'genir_febrir_mar_abril_mai_junh_julhet_agost_setembre_octbre_novembre_decembre'.split(
              '_'
          ),
          format: "de genir_de febrir_de mar_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octbre_de novembre_de decembre".split(
              '_'
          ),
          isFormat: /D[oD]?(\s)+MMMM/,
      },
      monthsShort: 'gen._febr._mar_abr._mai_junh_julh._ago._set._oct._nov._dec.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'dimenge_diluns_dimars_dimcres_dijus_divendres_dissabte'.split(
          '_'
      ),
      weekdaysShort: 'dg._dl._dm._dc._dj._dv._ds.'.split('_'),
      weekdaysMin: 'dg_dl_dm_dc_dj_dv_ds'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM [de] YYYY',
          ll: 'D MMM YYYY',
          LLL: 'D MMMM [de] YYYY [a] H:mm',
          lll: 'D MMM YYYY, H:mm',
          LLLL: 'dddd D MMMM [de] YYYY [a] H:mm',
          llll: 'ddd D MMM YYYY, H:mm',
      },
      calendar: {
          sameDay: '[ui a] LT',
          nextDay: '[deman a] LT',
          nextWeek: 'dddd [a] LT',
          lastDay: '[ir a] LT',
          lastWeek: 'dddd [passat a] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: "d'aqu %s",
          past: 'fa %s',
          s: 'unas segondas',
          ss: '%d segondas',
          m: 'una minuta',
          mm: '%d minutas',
          h: 'una ora',
          hh: '%d oras',
          d: 'un jorn',
          dd: '%d jorns',
          M: 'un mes',
          MM: '%d meses',
          y: 'un an',
          yy: '%d ans',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
      ordinal: function (number, period) {
          var output =
              number === 1
                  ? 'r'
                  : number === 2
                  ? 'n'
                  : number === 3
                  ? 'r'
                  : number === 4
                  ? 't'
                  : '';
          if (period === 'w' || period === 'W') {
              output = 'a';
          }
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4,
      },
  });

  //! moment.js locale configuration

  var symbolMap$f = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$e = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('pa-in', {
      // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm ',
          LTS: 'A h:mm:ss ',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm ',
          LLLL: 'dddd, D MMMM YYYY, A h:mm ',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: '[] dddd, LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$e[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$f[match];
          });
      },
      // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
      // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
      meridiemParse: /|||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '') {
              return hour < 4 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 10) {
              return '';
          } else if (hour < 17) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split(
          '_'
      ),
      monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split(
          '_'
      ),
      monthsParse$a = [
          /^sty/i,
          /^lut/i,
          /^mar/i,
          /^kwi/i,
          /^maj/i,
          /^cze/i,
          /^lip/i,
          /^sie/i,
          /^wrz/i,
          /^pa/i,
          /^lis/i,
          /^gru/i,
      ];
  function plural$3(n) {
      return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
  }
  function translate$8(number, withoutSuffix, key) {
      var result = number + ' ';
      switch (key) {
          case 'ss':
              return result + (plural$3(number) ? 'sekundy' : 'sekund');
          case 'm':
              return withoutSuffix ? 'minuta' : 'minut';
          case 'mm':
              return result + (plural$3(number) ? 'minuty' : 'minut');
          case 'h':
              return withoutSuffix ? 'godzina' : 'godzin';
          case 'hh':
              return result + (plural$3(number) ? 'godziny' : 'godzin');
          case 'ww':
              return result + (plural$3(number) ? 'tygodnie' : 'tygodni');
          case 'MM':
              return result + (plural$3(number) ? 'miesice' : 'miesicy');
          case 'yy':
              return result + (plural$3(number) ? 'lata' : 'lat');
      }
  }

  hooks.defineLocale('pl', {
      months: function (momentToFormat, format) {
          if (!momentToFormat) {
              return monthsNominative;
          } else if (/D MMMM/.test(format)) {
              return monthsSubjective[momentToFormat.month()];
          } else {
              return monthsNominative[momentToFormat.month()];
          }
      },
      monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
      monthsParse: monthsParse$a,
      longMonthsParse: monthsParse$a,
      shortMonthsParse: monthsParse$a,
      weekdays: 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split(
          '_'
      ),
      weekdaysShort: 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
      weekdaysMin: 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Dzi o] LT',
          nextDay: '[Jutro o] LT',
          nextWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[W niedziel o] LT';

                  case 2:
                      return '[We wtorek o] LT';

                  case 3:
                      return '[W rod o] LT';

                  case 6:
                      return '[W sobot o] LT';

                  default:
                      return '[W] dddd [o] LT';
              }
          },
          lastDay: '[Wczoraj o] LT',
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[W zesz niedziel o] LT';
                  case 3:
                      return '[W zesz rod o] LT';
                  case 6:
                      return '[W zesz sobot o] LT';
                  default:
                      return '[W zeszy] dddd [o] LT';
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'za %s',
          past: '%s temu',
          s: 'kilka sekund',
          ss: translate$8,
          m: translate$8,
          mm: translate$8,
          h: translate$8,
          hh: translate$8,
          d: '1 dzie',
          dd: '%d dni',
          w: 'tydzie',
          ww: translate$8,
          M: 'miesic',
          MM: translate$8,
          y: 'rok',
          yy: translate$8,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('pt-br', {
      months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
          '_'
      ),
      monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
      weekdays: 'domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado'.split(
          '_'
      ),
      weekdaysShort: 'dom_seg_ter_qua_qui_sex_sb'.split('_'),
      weekdaysMin: 'do_2_3_4_5_6_s'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY [s] HH:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY [s] HH:mm',
      },
      calendar: {
          sameDay: '[Hoje s] LT',
          nextDay: '[Amanh s] LT',
          nextWeek: 'dddd [s] LT',
          lastDay: '[Ontem s] LT',
          lastWeek: function () {
              return this.day() === 0 || this.day() === 6
                  ? '[ltimo] dddd [s] LT' // Saturday + Sunday
                  : '[ltima] dddd [s] LT'; // Monday - Friday
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'em %s',
          past: 'h %s',
          s: 'poucos segundos',
          ss: '%d segundos',
          m: 'um minuto',
          mm: '%d minutos',
          h: 'uma hora',
          hh: '%d horas',
          d: 'um dia',
          dd: '%d dias',
          M: 'um ms',
          MM: '%d meses',
          y: 'um ano',
          yy: '%d anos',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      invalidDate: 'Data invlida',
  });

  //! moment.js locale configuration

  hooks.defineLocale('pt', {
      months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
          '_'
      ),
      monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
      weekdays: 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split(
          '_'
      ),
      weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
      weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D [de] MMMM [de] YYYY',
          LLL: 'D [de] MMMM [de] YYYY HH:mm',
          LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Hoje s] LT',
          nextDay: '[Amanh s] LT',
          nextWeek: 'dddd [s] LT',
          lastDay: '[Ontem s] LT',
          lastWeek: function () {
              return this.day() === 0 || this.day() === 6
                  ? '[ltimo] dddd [s] LT' // Saturday + Sunday
                  : '[ltima] dddd [s] LT'; // Monday - Friday
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'em %s',
          past: 'h %s',
          s: 'segundos',
          ss: '%d segundos',
          m: 'um minuto',
          mm: '%d minutos',
          h: 'uma hora',
          hh: '%d horas',
          d: 'um dia',
          dd: '%d dias',
          w: 'uma semana',
          ww: '%d semanas',
          M: 'um ms',
          MM: '%d meses',
          y: 'um ano',
          yy: '%d anos',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function relativeTimeWithPlural$2(number, withoutSuffix, key) {
      var format = {
              ss: 'secunde',
              mm: 'minute',
              hh: 'ore',
              dd: 'zile',
              ww: 'sptmni',
              MM: 'luni',
              yy: 'ani',
          },
          separator = ' ';
      if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
          separator = ' de ';
      }
      return number + separator + format[key];
  }

  hooks.defineLocale('ro', {
      months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split(
          '_'
      ),
      monthsShort: 'ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
      weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
      weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY H:mm',
          LLLL: 'dddd, D MMMM YYYY H:mm',
      },
      calendar: {
          sameDay: '[azi la] LT',
          nextDay: '[mine la] LT',
          nextWeek: 'dddd [la] LT',
          lastDay: '[ieri la] LT',
          lastWeek: '[fosta] dddd [la] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'peste %s',
          past: '%s n urm',
          s: 'cteva secunde',
          ss: relativeTimeWithPlural$2,
          m: 'un minut',
          mm: relativeTimeWithPlural$2,
          h: 'o or',
          hh: relativeTimeWithPlural$2,
          d: 'o zi',
          dd: relativeTimeWithPlural$2,
          w: 'o sptmn',
          ww: relativeTimeWithPlural$2,
          M: 'o lun',
          MM: relativeTimeWithPlural$2,
          y: 'un an',
          yy: relativeTimeWithPlural$2,
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function plural$4(word, num) {
      var forms = word.split('_');
      return num % 10 === 1 && num % 100 !== 11
          ? forms[0]
          : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
          ? forms[1]
          : forms[2];
  }
  function relativeTimeWithPlural$3(number, withoutSuffix, key) {
      var format = {
          ss: withoutSuffix ? '__' : '__',
          mm: withoutSuffix ? '__' : '__',
          hh: '__',
          dd: '__',
          ww: '__',
          MM: '__',
          yy: '__',
      };
      if (key === 'm') {
          return withoutSuffix ? '' : '';
      } else {
          return number + ' ' + plural$4(format[key], +number);
      }
  }
  var monthsParse$b = [
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^[]/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
  ];

  // http://new.gramota.ru/spravka/rules/139-prop :  103
  //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
  // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
  hooks.defineLocale('ru', {
      months: {
          format: '___________'.split(
              '_'
          ),
          standalone: '___________'.split(
              '_'
          ),
      },
      monthsShort: {
          //  CLDR  "."  ".",       ?
          format: '._._._.____._._._._.'.split(
              '_'
          ),
          standalone: '._.__.____._._._._.'.split(
              '_'
          ),
      },
      weekdays: {
          standalone: '______'.split(
              '_'
          ),
          format: '______'.split(
              '_'
          ),
          isFormat: /\[ ?[] ?(?:||)? ?] ?dddd/,
      },
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      monthsParse: monthsParse$b,
      longMonthsParse: monthsParse$b,
      shortMonthsParse: monthsParse$b,

      //    ,   ,  ,  4 ,      
      monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

      //  
      monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

      //    
      monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

      // ,     
      monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY .',
          LLL: 'D MMMM YYYY ., H:mm',
          LLLL: 'dddd, D MMMM YYYY ., H:mm',
      },
      calendar: {
          sameDay: '[, ] LT',
          nextDay: '[, ] LT',
          lastDay: '[, ] LT',
          nextWeek: function (now) {
              if (now.week() !== this.week()) {
                  switch (this.day()) {
                      case 0:
                          return '[ ] dddd, [] LT';
                      case 1:
                      case 2:
                      case 4:
                          return '[ ] dddd, [] LT';
                      case 3:
                      case 5:
                      case 6:
                          return '[ ] dddd, [] LT';
                  }
              } else {
                  if (this.day() === 2) {
                      return '[] dddd, [] LT';
                  } else {
                      return '[] dddd, [] LT';
                  }
              }
          },
          lastWeek: function (now) {
              if (now.week() !== this.week()) {
                  switch (this.day()) {
                      case 0:
                          return '[ ] dddd, [] LT';
                      case 1:
                      case 2:
                      case 4:
                          return '[ ] dddd, [] LT';
                      case 3:
                      case 5:
                      case 6:
                          return '[ ] dddd, [] LT';
                  }
              } else {
                  if (this.day() === 2) {
                      return '[] dddd, [] LT';
                  } else {
                      return '[] dddd, [] LT';
                  }
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: '%s ',
          s: ' ',
          ss: relativeTimeWithPlural$3,
          m: relativeTimeWithPlural$3,
          mm: relativeTimeWithPlural$3,
          h: '',
          hh: relativeTimeWithPlural$3,
          d: '',
          dd: relativeTimeWithPlural$3,
          w: '',
          ww: relativeTimeWithPlural$3,
          M: '',
          MM: relativeTimeWithPlural$3,
          y: '',
          yy: relativeTimeWithPlural$3,
      },
      meridiemParse: /|||/i,
      isPM: function (input) {
          return /^(|)$/.test(input);
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 12) {
              return '';
          } else if (hour < 17) {
              return '';
          } else {
              return '';
          }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
      ordinal: function (number, period) {
          switch (period) {
              case 'M':
              case 'd':
              case 'DDD':
                  return number + '-';
              case 'D':
                  return number + '-';
              case 'w':
              case 'W':
                  return number + '-';
              default:
                  return number;
          }
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var months$9 = [
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
      ],
      days$1 = ['', '', '', '', '', '', ''];

  hooks.defineLocale('sd', {
      months: months$9,
      monthsShort: months$9,
      weekdays: days$1,
      weekdaysShort: days$1,
      weekdaysMin: days$1,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return '' === input;
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          }
          return '';
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd [  ] LT',
          lastDay: '[] LT',
          lastWeek: '[ ] dddd [] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      preparse: function (string) {
          return string.replace(//g, ',');
      },
      postformat: function (string) {
          return string.replace(/,/g, '');
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('se', {
      months: 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split(
          '_'
      ),
      monthsShort: 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split(
          '_'
      ),
      weekdays: 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split(
          '_'
      ),
      weekdaysShort: 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
      weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'MMMM D. [b.] YYYY',
          LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
          LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm',
      },
      calendar: {
          sameDay: '[otne ti] LT',
          nextDay: '[ihttin ti] LT',
          nextWeek: 'dddd [ti] LT',
          lastDay: '[ikte ti] LT',
          lastWeek: '[ovddit] dddd [ti] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s geaes',
          past: 'mait %s',
          s: 'moadde sekunddat',
          ss: '%d sekunddat',
          m: 'okta minuhta',
          mm: '%d minuhtat',
          h: 'okta diimmu',
          hh: '%d diimmut',
          d: 'okta beaivi',
          dd: '%d beaivvit',
          M: 'okta mnnu',
          MM: '%d mnut',
          y: 'okta jahki',
          yy: '%d jagit',
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  /*jshint -W100*/
  hooks.defineLocale('si', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'a h:mm',
          LTS: 'a h:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYY MMMM D',
          LLL: 'YYYY MMMM D, a h:mm',
          LLLL: 'YYYY MMMM D [] dddd, a h:mm:ss',
      },
      calendar: {
          sameDay: '[] LT[]',
          nextDay: '[] LT[]',
          nextWeek: 'dddd LT[]',
          lastDay: '[] LT[]',
          lastWeek: '[] dddd LT[]',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s',
          past: '%s ',
          s: ' ',
          ss: ' %d',
          m: '',
          mm: ' %d',
          h: '',
          hh: ' %d',
          d: '',
          dd: ' %d',
          M: '',
          MM: ' %d',
          y: '',
          yy: ' %d',
      },
      dayOfMonthOrdinalParse: /\d{1,2} /,
      ordinal: function (number) {
          return number + ' ';
      },
      meridiemParse: / | |.|../,
      isPM: function (input) {
          return input === '..' || input === ' ';
      },
      meridiem: function (hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? '..' : ' ';
          } else {
              return isLower ? '..' : ' ';
          }
      },
  });

  //! moment.js locale configuration

  var months$a = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split(
          '_'
      ),
      monthsShort$7 = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
  function plural$5(n) {
      return n > 1 && n < 5;
  }
  function translate$9(number, withoutSuffix, key, isFuture) {
      var result = number + ' ';
      switch (key) {
          case 's': // a few seconds / in a few seconds / a few seconds ago
              return withoutSuffix || isFuture ? 'pr seknd' : 'pr sekundami';
          case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$5(number) ? 'sekundy' : 'seknd');
              } else {
                  return result + 'sekundami';
              }
          case 'm': // a minute / in a minute / a minute ago
              return withoutSuffix ? 'minta' : isFuture ? 'mintu' : 'mintou';
          case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$5(number) ? 'minty' : 'mint');
              } else {
                  return result + 'mintami';
              }
          case 'h': // an hour / in an hour / an hour ago
              return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
          case 'hh': // 9 hours / in 9 hours / 9 hours ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$5(number) ? 'hodiny' : 'hodn');
              } else {
                  return result + 'hodinami';
              }
          case 'd': // a day / in a day / a day ago
              return withoutSuffix || isFuture ? 'de' : 'dom';
          case 'dd': // 9 days / in 9 days / 9 days ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$5(number) ? 'dni' : 'dn');
              } else {
                  return result + 'dami';
              }
          case 'M': // a month / in a month / a month ago
              return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';
          case 'MM': // 9 months / in 9 months / 9 months ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$5(number) ? 'mesiace' : 'mesiacov');
              } else {
                  return result + 'mesiacmi';
              }
          case 'y': // a year / in a year / a year ago
              return withoutSuffix || isFuture ? 'rok' : 'rokom';
          case 'yy': // 9 years / in 9 years / 9 years ago
              if (withoutSuffix || isFuture) {
                  return result + (plural$5(number) ? 'roky' : 'rokov');
              } else {
                  return result + 'rokmi';
              }
      }
  }

  hooks.defineLocale('sk', {
      months: months$a,
      monthsShort: monthsShort$7,
      weekdays: 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
      weekdaysShort: 'ne_po_ut_st_t_pi_so'.split('_'),
      weekdaysMin: 'ne_po_ut_st_t_pi_so'.split('_'),
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd D. MMMM YYYY H:mm',
      },
      calendar: {
          sameDay: '[dnes o] LT',
          nextDay: '[zajtra o] LT',
          nextWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[v nedeu o] LT';
                  case 1:
                  case 2:
                      return '[v] dddd [o] LT';
                  case 3:
                      return '[v stredu o] LT';
                  case 4:
                      return '[vo tvrtok o] LT';
                  case 5:
                      return '[v piatok o] LT';
                  case 6:
                      return '[v sobotu o] LT';
              }
          },
          lastDay: '[vera o] LT',
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[minul nedeu o] LT';
                  case 1:
                  case 2:
                      return '[minul] dddd [o] LT';
                  case 3:
                      return '[minul stredu o] LT';
                  case 4:
                  case 5:
                      return '[minul] dddd [o] LT';
                  case 6:
                      return '[minul sobotu o] LT';
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'za %s',
          past: 'pred %s',
          s: translate$9,
          ss: translate$9,
          m: translate$9,
          mm: translate$9,
          h: translate$9,
          hh: translate$9,
          d: translate$9,
          dd: translate$9,
          M: translate$9,
          MM: translate$9,
          y: translate$9,
          yy: translate$9,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function processRelativeTime$7(number, withoutSuffix, key, isFuture) {
      var result = number + ' ';
      switch (key) {
          case 's':
              return withoutSuffix || isFuture
                  ? 'nekaj sekund'
                  : 'nekaj sekundami';
          case 'ss':
              if (number === 1) {
                  result += withoutSuffix ? 'sekundo' : 'sekundi';
              } else if (number === 2) {
                  result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
              } else if (number < 5) {
                  result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
              } else {
                  result += 'sekund';
              }
              return result;
          case 'm':
              return withoutSuffix ? 'ena minuta' : 'eno minuto';
          case 'mm':
              if (number === 1) {
                  result += withoutSuffix ? 'minuta' : 'minuto';
              } else if (number === 2) {
                  result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
              } else if (number < 5) {
                  result += withoutSuffix || isFuture ? 'minute' : 'minutami';
              } else {
                  result += withoutSuffix || isFuture ? 'minut' : 'minutami';
              }
              return result;
          case 'h':
              return withoutSuffix ? 'ena ura' : 'eno uro';
          case 'hh':
              if (number === 1) {
                  result += withoutSuffix ? 'ura' : 'uro';
              } else if (number === 2) {
                  result += withoutSuffix || isFuture ? 'uri' : 'urama';
              } else if (number < 5) {
                  result += withoutSuffix || isFuture ? 'ure' : 'urami';
              } else {
                  result += withoutSuffix || isFuture ? 'ur' : 'urami';
              }
              return result;
          case 'd':
              return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
          case 'dd':
              if (number === 1) {
                  result += withoutSuffix || isFuture ? 'dan' : 'dnem';
              } else if (number === 2) {
                  result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
              } else {
                  result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
              }
              return result;
          case 'M':
              return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
          case 'MM':
              if (number === 1) {
                  result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
              } else if (number === 2) {
                  result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
              } else if (number < 5) {
                  result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
              } else {
                  result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
              }
              return result;
          case 'y':
              return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
          case 'yy':
              if (number === 1) {
                  result += withoutSuffix || isFuture ? 'leto' : 'letom';
              } else if (number === 2) {
                  result += withoutSuffix || isFuture ? 'leti' : 'letoma';
              } else if (number < 5) {
                  result += withoutSuffix || isFuture ? 'leta' : 'leti';
              } else {
                  result += withoutSuffix || isFuture ? 'let' : 'leti';
              }
              return result;
      }
  }

  hooks.defineLocale('sl', {
      months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split(
          '_'
      ),
      monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
      weekdaysShort: 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
      weekdaysMin: 'ne_po_to_sr_e_pe_so'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD. MM. YYYY',
          LL: 'D. MMMM YYYY',
          LLL: 'D. MMMM YYYY H:mm',
          LLLL: 'dddd, D. MMMM YYYY H:mm',
      },
      calendar: {
          sameDay: '[danes ob] LT',
          nextDay: '[jutri ob] LT',

          nextWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[v] [nedeljo] [ob] LT';
                  case 3:
                      return '[v] [sredo] [ob] LT';
                  case 6:
                      return '[v] [soboto] [ob] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[v] dddd [ob] LT';
              }
          },
          lastDay: '[veraj ob] LT',
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[prejnjo] [nedeljo] [ob] LT';
                  case 3:
                      return '[prejnjo] [sredo] [ob] LT';
                  case 6:
                      return '[prejnjo] [soboto] [ob] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[prejnji] dddd [ob] LT';
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'ez %s',
          past: 'pred %s',
          s: processRelativeTime$7,
          ss: processRelativeTime$7,
          m: processRelativeTime$7,
          mm: processRelativeTime$7,
          h: processRelativeTime$7,
          hh: processRelativeTime$7,
          d: processRelativeTime$7,
          dd: processRelativeTime$7,
          M: processRelativeTime$7,
          MM: processRelativeTime$7,
          y: processRelativeTime$7,
          yy: processRelativeTime$7,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('sq', {
      months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split(
          '_'
      ),
      monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
      weekdays: 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split(
          '_'
      ),
      weekdaysShort: 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
      weekdaysMin: 'D_H_Ma_M_E_P_Sh'.split('_'),
      weekdaysParseExact: true,
      meridiemParse: /PD|MD/,
      isPM: function (input) {
          return input.charAt(0) === 'M';
      },
      meridiem: function (hours, minutes, isLower) {
          return hours < 12 ? 'PD' : 'MD';
      },
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Sot n] LT',
          nextDay: '[Nesr n] LT',
          nextWeek: 'dddd [n] LT',
          lastDay: '[Dje n] LT',
          lastWeek: 'dddd [e kaluar n] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'n %s',
          past: '%s m par',
          s: 'disa sekonda',
          ss: '%d sekonda',
          m: 'nj minut',
          mm: '%d minuta',
          h: 'nj or',
          hh: '%d or',
          d: 'nj dit',
          dd: '%d dit',
          M: 'nj muaj',
          MM: '%d muaj',
          y: 'nj vit',
          yy: '%d vite',
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var translator$1 = {
      words: {
          //Different grammatical cases
          ss: ['', '', ''],
          m: [' ', ' '],
          mm: ['', '', ''],
          h: [' ', ' '],
          hh: ['', '', ''],
          dd: ['', '', ''],
          MM: ['', '', ''],
          yy: ['', '', ''],
      },
      correctGrammaticalCase: function (number, wordKey) {
          return number === 1
              ? wordKey[0]
              : number >= 2 && number <= 4
              ? wordKey[1]
              : wordKey[2];
      },
      translate: function (number, withoutSuffix, key) {
          var wordKey = translator$1.words[key];
          if (key.length === 1) {
              return withoutSuffix ? wordKey[0] : wordKey[1];
          } else {
              return (
                  number +
                  ' ' +
                  translator$1.correctGrammaticalCase(number, wordKey)
              );
          }
      },
  };

  hooks.defineLocale('sr-cyrl', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '._._._.____._._._._.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: '______'.split('_'),
      weekdaysShort: '._._._._._._.'.split('_'),
      weekdaysMin: '______'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'D. M. YYYY.',
          LL: 'D. MMMM YYYY.',
          LLL: 'D. MMMM YYYY. H:mm',
          LLLL: 'dddd, D. MMMM YYYY. H:mm',
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[] [] [] LT';
                  case 3:
                      return '[] [] [] LT';
                  case 6:
                      return '[] [] [] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[] dddd [] LT';
              }
          },
          lastDay: '[ ] LT',
          lastWeek: function () {
              var lastWeekDays = [
                  '[] [] [] LT',
                  '[] [] [] LT',
                  '[] [] [] LT',
                  '[] [] [] LT',
                  '[] [] [] LT',
                  '[] [] [] LT',
                  '[] [] [] LT',
              ];
              return lastWeekDays[this.day()];
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: ' %s',
          s: ' ',
          ss: translator$1.translate,
          m: translator$1.translate,
          mm: translator$1.translate,
          h: translator$1.translate,
          hh: translator$1.translate,
          d: '',
          dd: translator$1.translate,
          M: '',
          MM: translator$1.translate,
          y: '',
          yy: translator$1.translate,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 1st is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var translator$2 = {
      words: {
          //Different grammatical cases
          ss: ['sekunda', 'sekunde', 'sekundi'],
          m: ['jedan minut', 'jedne minute'],
          mm: ['minut', 'minute', 'minuta'],
          h: ['jedan sat', 'jednog sata'],
          hh: ['sat', 'sata', 'sati'],
          dd: ['dan', 'dana', 'dana'],
          MM: ['mesec', 'meseca', 'meseci'],
          yy: ['godina', 'godine', 'godina'],
      },
      correctGrammaticalCase: function (number, wordKey) {
          return number === 1
              ? wordKey[0]
              : number >= 2 && number <= 4
              ? wordKey[1]
              : wordKey[2];
      },
      translate: function (number, withoutSuffix, key) {
          var wordKey = translator$2.words[key];
          if (key.length === 1) {
              return withoutSuffix ? wordKey[0] : wordKey[1];
          } else {
              return (
                  number +
                  ' ' +
                  translator$2.correctGrammaticalCase(number, wordKey)
              );
          }
      },
  };

  hooks.defineLocale('sr', {
      months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
          '_'
      ),
      monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split(
          '_'
      ),
      weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
      weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'D. M. YYYY.',
          LL: 'D. MMMM YYYY.',
          LLL: 'D. MMMM YYYY. H:mm',
          LLLL: 'dddd, D. MMMM YYYY. H:mm',
      },
      calendar: {
          sameDay: '[danas u] LT',
          nextDay: '[sutra u] LT',
          nextWeek: function () {
              switch (this.day()) {
                  case 0:
                      return '[u] [nedelju] [u] LT';
                  case 3:
                      return '[u] [sredu] [u] LT';
                  case 6:
                      return '[u] [subotu] [u] LT';
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                      return '[u] dddd [u] LT';
              }
          },
          lastDay: '[jue u] LT',
          lastWeek: function () {
              var lastWeekDays = [
                  '[prole] [nedelje] [u] LT',
                  '[prolog] [ponedeljka] [u] LT',
                  '[prolog] [utorka] [u] LT',
                  '[prole] [srede] [u] LT',
                  '[prolog] [etvrtka] [u] LT',
                  '[prolog] [petka] [u] LT',
                  '[prole] [subote] [u] LT',
              ];
              return lastWeekDays[this.day()];
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: 'za %s',
          past: 'pre %s',
          s: 'nekoliko sekundi',
          ss: translator$2.translate,
          m: translator$2.translate,
          mm: translator$2.translate,
          h: translator$2.translate,
          hh: translator$2.translate,
          d: 'dan',
          dd: translator$2.translate,
          M: 'mesec',
          MM: translator$2.translate,
          y: 'godinu',
          yy: translator$2.translate,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ss', {
      months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split(
          '_'
      ),
      monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
      weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split(
          '_'
      ),
      weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
      weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
      },
      calendar: {
          sameDay: '[Namuhla nga] LT',
          nextDay: '[Kusasa nga] LT',
          nextWeek: 'dddd [nga] LT',
          lastDay: '[Itolo nga] LT',
          lastWeek: 'dddd [leliphelile] [nga] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'nga %s',
          past: 'wenteka nga %s',
          s: 'emizuzwana lomcane',
          ss: '%d mzuzwana',
          m: 'umzuzu',
          mm: '%d emizuzu',
          h: 'lihora',
          hh: '%d emahora',
          d: 'lilanga',
          dd: '%d emalanga',
          M: 'inyanga',
          MM: '%d tinyanga',
          y: 'umnyaka',
          yy: '%d iminyaka',
      },
      meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
      meridiem: function (hours, minutes, isLower) {
          if (hours < 11) {
              return 'ekuseni';
          } else if (hours < 15) {
              return 'emini';
          } else if (hours < 19) {
              return 'entsambama';
          } else {
              return 'ebusuku';
          }
      },
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === 'ekuseni') {
              return hour;
          } else if (meridiem === 'emini') {
              return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
              if (hour === 0) {
                  return 0;
              }
              return hour + 12;
          }
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('sv', {
      months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split(
          '_'
      ),
      monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
      weekdays: 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
      weekdaysShort: 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
      weekdaysMin: 's_m_ti_on_to_fr_l'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY [kl.] HH:mm',
          LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
          lll: 'D MMM YYYY HH:mm',
          llll: 'ddd D MMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Idag] LT',
          nextDay: '[Imorgon] LT',
          lastDay: '[Igr] LT',
          nextWeek: '[P] dddd LT',
          lastWeek: '[I] dddd[s] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'om %s',
          past: 'fr %s sedan',
          s: 'ngra sekunder',
          ss: '%d sekunder',
          m: 'en minut',
          mm: '%d minuter',
          h: 'en timme',
          hh: '%d timmar',
          d: 'en dag',
          dd: '%d dagar',
          M: 'en mnad',
          MM: '%d mnader',
          y: 'ett r',
          yy: '%d r',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? ':e'
                      : b === 1
                      ? ':a'
                      : b === 2
                      ? ':a'
                      : b === 3
                      ? ':e'
                      : ':e';
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('sw', {
      months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split(
          '_'
      ),
      monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
      weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split(
          '_'
      ),
      weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
      weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'hh:mm A',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[leo saa] LT',
          nextDay: '[kesho saa] LT',
          nextWeek: '[wiki ijayo] dddd [saat] LT',
          lastDay: '[jana] LT',
          lastWeek: '[wiki iliyopita] dddd [saat] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s baadaye',
          past: 'tokea %s',
          s: 'hivi punde',
          ss: 'sekunde %d',
          m: 'dakika moja',
          mm: 'dakika %d',
          h: 'saa limoja',
          hh: 'masaa %d',
          d: 'siku moja',
          dd: 'siku %d',
          M: 'mwezi mmoja',
          MM: 'miezi %d',
          y: 'mwaka mmoja',
          yy: 'miaka %d',
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var symbolMap$g = {
          1: '',
          2: '',
          3: '',
          4: '',
          5: '',
          6: '',
          7: '',
          8: '',
          9: '',
          0: '',
      },
      numberMap$f = {
          '': '1',
          '': '2',
          '': '3',
          '': '4',
          '': '5',
          '': '6',
          '': '7',
          '': '8',
          '': '9',
          '': '0',
      };

  hooks.defineLocale('ta', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split(
          '_'
      ),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, HH:mm',
          LLLL: 'dddd, D MMMM YYYY, HH:mm',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[] LT',
          lastWeek: '[ ] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: '  ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: '  ',
          hh: '%d  ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function (number) {
          return number + '';
      },
      preparse: function (string) {
          return string.replace(/[]/g, function (match) {
              return numberMap$f[match];
          });
      },
      postformat: function (string) {
          return string.replace(/\d/g, function (match) {
              return symbolMap$g[match];
          });
      },
      // refer http://ta.wikipedia.org/s/1er1
      meridiemParse: /|||||/,
      meridiem: function (hour, minute, isLower) {
          if (hour < 2) {
              return ' ';
          } else if (hour < 6) {
              return ' '; // 
          } else if (hour < 10) {
              return ' '; // 
          } else if (hour < 14) {
              return ' '; // 
          } else if (hour < 18) {
              return ' '; // 
          } else if (hour < 22) {
              return ' '; // 
          } else {
              return ' ';
          }
      },
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '') {
              return hour < 2 ? hour : hour + 12;
          } else if (meridiem === '' || meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 10 ? hour : hour + 12;
          } else {
              return hour + 12;
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('te', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '._.__.____._._._._.'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'A h:mm',
          LTS: 'A h:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY, A h:mm',
          LLLL: 'dddd, D MMMM YYYY, A h:mm',
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: 'dddd, LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd, LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: '%d',
      meridiemParse: /|||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '') {
              return hour < 4 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 10 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 10) {
              return '';
          } else if (hour < 17) {
              return '';
          } else if (hour < 20) {
              return '';
          } else {
              return '';
          }
      },
      week: {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('tet', {
      months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split(
          '_'
      ),
      monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
      weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
      weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
      weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Ohin iha] LT',
          nextDay: '[Aban iha] LT',
          nextWeek: 'dddd [iha] LT',
          lastDay: '[Horiseik iha] LT',
          lastWeek: 'dddd [semana kotuk] [iha] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'iha %s',
          past: '%s liuba',
          s: 'segundu balun',
          ss: 'segundu %d',
          m: 'minutu ida',
          mm: 'minutu %d',
          h: 'oras ida',
          hh: 'oras %d',
          d: 'loron ida',
          dd: 'loron %d',
          M: 'fulan ida',
          MM: 'fulan %d',
          y: 'tinan ida',
          yy: 'tinan %d',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var suffixes$3 = {
      0: '-',
      1: '-',
      2: '-',
      3: '-',
      4: '-',
      5: '-',
      6: '-',
      7: '-',
      8: '-',
      9: '-',
      10: '-',
      12: '-',
      13: '-',
      20: '-',
      30: '-',
      40: '-',
      50: '-',
      60: '-',
      70: '-',
      80: '-',
      90: '-',
      100: '-',
  };

  hooks.defineLocale('tg', {
      months: {
          format: '___________'.split(
              '_'
          ),
          standalone: '___________'.split(
              '_'
          ),
      },
      monthsShort: '___________'.split('_'),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          lastDay: '[ ] LT',
          nextWeek: 'dddd[] [  ] LT',
          lastWeek: 'dddd[] [  ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: '%s ',
          s: ' ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      meridiemParse: /|||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '') {
              return hour < 4 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 11) {
              return '';
          } else if (hour < 16) {
              return '';
          } else if (hour < 19) {
              return '';
          } else {
              return '';
          }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
      ordinal: function (number) {
          var a = number % 10,
              b = number >= 100 ? 100 : null;
          return number + (suffixes$3[number] || suffixes$3[a] || suffixes$3[b]);
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 1th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('th', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '.._.._.._.._.._.._.._.._.._.._.._..'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'), // yes, three characters difference
      weekdaysMin: '._._._._._._.'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'H:mm',
          LTS: 'H:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY  H:mm',
          LLLL: 'dddd D MMMM YYYY  H:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return input === '';
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: 'dddd[ ] LT',
          lastDay: '[ ] LT',
          lastWeek: '[]dddd[ ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: '%s',
          s: '',
          ss: '%d ',
          m: '1 ',
          mm: '%d ',
          h: '1 ',
          hh: '%d ',
          d: '1 ',
          dd: '%d ',
          w: '1 ',
          ww: '%d ',
          M: '1 ',
          MM: '%d ',
          y: '1 ',
          yy: '%d ',
      },
  });

  //! moment.js locale configuration

  var suffixes$4 = {
      1: "'inji",
      5: "'inji",
      8: "'inji",
      70: "'inji",
      80: "'inji",
      2: "'nji",
      7: "'nji",
      20: "'nji",
      50: "'nji",
      3: "'nji",
      4: "'nji",
      100: "'nji",
      6: "'njy",
      9: "'unjy",
      10: "'unjy",
      30: "'unjy",
      60: "'ynjy",
      90: "'ynjy",
  };

  hooks.defineLocale('tk', {
      months: 'anwar_Fewral_Mart_Aprel_Ma_Iun_Iul_Awgust_Sentabr_Oktabr_Noabr_Dekabr'.split(
          '_'
      ),
      monthsShort: 'an_Few_Mar_Apr_Ma_In_Il_Awg_Sen_Okt_No_Dek'.split('_'),
      weekdays: 'ekenbe_Duenbe_Sienbe_arenbe_Penenbe_Anna_enbe'.split(
          '_'
      ),
      weekdaysShort: 'ek_Du_Si_ar_Pen_Ann_en'.split('_'),
      weekdaysMin: 'k_D_S_r_Pn_An_n'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[bugn sagat] LT',
          nextDay: '[ertir sagat] LT',
          nextWeek: '[indiki] dddd [sagat] LT',
          lastDay: '[dn] LT',
          lastWeek: '[geen] dddd [sagat] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s so',
          past: '%s ',
          s: 'birne sekunt',
          m: 'bir minut',
          mm: '%d minut',
          h: 'bir sagat',
          hh: '%d sagat',
          d: 'bir gn',
          dd: '%d gn',
          M: 'bir a',
          MM: '%d a',
          y: 'bir yl',
          yy: '%d yl',
      },
      ordinal: function (number, period) {
          switch (period) {
              case 'd':
              case 'D':
              case 'Do':
              case 'DD':
                  return number;
              default:
                  if (number === 0) {
                      // special case for zero
                      return number + "'unjy";
                  }
                  var a = number % 10,
                      b = (number % 100) - a,
                      c = number >= 100 ? 100 : null;
                  return number + (suffixes$4[a] || suffixes$4[b] || suffixes$4[c]);
          }
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('tl-ph', {
      months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split(
          '_'
      ),
      monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
      weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split(
          '_'
      ),
      weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
      weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'MM/D/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY HH:mm',
          LLLL: 'dddd, MMMM DD, YYYY HH:mm',
      },
      calendar: {
          sameDay: 'LT [ngayong araw]',
          nextDay: '[Bukas ng] LT',
          nextWeek: 'LT [sa susunod na] dddd',
          lastDay: 'LT [kahapon]',
          lastWeek: 'LT [noong nakaraang] dddd',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'sa loob ng %s',
          past: '%s ang nakalipas',
          s: 'ilang segundo',
          ss: '%d segundo',
          m: 'isang minuto',
          mm: '%d minuto',
          h: 'isang oras',
          hh: '%d oras',
          d: 'isang araw',
          dd: '%d araw',
          M: 'isang buwan',
          MM: '%d buwan',
          y: 'isang taon',
          yy: '%d taon',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function (number) {
          return number;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

  function translateFuture(output) {
      var time = output;
      time =
          output.indexOf('jaj') !== -1
              ? time.slice(0, -3) + 'leS'
              : output.indexOf('jar') !== -1
              ? time.slice(0, -3) + 'waQ'
              : output.indexOf('DIS') !== -1
              ? time.slice(0, -3) + 'nem'
              : time + ' pIq';
      return time;
  }

  function translatePast(output) {
      var time = output;
      time =
          output.indexOf('jaj') !== -1
              ? time.slice(0, -3) + 'Hu'
              : output.indexOf('jar') !== -1
              ? time.slice(0, -3) + 'wen'
              : output.indexOf('DIS') !== -1
              ? time.slice(0, -3) + 'ben'
              : time + ' ret';
      return time;
  }

  function translate$a(number, withoutSuffix, string, isFuture) {
      var numberNoun = numberAsNoun(number);
      switch (string) {
          case 'ss':
              return numberNoun + ' lup';
          case 'mm':
              return numberNoun + ' tup';
          case 'hh':
              return numberNoun + ' rep';
          case 'dd':
              return numberNoun + ' jaj';
          case 'MM':
              return numberNoun + ' jar';
          case 'yy':
              return numberNoun + ' DIS';
      }
  }

  function numberAsNoun(number) {
      var hundred = Math.floor((number % 1000) / 100),
          ten = Math.floor((number % 100) / 10),
          one = number % 10,
          word = '';
      if (hundred > 0) {
          word += numbersNouns[hundred] + 'vatlh';
      }
      if (ten > 0) {
          word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
      }
      if (one > 0) {
          word += (word !== '' ? ' ' : '') + numbersNouns[one];
      }
      return word === '' ? 'pagh' : word;
  }

  hooks.defineLocale('tlh', {
      months: 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split(
          '_'
      ),
      monthsShort: 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
          '_'
      ),
      weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
          '_'
      ),
      weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
          '_'
      ),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[DaHjaj] LT',
          nextDay: '[waleS] LT',
          nextWeek: 'LLL',
          lastDay: '[waHu] LT',
          lastWeek: 'LLL',
          sameElse: 'L',
      },
      relativeTime: {
          future: translateFuture,
          past: translatePast,
          s: 'puS lup',
          ss: translate$a,
          m: 'wa tup',
          mm: translate$a,
          h: 'wa rep',
          hh: translate$a,
          d: 'wa jaj',
          dd: translate$a,
          M: 'wa jar',
          MM: translate$a,
          y: 'wa DIS',
          yy: translate$a,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var suffixes$5 = {
      1: "'inci",
      5: "'inci",
      8: "'inci",
      70: "'inci",
      80: "'inci",
      2: "'nci",
      7: "'nci",
      20: "'nci",
      50: "'nci",
      3: "'nc",
      4: "'nc",
      100: "'nc",
      6: "'nc",
      9: "'uncu",
      10: "'uncu",
      30: "'uncu",
      60: "'nc",
      90: "'nc",
  };

  hooks.defineLocale('tr', {
      months: 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split(
          '_'
      ),
      monthsShort: 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
      weekdays: 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split(
          '_'
      ),
      weekdaysShort: 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
      weekdaysMin: 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
      meridiem: function (hours, minutes, isLower) {
          if (hours < 12) {
              return isLower ? '' : '';
          } else {
              return isLower ? 's' : 'S';
          }
      },
      meridiemParse: /||s|S/,
      isPM: function (input) {
          return input === 's' || input === 'S';
      },
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[bugn saat] LT',
          nextDay: '[yarn saat] LT',
          nextWeek: '[gelecek] dddd [saat] LT',
          lastDay: '[dn] LT',
          lastWeek: '[geen] dddd [saat] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s sonra',
          past: '%s nce',
          s: 'birka saniye',
          ss: '%d saniye',
          m: 'bir dakika',
          mm: '%d dakika',
          h: 'bir saat',
          hh: '%d saat',
          d: 'bir gn',
          dd: '%d gn',
          w: 'bir hafta',
          ww: '%d hafta',
          M: 'bir ay',
          MM: '%d ay',
          y: 'bir yl',
          yy: '%d yl',
      },
      ordinal: function (number, period) {
          switch (period) {
              case 'd':
              case 'D':
              case 'Do':
              case 'DD':
                  return number;
              default:
                  if (number === 0) {
                      // special case for zero
                      return number + "'nc";
                  }
                  var a = number % 10,
                      b = (number % 100) - a,
                      c = number >= 100 ? 100 : null;
                  return number + (suffixes$5[a] || suffixes$5[b] || suffixes$5[c]);
          }
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
  // This is currently too difficult (maybe even impossible) to add.
  hooks.defineLocale('tzl', {
      months: 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split(
          '_'
      ),
      monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
      weekdays: 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
      weekdaysShort: 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
      weekdaysMin: 'S_L_Ma_M_Xh_Vi_S'.split('_'),
      longDateFormat: {
          LT: 'HH.mm',
          LTS: 'HH.mm.ss',
          L: 'DD.MM.YYYY',
          LL: 'D. MMMM [dallas] YYYY',
          LLL: 'D. MMMM [dallas] YYYY HH.mm',
          LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm',
      },
      meridiemParse: /d\'o|d\'a/i,
      isPM: function (input) {
          return "d'o" === input.toLowerCase();
      },
      meridiem: function (hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? "d'o" : "D'O";
          } else {
              return isLower ? "d'a" : "D'A";
          }
      },
      calendar: {
          sameDay: '[oxhi ] LT',
          nextDay: '[dem ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[ieiri ] LT',
          lastWeek: '[sr el] dddd [lasteu ] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'osprei %s',
          past: 'ja%s',
          s: processRelativeTime$8,
          ss: processRelativeTime$8,
          m: processRelativeTime$8,
          mm: processRelativeTime$8,
          h: processRelativeTime$8,
          hh: processRelativeTime$8,
          d: processRelativeTime$8,
          dd: processRelativeTime$8,
          M: processRelativeTime$8,
          MM: processRelativeTime$8,
          y: processRelativeTime$8,
          yy: processRelativeTime$8,
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: '%d.',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  function processRelativeTime$8(number, withoutSuffix, key, isFuture) {
      var format = {
          s: ['viensas secunds', "'iensas secunds"],
          ss: [number + ' secunds', '' + number + ' secunds'],
          m: ["'n mut", "'iens mut"],
          mm: [number + ' muts', '' + number + ' muts'],
          h: ["'n ora", "'iensa ora"],
          hh: [number + ' oras', '' + number + ' oras'],
          d: ["'n ziua", "'iensa ziua"],
          dd: [number + ' ziuas', '' + number + ' ziuas'],
          M: ["'n mes", "'iens mes"],
          MM: [number + ' mesen', '' + number + ' mesen'],
          y: ["'n ar", "'iens ar"],
          yy: [number + ' ars', '' + number + ' ars'],
      };
      return isFuture
          ? format[key][0]
          : withoutSuffix
          ? format[key][0]
          : format[key][1];
  }

  //! moment.js locale configuration

  hooks.defineLocale('tzm-latn', {
      months: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split(
          '_'
      ),
      monthsShort: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split(
          '_'
      ),
      weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
      weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
      weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[asdkh g] LT',
          nextDay: '[aska g] LT',
          nextWeek: 'dddd [g] LT',
          lastDay: '[assant g] LT',
          lastWeek: 'dddd [g] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'dadkh s yan %s',
          past: 'yan %s',
          s: 'imik',
          ss: '%d imik',
          m: 'minu',
          mm: '%d minu',
          h: 'saa',
          hh: '%d tassain',
          d: 'ass',
          dd: '%d ossan',
          M: 'ayowr',
          MM: '%d iyyirn',
          y: 'asgas',
          yy: '%d isgasn',
      },
      week: {
          dow: 6, // Saturday is the first day of the week.
          doy: 12, // The week that contains Jan 12th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('tzm', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[ ] LT',
          lastWeek: 'dddd [] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '   %s',
          past: ' %s',
          s: '',
          ss: '%d ',
          m: '',
          mm: '%d ',
          h: '',
          hh: '%d ',
          d: '',
          dd: '%d o',
          M: 'o',
          MM: '%d ',
          y: '',
          yy: '%d ',
      },
      week: {
          dow: 6, // Saturday is the first day of the week.
          doy: 12, // The week that contains Jan 12th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('ug-cn', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: '______'.split(
          '_'
      ),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY-MM-DD',
          LL: 'YYYY-M-D-',
          LLL: 'YYYY-M-D- HH:mm',
          LLLL: 'dddd YYYY-M-D- HH:mm',
      },
      meridiemParse: / || || |/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (
              meridiem === ' ' ||
              meridiem === '' ||
              meridiem === ' '
          ) {
              return hour;
          } else if (meridiem === ' ' || meridiem === '') {
              return hour + 12;
          } else {
              return hour >= 11 ? hour : hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          var hm = hour * 100 + minute;
          if (hm < 600) {
              return ' ';
          } else if (hm < 900) {
              return '';
          } else if (hm < 1130) {
              return ' ';
          } else if (hm < 1230) {
              return '';
          } else if (hm < 1800) {
              return ' ';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: '[] dddd [] LT',
          lastDay: '[] LT',
          lastWeek: '[] dddd [] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },

      dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
      ordinal: function (number, period) {
          switch (period) {
              case 'd':
              case 'D':
              case 'DDD':
                  return number + '-';
              case 'w':
              case 'W':
                  return number + '-';
              default:
                  return number;
          }
      },
      preparse: function (string) {
          return string.replace(//g, ',');
      },
      postformat: function (string) {
          return string.replace(/,/g, '');
      },
      week: {
          // GB/T 7408-1994ISO 8601:1988
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 1st is the first week of the year.
      },
  });

  //! moment.js locale configuration

  function plural$6(word, num) {
      var forms = word.split('_');
      return num % 10 === 1 && num % 100 !== 11
          ? forms[0]
          : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
          ? forms[1]
          : forms[2];
  }
  function relativeTimeWithPlural$4(number, withoutSuffix, key) {
      var format = {
          ss: withoutSuffix ? '__' : '__',
          mm: withoutSuffix ? '__' : '__',
          hh: withoutSuffix ? '__' : '__',
          dd: '__',
          MM: '__',
          yy: '__',
      };
      if (key === 'm') {
          return withoutSuffix ? '' : '';
      } else if (key === 'h') {
          return withoutSuffix ? '' : '';
      } else {
          return number + ' ' + plural$6(format[key], +number);
      }
  }
  function weekdaysCaseReplace(m, format) {
      var weekdays = {
              nominative: '______'.split(
                  '_'
              ),
              accusative: '______'.split(
                  '_'
              ),
              genitive: '______'.split(
                  '_'
              ),
          },
          nounCase;

      if (m === true) {
          return weekdays['nominative']
              .slice(1, 7)
              .concat(weekdays['nominative'].slice(0, 1));
      }
      if (!m) {
          return weekdays['nominative'];
      }

      nounCase = /(\[[]\]) ?dddd/.test(format)
          ? 'accusative'
          : /\[?(?:|)? ?\] ?dddd/.test(format)
          ? 'genitive'
          : 'nominative';
      return weekdays[nounCase][m.day()];
  }
  function processHoursFunction(str) {
      return function () {
          return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
      };
  }

  hooks.defineLocale('uk', {
      months: {
          format: '___________'.split(
              '_'
          ),
          standalone: '___________'.split(
              '_'
          ),
      },
      monthsShort: '___________'.split(
          '_'
      ),
      weekdays: weekdaysCaseReplace,
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD.MM.YYYY',
          LL: 'D MMMM YYYY .',
          LLL: 'D MMMM YYYY ., HH:mm',
          LLLL: 'dddd, D MMMM YYYY ., HH:mm',
      },
      calendar: {
          sameDay: processHoursFunction('[ '),
          nextDay: processHoursFunction('[ '),
          lastDay: processHoursFunction('[ '),
          nextWeek: processHoursFunction('[] dddd ['),
          lastWeek: function () {
              switch (this.day()) {
                  case 0:
                  case 3:
                  case 5:
                  case 6:
                      return processHoursFunction('[] dddd [').call(this);
                  case 1:
                  case 2:
                  case 4:
                      return processHoursFunction('[] dddd [').call(this);
              }
          },
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s',
          past: '%s ',
          s: ' ',
          ss: relativeTimeWithPlural$4,
          m: relativeTimeWithPlural$4,
          mm: relativeTimeWithPlural$4,
          h: '',
          hh: relativeTimeWithPlural$4,
          d: '',
          dd: relativeTimeWithPlural$4,
          M: '',
          MM: relativeTimeWithPlural$4,
          y: '',
          yy: relativeTimeWithPlural$4,
      },
      // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
      meridiemParse: /|||/,
      isPM: function (input) {
          return /^(|)$/.test(input);
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 4) {
              return '';
          } else if (hour < 12) {
              return '';
          } else if (hour < 17) {
              return '';
          } else {
              return '';
          }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
      ordinal: function (number, period) {
          switch (period) {
              case 'M':
              case 'd':
              case 'DDD':
              case 'w':
              case 'W':
                  return number + '-';
              case 'D':
                  return number + '-';
              default:
                  return number;
          }
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  var months$b = [
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
          '',
      ],
      days$2 = ['', '', '', '', '', '', ''];

  hooks.defineLocale('ur', {
      months: months$b,
      monthsShort: months$b,
      weekdays: days$2,
      weekdaysShort: days$2,
      weekdaysMin: days$2,
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd D MMMM YYYY HH:mm',
      },
      meridiemParse: /|/,
      isPM: function (input) {
          return '' === input;
      },
      meridiem: function (hour, minute, isLower) {
          if (hour < 12) {
              return '';
          }
          return '';
      },
      calendar: {
          sameDay: '[ ] LT',
          nextDay: '[ ] LT',
          nextWeek: 'dddd [] LT',
          lastDay: '[  ] LT',
          lastWeek: '[] dddd [] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ',
          past: '%s ',
          s: ' ',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      preparse: function (string) {
          return string.replace(//g, ',');
      },
      postformat: function (string) {
          return string.replace(/,/g, '');
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('uz-latn', {
      months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split(
          '_'
      ),
      monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
      weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split(
          '_'
      ),
      weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
      weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'D MMMM YYYY, dddd HH:mm',
      },
      calendar: {
          sameDay: '[Bugun soat] LT [da]',
          nextDay: '[Ertaga] LT [da]',
          nextWeek: 'dddd [kuni soat] LT [da]',
          lastDay: '[Kecha soat] LT [da]',
          lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
          sameElse: 'L',
      },
      relativeTime: {
          future: 'Yaqin %s ichida',
          past: 'Bir necha %s oldin',
          s: 'soniya',
          ss: '%d soniya',
          m: 'bir daqiqa',
          mm: '%d daqiqa',
          h: 'bir soat',
          hh: '%d soat',
          d: 'bir kun',
          dd: '%d kun',
          M: 'bir oy',
          MM: '%d oy',
          y: 'bir yil',
          yy: '%d yil',
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 7th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('uz', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '___________'.split('_'),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'D MMMM YYYY, dddd HH:mm',
      },
      calendar: {
          sameDay: '[ ] LT []',
          nextDay: '[] LT []',
          nextWeek: 'dddd [ ] LT []',
          lastDay: '[ ] LT []',
          lastWeek: '[] dddd [ ] LT []',
          sameElse: 'L',
      },
      relativeTime: {
          future: ' %s ',
          past: '  %s ',
          s: '',
          ss: '%d ',
          m: ' ',
          mm: '%d ',
          h: ' ',
          hh: '%d ',
          d: ' ',
          dd: '%d ',
          M: ' ',
          MM: '%d ',
          y: ' ',
          yy: '%d ',
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 7, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('vi', {
      months: 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split(
          '_'
      ),
      monthsShort: 'Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split(
          '_'
      ),
      weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
      weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
      weekdaysParseExact: true,
      meridiemParse: /sa|ch/i,
      isPM: function (input) {
          return /^ch$/i.test(input);
      },
      meridiem: function (hours, minutes, isLower) {
          if (hours < 12) {
              return isLower ? 'sa' : 'SA';
          } else {
              return isLower ? 'ch' : 'CH';
          }
      },
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM [nm] YYYY',
          LLL: 'D MMMM [nm] YYYY HH:mm',
          LLLL: 'dddd, D MMMM [nm] YYYY HH:mm',
          l: 'DD/M/YYYY',
          ll: 'D MMM YYYY',
          lll: 'D MMM YYYY HH:mm',
          llll: 'ddd, D MMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[Hm nay lc] LT',
          nextDay: '[Ngy mai lc] LT',
          nextWeek: 'dddd [tun ti lc] LT',
          lastDay: '[Hm qua lc] LT',
          lastWeek: 'dddd [tun trc lc] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '%s ti',
          past: '%s trc',
          s: 'vi giy',
          ss: '%d giy',
          m: 'mt pht',
          mm: '%d pht',
          h: 'mt gi',
          hh: '%d gi',
          d: 'mt ngy',
          dd: '%d ngy',
          w: 'mt tun',
          ww: '%d tun',
          M: 'mt thng',
          MM: '%d thng',
          y: 'mt nm',
          yy: '%d nm',
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function (number) {
          return number;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('x-pseudo', {
      months: 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split(
          '_'
      ),
      monthsShort: 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split(
          '_'
      ),
      monthsParseExact: true,
      weekdays: 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split(
          '_'
      ),
      weekdaysShort: 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
      weekdaysMin: 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
      weekdaysParseExact: true,
      longDateFormat: {
          LT: 'HH:mm',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY HH:mm',
          LLLL: 'dddd, D MMMM YYYY HH:mm',
      },
      calendar: {
          sameDay: '[T~d~ t] LT',
          nextDay: '[T~m~rr~w t] LT',
          nextWeek: 'dddd [t] LT',
          lastDay: '[~st~rd~ t] LT',
          lastWeek: '[L~st] dddd [t] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: '~ %s',
          past: '%s ~g',
          s: ' ~fw ~sc~ds',
          ss: '%d s~c~ds',
          m: ' ~m~t',
          mm: '%d m~~ts',
          h: '~ h~r',
          hh: '%d h~rs',
          d: ' ~d',
          dd: '%d d~s',
          M: ' ~m~th',
          MM: '%d m~t~hs',
          y: ' ~r',
          yy: '%d ~rs',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function (number) {
          var b = number % 10,
              output =
                  ~~((number % 100) / 10) === 1
                      ? 'th'
                      : b === 1
                      ? 'st'
                      : b === 2
                      ? 'nd'
                      : b === 3
                      ? 'rd'
                      : 'th';
          return number + output;
      },
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('yo', {
      months: 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split(
          '_'
      ),
      monthsShort: 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
      weekdays: 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
      weekdaysShort: 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
      weekdaysMin: 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
      longDateFormat: {
          LT: 'h:mm A',
          LTS: 'h:mm:ss A',
          L: 'DD/MM/YYYY',
          LL: 'D MMMM YYYY',
          LLL: 'D MMMM YYYY h:mm A',
          LLLL: 'dddd, D MMMM YYYY h:mm A',
      },
      calendar: {
          sameDay: '[Oni ni] LT',
          nextDay: '[la ni] LT',
          nextWeek: "dddd [s ton'b] [ni] LT",
          lastDay: '[Ana ni] LT',
          lastWeek: 'dddd [s tol] [ni] LT',
          sameElse: 'L',
      },
      relativeTime: {
          future: 'ni %s',
          past: '%s kja',
          s: 'isju aaya die',
          ss: 'aaya %d',
          m: 'isju kan',
          mm: 'isju %d',
          h: 'wakati kan',
          hh: 'wakati %d',
          d: 'j kan',
          dd: 'j %d',
          M: 'osu kan',
          MM: 'osu %d',
          y: 'dun kan',
          yy: 'dun %d',
      },
      dayOfMonthOrdinalParse: /j\s\d{1,2}/,
      ordinal: 'j %d',
      week: {
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('zh-cn', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYYMD',
          LLL: 'YYYYMDAhmm',
          LLLL: 'YYYYMDddddAhmm',
          l: 'YYYY/M/D',
          ll: 'YYYYMD',
          lll: 'YYYYMD HH:mm',
          llll: 'YYYYMDdddd HH:mm',
      },
      meridiemParse: /|||||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '' || meridiem === '' || meridiem === '') {
              return hour;
          } else if (meridiem === '' || meridiem === '') {
              return hour + 12;
          } else {
              // ''
              return hour >= 11 ? hour : hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          var hm = hour * 100 + minute;
          if (hm < 600) {
              return '';
          } else if (hm < 900) {
              return '';
          } else if (hm < 1130) {
              return '';
          } else if (hm < 1230) {
              return '';
          } else if (hm < 1800) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[]LT',
          nextDay: '[]LT',
          nextWeek: function (now) {
              if (now.week() !== this.week()) {
                  return '[]dddLT';
              } else {
                  return '[]dddLT';
              }
          },
          lastDay: '[]LT',
          lastWeek: function (now) {
              if (this.week() !== now.week()) {
                  return '[]dddLT';
              } else {
                  return '[]dddLT';
              }
          },
          sameElse: 'L',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(||)/,
      ordinal: function (number, period) {
          switch (period) {
              case 'd':
              case 'D':
              case 'DDD':
                  return number + '';
              case 'M':
                  return number + '';
              case 'w':
              case 'W':
                  return number + '';
              default:
                  return number;
          }
      },
      relativeTime: {
          future: '%s',
          past: '%s',
          s: '',
          ss: '%d ',
          m: '1 ',
          mm: '%d ',
          h: '1 ',
          hh: '%d ',
          d: '1 ',
          dd: '%d ',
          w: '1 ',
          ww: '%d ',
          M: '1 ',
          MM: '%d ',
          y: '1 ',
          yy: '%d ',
      },
      week: {
          // GB/T 7408-1994ISO 8601:1988
          dow: 1, // Monday is the first day of the week.
          doy: 4, // The week that contains Jan 4th is the first week of the year.
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('zh-hk', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYYMD',
          LLL: 'YYYYMD HH:mm',
          LLLL: 'YYYYMDdddd HH:mm',
          l: 'YYYY/M/D',
          ll: 'YYYYMD',
          lll: 'YYYYMD HH:mm',
          llll: 'YYYYMDdddd HH:mm',
      },
      meridiemParse: /|||||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '' || meridiem === '' || meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === '' || meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          var hm = hour * 100 + minute;
          if (hm < 600) {
              return '';
          } else if (hm < 900) {
              return '';
          } else if (hm < 1200) {
              return '';
          } else if (hm === 1200) {
              return '';
          } else if (hm < 1800) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[]LT',
          nextDay: '[]LT',
          nextWeek: '[]ddddLT',
          lastDay: '[]LT',
          lastWeek: '[]ddddLT',
          sameElse: 'L',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(||)/,
      ordinal: function (number, period) {
          switch (period) {
              case 'd':
              case 'D':
              case 'DDD':
                  return number + '';
              case 'M':
                  return number + '';
              case 'w':
              case 'W':
                  return number + '';
              default:
                  return number;
          }
      },
      relativeTime: {
          future: '%s',
          past: '%s',
          s: '',
          ss: '%d ',
          m: '1 ',
          mm: '%d ',
          h: '1 ',
          hh: '%d ',
          d: '1 ',
          dd: '%d ',
          M: '1 ',
          MM: '%d ',
          y: '1 ',
          yy: '%d ',
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('zh-mo', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'DD/MM/YYYY',
          LL: 'YYYYMD',
          LLL: 'YYYYMD HH:mm',
          LLLL: 'YYYYMDdddd HH:mm',
          l: 'D/M/YYYY',
          ll: 'YYYYMD',
          lll: 'YYYYMD HH:mm',
          llll: 'YYYYMDdddd HH:mm',
      },
      meridiemParse: /|||||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '' || meridiem === '' || meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === '' || meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          var hm = hour * 100 + minute;
          if (hm < 600) {
              return '';
          } else if (hm < 900) {
              return '';
          } else if (hm < 1130) {
              return '';
          } else if (hm < 1230) {
              return '';
          } else if (hm < 1800) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: '[]dddd LT',
          lastDay: '[] LT',
          lastWeek: '[]dddd LT',
          sameElse: 'L',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(||)/,
      ordinal: function (number, period) {
          switch (period) {
              case 'd':
              case 'D':
              case 'DDD':
                  return number + '';
              case 'M':
                  return number + '';
              case 'w':
              case 'W':
                  return number + '';
              default:
                  return number;
          }
      },
      relativeTime: {
          future: '%s',
          past: '%s',
          s: '',
          ss: '%d ',
          m: '1 ',
          mm: '%d ',
          h: '1 ',
          hh: '%d ',
          d: '1 ',
          dd: '%d ',
          M: '1 ',
          MM: '%d ',
          y: '1 ',
          yy: '%d ',
      },
  });

  //! moment.js locale configuration

  hooks.defineLocale('zh-tw', {
      months: '___________'.split(
          '_'
      ),
      monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split(
          '_'
      ),
      weekdays: '______'.split('_'),
      weekdaysShort: '______'.split('_'),
      weekdaysMin: '______'.split('_'),
      longDateFormat: {
          LT: 'HH:mm',
          LTS: 'HH:mm:ss',
          L: 'YYYY/MM/DD',
          LL: 'YYYYMD',
          LLL: 'YYYYMD HH:mm',
          LLLL: 'YYYYMDdddd HH:mm',
          l: 'YYYY/M/D',
          ll: 'YYYYMD',
          lll: 'YYYYMD HH:mm',
          llll: 'YYYYMDdddd HH:mm',
      },
      meridiemParse: /|||||/,
      meridiemHour: function (hour, meridiem) {
          if (hour === 12) {
              hour = 0;
          }
          if (meridiem === '' || meridiem === '' || meridiem === '') {
              return hour;
          } else if (meridiem === '') {
              return hour >= 11 ? hour : hour + 12;
          } else if (meridiem === '' || meridiem === '') {
              return hour + 12;
          }
      },
      meridiem: function (hour, minute, isLower) {
          var hm = hour * 100 + minute;
          if (hm < 600) {
              return '';
          } else if (hm < 900) {
              return '';
          } else if (hm < 1130) {
              return '';
          } else if (hm < 1230) {
              return '';
          } else if (hm < 1800) {
              return '';
          } else {
              return '';
          }
      },
      calendar: {
          sameDay: '[] LT',
          nextDay: '[] LT',
          nextWeek: '[]dddd LT',
          lastDay: '[] LT',
          lastWeek: '[]dddd LT',
          sameElse: 'L',
      },
      dayOfMonthOrdinalParse: /\d{1,2}(||)/,
      ordinal: function (number, period) {
          switch (period) {
              case 'd':
              case 'D':
              case 'DDD':
                  return number + '';
              case 'M':
                  return number + '';
              case 'w':
              case 'W':
                  return number + '';
              default:
                  return number;
          }
      },
      relativeTime: {
          future: '%s',
          past: '%s',
          s: '',
          ss: '%d ',
          m: '1 ',
          mm: '%d ',
          h: '1 ',
          hh: '%d ',
          d: '1 ',
          dd: '%d ',
          M: '1 ',
          MM: '%d ',
          y: '1 ',
          yy: '%d ',
      },
  });

  hooks.locale('en');

  return hooks;

})));
/**
 * Swiper 6.8.1
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2021 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: August 3, 2021
 */

 !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).Swiper=t()}(this,(function(){"use strict";function e(e,t){for(var a=0;a<t.length;a++){var i=t[a];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function t(){return(t=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var i in a)Object.prototype.hasOwnProperty.call(a,i)&&(e[i]=a[i])}return e}).apply(this,arguments)}function a(e){return null!==e&&"object"==typeof e&&"constructor"in e&&e.constructor===Object}function i(e,t){void 0===e&&(e={}),void 0===t&&(t={}),Object.keys(t).forEach((function(s){void 0===e[s]?e[s]=t[s]:a(t[s])&&a(e[s])&&Object.keys(t[s]).length>0&&i(e[s],t[s])}))}var s={body:{},addEventListener:function(){},removeEventListener:function(){},activeElement:{blur:function(){},nodeName:""},querySelector:function(){return null},querySelectorAll:function(){return[]},getElementById:function(){return null},createEvent:function(){return{initEvent:function(){}}},createElement:function(){return{children:[],childNodes:[],style:{},setAttribute:function(){},getElementsByTagName:function(){return[]}}},createElementNS:function(){return{}},importNode:function(){return null},location:{hash:"",host:"",hostname:"",href:"",origin:"",pathname:"",protocol:"",search:""}};function r(){var e="undefined"!=typeof document?document:{};return i(e,s),e}var n={document:s,navigator:{userAgent:""},location:{hash:"",host:"",hostname:"",href:"",origin:"",pathname:"",protocol:"",search:""},history:{replaceState:function(){},pushState:function(){},go:function(){},back:function(){}},CustomEvent:function(){return this},addEventListener:function(){},removeEventListener:function(){},getComputedStyle:function(){return{getPropertyValue:function(){return""}}},Image:function(){},Date:function(){},screen:{},setTimeout:function(){},clearTimeout:function(){},matchMedia:function(){return{}},requestAnimationFrame:function(e){return"undefined"==typeof setTimeout?(e(),null):setTimeout(e,0)},cancelAnimationFrame:function(e){"undefined"!=typeof setTimeout&&clearTimeout(e)}};function l(){var e="undefined"!=typeof window?window:{};return i(e,n),e}function o(e){return(o=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function d(e,t){return(d=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function p(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function u(e,t,a){return(u=p()?Reflect.construct:function(e,t,a){var i=[null];i.push.apply(i,t);var s=new(Function.bind.apply(e,i));return a&&d(s,a.prototype),s}).apply(null,arguments)}function c(e){var t="function"==typeof Map?new Map:void 0;return(c=function(e){if(null===e||(a=e,-1===Function.toString.call(a).indexOf("[native code]")))return e;var a;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,i)}function i(){return u(e,arguments,o(this).constructor)}return i.prototype=Object.create(e.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),d(i,e)})(e)}var h=function(e){var t,a;function i(t){var a,i,s;return a=e.call.apply(e,[this].concat(t))||this,i=function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(a),s=i.__proto__,Object.defineProperty(i,"__proto__",{get:function(){return s},set:function(e){s.__proto__=e}}),a}return a=e,(t=i).prototype=Object.create(a.prototype),t.prototype.constructor=t,t.__proto__=a,i}(c(Array));function v(e){void 0===e&&(e=[]);var t=[];return e.forEach((function(e){Array.isArray(e)?t.push.apply(t,v(e)):t.push(e)})),t}function f(e,t){return Array.prototype.filter.call(e,t)}function m(e,t){var a=l(),i=r(),s=[];if(!t&&e instanceof h)return e;if(!e)return new h(s);if("string"==typeof e){var n=e.trim();if(n.indexOf("<")>=0&&n.indexOf(">")>=0){var o="div";0===n.indexOf("<li")&&(o="ul"),0===n.indexOf("<tr")&&(o="tbody"),0!==n.indexOf("<td")&&0!==n.indexOf("<th")||(o="tr"),0===n.indexOf("<tbody")&&(o="table"),0===n.indexOf("<option")&&(o="select");var d=i.createElement(o);d.innerHTML=n;for(var p=0;p<d.childNodes.length;p+=1)s.push(d.childNodes[p])}else s=function(e,t){if("string"!=typeof e)return[e];for(var a=[],i=t.querySelectorAll(e),s=0;s<i.length;s+=1)a.push(i[s]);return a}(e.trim(),t||i)}else if(e.nodeType||e===a||e===i)s.push(e);else if(Array.isArray(e)){if(e instanceof h)return e;s=e}return new h(function(e){for(var t=[],a=0;a<e.length;a+=1)-1===t.indexOf(e[a])&&t.push(e[a]);return t}(s))}m.fn=h.prototype;var g,b,w,y={addClass:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=v(t.map((function(e){return e.split(" ")})));return this.forEach((function(e){var t;(t=e.classList).add.apply(t,i)})),this},removeClass:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=v(t.map((function(e){return e.split(" ")})));return this.forEach((function(e){var t;(t=e.classList).remove.apply(t,i)})),this},hasClass:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=v(t.map((function(e){return e.split(" ")})));return f(this,(function(e){return i.filter((function(t){return e.classList.contains(t)})).length>0})).length>0},toggleClass:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=v(t.map((function(e){return e.split(" ")})));this.forEach((function(e){i.forEach((function(t){e.classList.toggle(t)}))}))},attr:function(e,t){if(1===arguments.length&&"string"==typeof e)return this[0]?this[0].getAttribute(e):void 0;for(var a=0;a<this.length;a+=1)if(2===arguments.length)this[a].setAttribute(e,t);else for(var i in e)this[a][i]=e[i],this[a].setAttribute(i,e[i]);return this},removeAttr:function(e){for(var t=0;t<this.length;t+=1)this[t].removeAttribute(e);return this},transform:function(e){for(var t=0;t<this.length;t+=1)this[t].style.transform=e;return this},transition:function(e){for(var t=0;t<this.length;t+=1)this[t].style.transitionDuration="string"!=typeof e?e+"ms":e;return this},on:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=t[0],s=t[1],r=t[2],n=t[3];function l(e){var t=e.target;if(t){var a=e.target.dom7EventData||[];if(a.indexOf(e)<0&&a.unshift(e),m(t).is(s))r.apply(t,a);else for(var i=m(t).parents(),n=0;n<i.length;n+=1)m(i[n]).is(s)&&r.apply(i[n],a)}}function o(e){var t=e&&e.target&&e.target.dom7EventData||[];t.indexOf(e)<0&&t.unshift(e),r.apply(this,t)}"function"==typeof t[1]&&(i=t[0],r=t[1],n=t[2],s=void 0),n||(n=!1);for(var d,p=i.split(" "),u=0;u<this.length;u+=1){var c=this[u];if(s)for(d=0;d<p.length;d+=1){var h=p[d];c.dom7LiveListeners||(c.dom7LiveListeners={}),c.dom7LiveListeners[h]||(c.dom7LiveListeners[h]=[]),c.dom7LiveListeners[h].push({listener:r,proxyListener:l}),c.addEventListener(h,l,n)}else for(d=0;d<p.length;d+=1){var v=p[d];c.dom7Listeners||(c.dom7Listeners={}),c.dom7Listeners[v]||(c.dom7Listeners[v]=[]),c.dom7Listeners[v].push({listener:r,proxyListener:o}),c.addEventListener(v,o,n)}}return this},off:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=t[0],s=t[1],r=t[2],n=t[3];"function"==typeof t[1]&&(i=t[0],r=t[1],n=t[2],s=void 0),n||(n=!1);for(var l=i.split(" "),o=0;o<l.length;o+=1)for(var d=l[o],p=0;p<this.length;p+=1){var u=this[p],c=void 0;if(!s&&u.dom7Listeners?c=u.dom7Listeners[d]:s&&u.dom7LiveListeners&&(c=u.dom7LiveListeners[d]),c&&c.length)for(var h=c.length-1;h>=0;h-=1){var v=c[h];r&&v.listener===r||r&&v.listener&&v.listener.dom7proxy&&v.listener.dom7proxy===r?(u.removeEventListener(d,v.proxyListener,n),c.splice(h,1)):r||(u.removeEventListener(d,v.proxyListener,n),c.splice(h,1))}}return this},trigger:function(){for(var e=l(),t=arguments.length,a=new Array(t),i=0;i<t;i++)a[i]=arguments[i];for(var s=a[0].split(" "),r=a[1],n=0;n<s.length;n+=1)for(var o=s[n],d=0;d<this.length;d+=1){var p=this[d];if(e.CustomEvent){var u=new e.CustomEvent(o,{detail:r,bubbles:!0,cancelable:!0});p.dom7EventData=a.filter((function(e,t){return t>0})),p.dispatchEvent(u),p.dom7EventData=[],delete p.dom7EventData}}return this},transitionEnd:function(e){var t=this;return e&&t.on("transitionend",(function a(i){i.target===this&&(e.call(this,i),t.off("transitionend",a))})),this},outerWidth:function(e){if(this.length>0){if(e){var t=this.styles();return this[0].offsetWidth+parseFloat(t.getPropertyValue("margin-right"))+parseFloat(t.getPropertyValue("margin-left"))}return this[0].offsetWidth}return null},outerHeight:function(e){if(this.length>0){if(e){var t=this.styles();return this[0].offsetHeight+parseFloat(t.getPropertyValue("margin-top"))+parseFloat(t.getPropertyValue("margin-bottom"))}return this[0].offsetHeight}return null},styles:function(){var e=l();return this[0]?e.getComputedStyle(this[0],null):{}},offset:function(){if(this.length>0){var e=l(),t=r(),a=this[0],i=a.getBoundingClientRect(),s=t.body,n=a.clientTop||s.clientTop||0,o=a.clientLeft||s.clientLeft||0,d=a===e?e.scrollY:a.scrollTop,p=a===e?e.scrollX:a.scrollLeft;return{top:i.top+d-n,left:i.left+p-o}}return null},css:function(e,t){var a,i=l();if(1===arguments.length){if("string"!=typeof e){for(a=0;a<this.length;a+=1)for(var s in e)this[a].style[s]=e[s];return this}if(this[0])return i.getComputedStyle(this[0],null).getPropertyValue(e)}if(2===arguments.length&&"string"==typeof e){for(a=0;a<this.length;a+=1)this[a].style[e]=t;return this}return this},each:function(e){return e?(this.forEach((function(t,a){e.apply(t,[t,a])})),this):this},html:function(e){if(void 0===e)return this[0]?this[0].innerHTML:null;for(var t=0;t<this.length;t+=1)this[t].innerHTML=e;return this},text:function(e){if(void 0===e)return this[0]?this[0].textContent.trim():null;for(var t=0;t<this.length;t+=1)this[t].textContent=e;return this},is:function(e){var t,a,i=l(),s=r(),n=this[0];if(!n||void 0===e)return!1;if("string"==typeof e){if(n.matches)return n.matches(e);if(n.webkitMatchesSelector)return n.webkitMatchesSelector(e);if(n.msMatchesSelector)return n.msMatchesSelector(e);for(t=m(e),a=0;a<t.length;a+=1)if(t[a]===n)return!0;return!1}if(e===s)return n===s;if(e===i)return n===i;if(e.nodeType||e instanceof h){for(t=e.nodeType?[e]:e,a=0;a<t.length;a+=1)if(t[a]===n)return!0;return!1}return!1},index:function(){var e,t=this[0];if(t){for(e=0;null!==(t=t.previousSibling);)1===t.nodeType&&(e+=1);return e}},eq:function(e){if(void 0===e)return this;var t=this.length;if(e>t-1)return m([]);if(e<0){var a=t+e;return m(a<0?[]:[this[a]])}return m([this[e]])},append:function(){for(var e,t=r(),a=0;a<arguments.length;a+=1){e=a<0||arguments.length<=a?void 0:arguments[a];for(var i=0;i<this.length;i+=1)if("string"==typeof e){var s=t.createElement("div");for(s.innerHTML=e;s.firstChild;)this[i].appendChild(s.firstChild)}else if(e instanceof h)for(var n=0;n<e.length;n+=1)this[i].appendChild(e[n]);else this[i].appendChild(e)}return this},prepend:function(e){var t,a,i=r();for(t=0;t<this.length;t+=1)if("string"==typeof e){var s=i.createElement("div");for(s.innerHTML=e,a=s.childNodes.length-1;a>=0;a-=1)this[t].insertBefore(s.childNodes[a],this[t].childNodes[0])}else if(e instanceof h)for(a=0;a<e.length;a+=1)this[t].insertBefore(e[a],this[t].childNodes[0]);else this[t].insertBefore(e,this[t].childNodes[0]);return this},next:function(e){return this.length>0?e?this[0].nextElementSibling&&m(this[0].nextElementSibling).is(e)?m([this[0].nextElementSibling]):m([]):this[0].nextElementSibling?m([this[0].nextElementSibling]):m([]):m([])},nextAll:function(e){var t=[],a=this[0];if(!a)return m([]);for(;a.nextElementSibling;){var i=a.nextElementSibling;e?m(i).is(e)&&t.push(i):t.push(i),a=i}return m(t)},prev:function(e){if(this.length>0){var t=this[0];return e?t.previousElementSibling&&m(t.previousElementSibling).is(e)?m([t.previousElementSibling]):m([]):t.previousElementSibling?m([t.previousElementSibling]):m([])}return m([])},prevAll:function(e){var t=[],a=this[0];if(!a)return m([]);for(;a.previousElementSibling;){var i=a.previousElementSibling;e?m(i).is(e)&&t.push(i):t.push(i),a=i}return m(t)},parent:function(e){for(var t=[],a=0;a<this.length;a+=1)null!==this[a].parentNode&&(e?m(this[a].parentNode).is(e)&&t.push(this[a].parentNode):t.push(this[a].parentNode));return m(t)},parents:function(e){for(var t=[],a=0;a<this.length;a+=1)for(var i=this[a].parentNode;i;)e?m(i).is(e)&&t.push(i):t.push(i),i=i.parentNode;return m(t)},closest:function(e){var t=this;return void 0===e?m([]):(t.is(e)||(t=t.parents(e).eq(0)),t)},find:function(e){for(var t=[],a=0;a<this.length;a+=1){try{var i=this[a].querySelectorAll(e)}catch(t){console.log(e)}for(var s=0;s<i.length;s+=1)t.push(i[s])}return m(t)},children:function(e){for(var t=[],a=0;a<this.length;a+=1)for(var i=this[a].children,s=0;s<i.length;s+=1)e&&!m(i[s]).is(e)||t.push(i[s]);return m(t)},filter:function(e){return m(f(this,e))},remove:function(){for(var e=0;e<this.length;e+=1)this[e].parentNode&&this[e].parentNode.removeChild(this[e]);return this}};function E(e,t){return void 0===t&&(t=0),setTimeout(e,t)}function x(){return Date.now()}function T(e,t){void 0===t&&(t="x");var a,i,s,r=l(),n=function(e){var t,a=l();return a.getComputedStyle&&(t=a.getComputedStyle(e,null)),!t&&e.currentStyle&&(t=e.currentStyle),t||(t=e.style),t}(e);return r.WebKitCSSMatrix?((i=n.transform||n.webkitTransform).split(",").length>6&&(i=i.split(", ").map((function(e){return e.replace(",",".")})).join(", ")),s=new r.WebKitCSSMatrix("none"===i?"":i)):a=(s=n.MozTransform||n.OTransform||n.MsTransform||n.msTransform||n.transform||n.getPropertyValue("transform").replace("translate(","matrix(1, 0, 0, 1,")).toString().split(","),"x"===t&&(i=r.WebKitCSSMatrix?s.m41:16===a.length?parseFloat(a[12]):parseFloat(a[4])),"y"===t&&(i=r.WebKitCSSMatrix?s.m42:16===a.length?parseFloat(a[13]):parseFloat(a[5])),i||0}function C(e){return"object"==typeof e&&null!==e&&e.constructor&&"Object"===Object.prototype.toString.call(e).slice(8,-1)}function S(e){return"undefined"!=typeof window&&void 0!==window.HTMLElement?e instanceof HTMLElement:e&&(1===e.nodeType||11===e.nodeType)}function M(){for(var e=Object(arguments.length<=0?void 0:arguments[0]),t=["__proto__","constructor","prototype"],a=1;a<arguments.length;a+=1){var i=a<0||arguments.length<=a?void 0:arguments[a];if(null!=i&&!S(i))for(var s=Object.keys(Object(i)).filter((function(e){return t.indexOf(e)<0})),r=0,n=s.length;r<n;r+=1){var l=s[r],o=Object.getOwnPropertyDescriptor(i,l);void 0!==o&&o.enumerable&&(C(e[l])&&C(i[l])?i[l].__swiper__?e[l]=i[l]:M(e[l],i[l]):!C(e[l])&&C(i[l])?(e[l]={},i[l].__swiper__?e[l]=i[l]:M(e[l],i[l])):e[l]=i[l])}}return e}function z(e,t){Object.keys(t).forEach((function(a){C(t[a])&&Object.keys(t[a]).forEach((function(i){"function"==typeof t[a][i]&&(t[a][i]=t[a][i].bind(e))})),e[a]=t[a]}))}function P(e){return void 0===e&&(e=""),"."+e.trim().replace(/([\.:\/])/g,"\\$1").replace(/ /g,".")}function k(e,t,a,i){var s=r();return a&&Object.keys(i).forEach((function(a){if(!t[a]&&!0===t.auto){var r=s.createElement("div");r.className=i[a],e.append(r),t[a]=r}})),t}function $(){return g||(g=function(){var e=l(),t=r();return{touch:!!("ontouchstart"in e||e.DocumentTouch&&t instanceof e.DocumentTouch),pointerEvents:!!e.PointerEvent&&"maxTouchPoints"in e.navigator&&e.navigator.maxTouchPoints>=0,observer:"MutationObserver"in e||"WebkitMutationObserver"in e,passiveListener:function(){var t=!1;try{var a=Object.defineProperty({},"passive",{get:function(){t=!0}});e.addEventListener("testPassiveListener",null,a)}catch(e){}return t}(),gestures:"ongesturestart"in e}}()),g}function L(e){return void 0===e&&(e={}),b||(b=function(e){var t=(void 0===e?{}:e).userAgent,a=$(),i=l(),s=i.navigator.platform,r=t||i.navigator.userAgent,n={ios:!1,android:!1},o=i.screen.width,d=i.screen.height,p=r.match(/(Android);?[\s\/]+([\d.]+)?/),u=r.match(/(iPad).*OS\s([\d_]+)/),c=r.match(/(iPod)(.*OS\s([\d_]+))?/),h=!u&&r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),v="Win32"===s,f="MacIntel"===s;return!u&&f&&a.touch&&["1024x1366","1366x1024","834x1194","1194x834","834x1112","1112x834","768x1024","1024x768","820x1180","1180x820","810x1080","1080x810"].indexOf(o+"x"+d)>=0&&((u=r.match(/(Version)\/([\d.]+)/))||(u=[0,1,"13_0_0"]),f=!1),p&&!v&&(n.os="android",n.android=!0),(u||h||c)&&(n.os="ios",n.ios=!0),n}(e)),b}function I(){return w||(w=function(){var e,t=l();return{isEdge:!!t.navigator.userAgent.match(/Edge/g),isSafari:(e=t.navigator.userAgent.toLowerCase(),e.indexOf("safari")>=0&&e.indexOf("chrome")<0&&e.indexOf("android")<0),isWebView:/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent)}}()),w}Object.keys(y).forEach((function(e){Object.defineProperty(m.fn,e,{value:y[e],writable:!0})}));var O={name:"resize",create:function(){var e=this;M(e,{resize:{observer:null,createObserver:function(){e&&!e.destroyed&&e.initialized&&(e.resize.observer=new ResizeObserver((function(t){var a=e.width,i=e.height,s=a,r=i;t.forEach((function(t){var a=t.contentBoxSize,i=t.contentRect,n=t.target;n&&n!==e.el||(s=i?i.width:(a[0]||a).inlineSize,r=i?i.height:(a[0]||a).blockSize)})),s===a&&r===i||e.resize.resizeHandler()})),e.resize.observer.observe(e.el))},removeObserver:function(){e.resize.observer&&e.resize.observer.unobserve&&e.el&&(e.resize.observer.unobserve(e.el),e.resize.observer=null)},resizeHandler:function(){e&&!e.destroyed&&e.initialized&&(e.emit("beforeResize"),e.emit("resize"))},orientationChangeHandler:function(){e&&!e.destroyed&&e.initialized&&e.emit("orientationchange")}}})},on:{init:function(e){var t=l();e.params.resizeObserver&&void 0!==l().ResizeObserver?e.resize.createObserver():(t.addEventListener("resize",e.resize.resizeHandler),t.addEventListener("orientationchange",e.resize.orientationChangeHandler))},destroy:function(e){var t=l();e.resize.removeObserver(),t.removeEventListener("resize",e.resize.resizeHandler),t.removeEventListener("orientationchange",e.resize.orientationChangeHandler)}}},A={attach:function(e,t){void 0===t&&(t={});var a=l(),i=this,s=new(a.MutationObserver||a.WebkitMutationObserver)((function(e){if(1!==e.length){var t=function(){i.emit("observerUpdate",e[0])};a.requestAnimationFrame?a.requestAnimationFrame(t):a.setTimeout(t,0)}else i.emit("observerUpdate",e[0])}));s.observe(e,{attributes:void 0===t.attributes||t.attributes,childList:void 0===t.childList||t.childList,characterData:void 0===t.characterData||t.characterData}),i.observer.observers.push(s)},init:function(){var e=this;if(e.support.observer&&e.params.observer){if(e.params.observeParents)for(var t=e.$el.parents(),a=0;a<t.length;a+=1)e.observer.attach(t[a]);e.observer.attach(e.$el[0],{childList:e.params.observeSlideChildren}),e.observer.attach(e.$wrapperEl[0],{attributes:!1})}},destroy:function(){this.observer.observers.forEach((function(e){e.disconnect()})),this.observer.observers=[]}},D={name:"observer",params:{observer:!1,observeParents:!1,observeSlideChildren:!1},create:function(){z(this,{observer:t({},A,{observers:[]})})},on:{init:function(e){e.observer.init()},destroy:function(e){e.observer.destroy()}}};function N(e){var t=this,a=r(),i=l(),s=t.touchEventsData,n=t.params,o=t.touches;if(t.enabled&&(!t.animating||!n.preventInteractionOnTransition)){var d=e;d.originalEvent&&(d=d.originalEvent);var p=m(d.target);if(("wrapper"!==n.touchEventsTarget||p.closest(t.wrapperEl).length)&&(s.isTouchEvent="touchstart"===d.type,(s.isTouchEvent||!("which"in d)||3!==d.which)&&!(!s.isTouchEvent&&"button"in d&&d.button>0||s.isTouched&&s.isMoved))){!!n.noSwipingClass&&""!==n.noSwipingClass&&d.target&&d.target.shadowRoot&&e.path&&e.path[0]&&(p=m(e.path[0]));var u=n.noSwipingSelector?n.noSwipingSelector:"."+n.noSwipingClass,c=!(!d.target||!d.target.shadowRoot);if(n.noSwiping&&(c?function(e,t){return void 0===t&&(t=this),function t(a){return a&&a!==r()&&a!==l()?(a.assignedSlot&&(a=a.assignedSlot),a.closest(e)||t(a.getRootNode().host)):null}(t)}(u,d.target):p.closest(u)[0]))t.allowClick=!0;else if(!n.swipeHandler||p.closest(n.swipeHandler)[0]){o.currentX="touchstart"===d.type?d.targetTouches[0].pageX:d.pageX,o.currentY="touchstart"===d.type?d.targetTouches[0].pageY:d.pageY;var h=o.currentX,v=o.currentY,f=n.edgeSwipeDetection||n.iOSEdgeSwipeDetection,g=n.edgeSwipeThreshold||n.iOSEdgeSwipeThreshold;if(f&&(h<=g||h>=i.innerWidth-g)){if("prevent"!==f)return;e.preventDefault()}if(M(s,{isTouched:!0,isMoved:!1,allowTouchCallbacks:!0,isScrolling:void 0,startMoving:void 0}),o.startX=h,o.startY=v,s.touchStartTime=x(),t.allowClick=!0,t.updateSize(),t.swipeDirection=void 0,n.threshold>0&&(s.allowThresholdMove=!1),"touchstart"!==d.type){var b=!0;p.is(s.focusableElements)&&(b=!1),a.activeElement&&m(a.activeElement).is(s.focusableElements)&&a.activeElement!==p[0]&&a.activeElement.blur();var w=b&&t.allowTouchMove&&n.touchStartPreventDefault;!n.touchStartForcePreventDefault&&!w||p[0].isContentEditable||d.preventDefault()}t.emit("touchStart",d)}}}}function G(e){var t=r(),a=this,i=a.touchEventsData,s=a.params,n=a.touches,l=a.rtlTranslate;if(a.enabled){var o=e;if(o.originalEvent&&(o=o.originalEvent),i.isTouched){if(!i.isTouchEvent||"touchmove"===o.type){var d="touchmove"===o.type&&o.targetTouches&&(o.targetTouches[0]||o.changedTouches[0]),p="touchmove"===o.type?d.pageX:o.pageX,u="touchmove"===o.type?d.pageY:o.pageY;if(o.preventedByNestedSwiper)return n.startX=p,void(n.startY=u);if(!a.allowTouchMove)return a.allowClick=!1,void(i.isTouched&&(M(n,{startX:p,startY:u,currentX:p,currentY:u}),i.touchStartTime=x()));if(i.isTouchEvent&&s.touchReleaseOnEdges&&!s.loop)if(a.isVertical()){if(u<n.startY&&a.translate<=a.maxTranslate()||u>n.startY&&a.translate>=a.minTranslate())return i.isTouched=!1,void(i.isMoved=!1)}else if(p<n.startX&&a.translate<=a.maxTranslate()||p>n.startX&&a.translate>=a.minTranslate())return;if(i.isTouchEvent&&t.activeElement&&o.target===t.activeElement&&m(o.target).is(i.focusableElements))return i.isMoved=!0,void(a.allowClick=!1);if(i.allowTouchCallbacks&&a.emit("touchMove",o),!(o.targetTouches&&o.targetTouches.length>1)){n.currentX=p,n.currentY=u;var c=n.currentX-n.startX,h=n.currentY-n.startY;if(!(a.params.threshold&&Math.sqrt(Math.pow(c,2)+Math.pow(h,2))<a.params.threshold)){var v;if(void 0===i.isScrolling)a.isHorizontal()&&n.currentY===n.startY||a.isVertical()&&n.currentX===n.startX?i.isScrolling=!1:c*c+h*h>=25&&(v=180*Math.atan2(Math.abs(h),Math.abs(c))/Math.PI,i.isScrolling=a.isHorizontal()?v>s.touchAngle:90-v>s.touchAngle);if(i.isScrolling&&a.emit("touchMoveOpposite",o),void 0===i.startMoving&&(n.currentX===n.startX&&n.currentY===n.startY||(i.startMoving=!0)),i.isScrolling)i.isTouched=!1;else if(i.startMoving){a.allowClick=!1,!s.cssMode&&o.cancelable&&o.preventDefault(),s.touchMoveStopPropagation&&!s.nested&&o.stopPropagation(),i.isMoved||(s.loop&&a.loopFix(),i.startTranslate=a.getTranslate(),a.setTransition(0),a.animating&&a.$wrapperEl.trigger("webkitTransitionEnd transitionend"),i.allowMomentumBounce=!1,!s.grabCursor||!0!==a.allowSlideNext&&!0!==a.allowSlidePrev||a.setGrabCursor(!0),a.emit("sliderFirstMove",o)),a.emit("sliderMove",o),i.isMoved=!0;var f=a.isHorizontal()?c:h;n.diff=f,f*=s.touchRatio,l&&(f=-f),a.swipeDirection=f>0?"prev":"next",i.currentTranslate=f+i.startTranslate;var g=!0,b=s.resistanceRatio;if(s.touchReleaseOnEdges&&(b=0),f>0&&i.currentTranslate>a.minTranslate()?(g=!1,s.resistance&&(i.currentTranslate=a.minTranslate()-1+Math.pow(-a.minTranslate()+i.startTranslate+f,b))):f<0&&i.currentTranslate<a.maxTranslate()&&(g=!1,s.resistance&&(i.currentTranslate=a.maxTranslate()+1-Math.pow(a.maxTranslate()-i.startTranslate-f,b))),g&&(o.preventedByNestedSwiper=!0),!a.allowSlideNext&&"next"===a.swipeDirection&&i.currentTranslate<i.startTranslate&&(i.currentTranslate=i.startTranslate),!a.allowSlidePrev&&"prev"===a.swipeDirection&&i.currentTranslate>i.startTranslate&&(i.currentTranslate=i.startTranslate),a.allowSlidePrev||a.allowSlideNext||(i.currentTranslate=i.startTranslate),s.threshold>0){if(!(Math.abs(f)>s.threshold||i.allowThresholdMove))return void(i.currentTranslate=i.startTranslate);if(!i.allowThresholdMove)return i.allowThresholdMove=!0,n.startX=n.currentX,n.startY=n.currentY,i.currentTranslate=i.startTranslate,void(n.diff=a.isHorizontal()?n.currentX-n.startX:n.currentY-n.startY)}s.followFinger&&!s.cssMode&&((s.freeMode||s.watchSlidesProgress||s.watchSlidesVisibility)&&(a.updateActiveIndex(),a.updateSlidesClasses()),s.freeMode&&(0===i.velocities.length&&i.velocities.push({position:n[a.isHorizontal()?"startX":"startY"],time:i.touchStartTime}),i.velocities.push({position:n[a.isHorizontal()?"currentX":"currentY"],time:x()})),a.updateProgress(i.currentTranslate),a.setTranslate(i.currentTranslate))}}}}}else i.startMoving&&i.isScrolling&&a.emit("touchMoveOpposite",o)}}function B(e){var t=this,a=t.touchEventsData,i=t.params,s=t.touches,r=t.rtlTranslate,n=t.$wrapperEl,l=t.slidesGrid,o=t.snapGrid;if(t.enabled){var d=e;if(d.originalEvent&&(d=d.originalEvent),a.allowTouchCallbacks&&t.emit("touchEnd",d),a.allowTouchCallbacks=!1,!a.isTouched)return a.isMoved&&i.grabCursor&&t.setGrabCursor(!1),a.isMoved=!1,void(a.startMoving=!1);i.grabCursor&&a.isMoved&&a.isTouched&&(!0===t.allowSlideNext||!0===t.allowSlidePrev)&&t.setGrabCursor(!1);var p,u=x(),c=u-a.touchStartTime;if(t.allowClick&&(t.updateClickedSlide(d),t.emit("tap click",d),c<300&&u-a.lastClickTime<300&&t.emit("doubleTap doubleClick",d)),a.lastClickTime=x(),E((function(){t.destroyed||(t.allowClick=!0)})),!a.isTouched||!a.isMoved||!t.swipeDirection||0===s.diff||a.currentTranslate===a.startTranslate)return a.isTouched=!1,a.isMoved=!1,void(a.startMoving=!1);if(a.isTouched=!1,a.isMoved=!1,a.startMoving=!1,p=i.followFinger?r?t.translate:-t.translate:-a.currentTranslate,!i.cssMode)if(i.freeMode){if(p<-t.minTranslate())return void t.slideTo(t.activeIndex);if(p>-t.maxTranslate())return void(t.slides.length<o.length?t.slideTo(o.length-1):t.slideTo(t.slides.length-1));if(i.freeModeMomentum){if(a.velocities.length>1){var h=a.velocities.pop(),v=a.velocities.pop(),f=h.position-v.position,m=h.time-v.time;t.velocity=f/m,t.velocity/=2,Math.abs(t.velocity)<i.freeModeMinimumVelocity&&(t.velocity=0),(m>150||x()-h.time>300)&&(t.velocity=0)}else t.velocity=0;t.velocity*=i.freeModeMomentumVelocityRatio,a.velocities.length=0;var g=1e3*i.freeModeMomentumRatio,b=t.velocity*g,w=t.translate+b;r&&(w=-w);var y,T,C=!1,S=20*Math.abs(t.velocity)*i.freeModeMomentumBounceRatio;if(w<t.maxTranslate())i.freeModeMomentumBounce?(w+t.maxTranslate()<-S&&(w=t.maxTranslate()-S),y=t.maxTranslate(),C=!0,a.allowMomentumBounce=!0):w=t.maxTranslate(),i.loop&&i.centeredSlides&&(T=!0);else if(w>t.minTranslate())i.freeModeMomentumBounce?(w-t.minTranslate()>S&&(w=t.minTranslate()+S),y=t.minTranslate(),C=!0,a.allowMomentumBounce=!0):w=t.minTranslate(),i.loop&&i.centeredSlides&&(T=!0);else if(i.freeModeSticky){for(var M,z=0;z<o.length;z+=1)if(o[z]>-w){M=z;break}w=-(w=Math.abs(o[M]-w)<Math.abs(o[M-1]-w)||"next"===t.swipeDirection?o[M]:o[M-1])}if(T&&t.once("transitionEnd",(function(){t.loopFix()})),0!==t.velocity){if(g=r?Math.abs((-w-t.translate)/t.velocity):Math.abs((w-t.translate)/t.velocity),i.freeModeSticky){var P=Math.abs((r?-w:w)-t.translate),k=t.slidesSizesGrid[t.activeIndex];g=P<k?i.speed:P<2*k?1.5*i.speed:2.5*i.speed}}else if(i.freeModeSticky)return void t.slideToClosest();i.freeModeMomentumBounce&&C?(t.updateProgress(y),t.setTransition(g),t.setTranslate(w),t.transitionStart(!0,t.swipeDirection),t.animating=!0,n.transitionEnd((function(){t&&!t.destroyed&&a.allowMomentumBounce&&(t.emit("momentumBounce"),t.setTransition(i.speed),setTimeout((function(){t.setTranslate(y),n.transitionEnd((function(){t&&!t.destroyed&&t.transitionEnd()}))}),0))}))):t.velocity?(t.updateProgress(w),t.setTransition(g),t.setTranslate(w),t.transitionStart(!0,t.swipeDirection),t.animating||(t.animating=!0,n.transitionEnd((function(){t&&!t.destroyed&&t.transitionEnd()})))):(t.emit("_freeModeNoMomentumRelease"),t.updateProgress(w)),t.updateActiveIndex(),t.updateSlidesClasses()}else{if(i.freeModeSticky)return void t.slideToClosest();i.freeMode&&t.emit("_freeModeNoMomentumRelease")}(!i.freeModeMomentum||c>=i.longSwipesMs)&&(t.updateProgress(),t.updateActiveIndex(),t.updateSlidesClasses())}else{for(var $=0,L=t.slidesSizesGrid[0],I=0;I<l.length;I+=I<i.slidesPerGroupSkip?1:i.slidesPerGroup){var O=I<i.slidesPerGroupSkip-1?1:i.slidesPerGroup;void 0!==l[I+O]?p>=l[I]&&p<l[I+O]&&($=I,L=l[I+O]-l[I]):p>=l[I]&&($=I,L=l[l.length-1]-l[l.length-2])}var A=(p-l[$])/L,D=$<i.slidesPerGroupSkip-1?1:i.slidesPerGroup;if(c>i.longSwipesMs){if(!i.longSwipes)return void t.slideTo(t.activeIndex);"next"===t.swipeDirection&&(A>=i.longSwipesRatio?t.slideTo($+D):t.slideTo($)),"prev"===t.swipeDirection&&(A>1-i.longSwipesRatio?t.slideTo($+D):t.slideTo($))}else{if(!i.shortSwipes)return void t.slideTo(t.activeIndex);t.navigation&&(d.target===t.navigation.nextEl||d.target===t.navigation.prevEl)?d.target===t.navigation.nextEl?t.slideTo($+D):t.slideTo($):("next"===t.swipeDirection&&t.slideTo($+D),"prev"===t.swipeDirection&&t.slideTo($))}}}}function H(){var e=this,t=e.params,a=e.el;if(!a||0!==a.offsetWidth){t.breakpoints&&e.setBreakpoint();var i=e.allowSlideNext,s=e.allowSlidePrev,r=e.snapGrid;e.allowSlideNext=!0,e.allowSlidePrev=!0,e.updateSize(),e.updateSlides(),e.updateSlidesClasses(),("auto"===t.slidesPerView||t.slidesPerView>1)&&e.isEnd&&!e.isBeginning&&!e.params.centeredSlides?e.slideTo(e.slides.length-1,0,!1,!0):e.slideTo(e.activeIndex,0,!1,!0),e.autoplay&&e.autoplay.running&&e.autoplay.paused&&e.autoplay.run(),e.allowSlidePrev=s,e.allowSlideNext=i,e.params.watchOverflow&&r!==e.snapGrid&&e.checkOverflow()}}function R(e){var t=this;t.enabled&&(t.allowClick||(t.params.preventClicks&&e.preventDefault(),t.params.preventClicksPropagation&&t.animating&&(e.stopPropagation(),e.stopImmediatePropagation())))}function X(){var e=this,t=e.wrapperEl,a=e.rtlTranslate;if(e.enabled){e.previousTranslate=e.translate,e.isHorizontal()?e.translate=a?t.scrollWidth-t.offsetWidth-t.scrollLeft:-t.scrollLeft:e.translate=-t.scrollTop,-0===e.translate&&(e.translate=0),e.updateActiveIndex(),e.updateSlidesClasses();var i=e.maxTranslate()-e.minTranslate();(0===i?0:(e.translate-e.minTranslate())/i)!==e.progress&&e.updateProgress(a?-e.translate:e.translate),e.emit("setTranslate",e.translate,!1)}}var Y=!1;function V(){}var W={init:!0,direction:"horizontal",touchEventsTarget:"container",initialSlide:0,speed:300,cssMode:!1,updateOnWindowResize:!0,resizeObserver:!1,nested:!1,createElements:!1,enabled:!0,focusableElements:"input, select, option, textarea, button, video, label",width:null,height:null,preventInteractionOnTransition:!1,userAgent:null,url:null,edgeSwipeDetection:!1,edgeSwipeThreshold:20,freeMode:!1,freeModeMomentum:!0,freeModeMomentumRatio:1,freeModeMomentumBounce:!0,freeModeMomentumBounceRatio:1,freeModeMomentumVelocityRatio:1,freeModeSticky:!1,freeModeMinimumVelocity:.02,autoHeight:!1,setWrapperSize:!1,virtualTranslate:!1,effect:"slide",breakpoints:void 0,breakpointsBase:"window",spaceBetween:0,slidesPerView:1,slidesPerColumn:1,slidesPerColumnFill:"column",slidesPerGroup:1,slidesPerGroupSkip:0,centeredSlides:!1,centeredSlidesBounds:!1,slidesOffsetBefore:0,slidesOffsetAfter:0,normalizeSlideIndex:!0,centerInsufficientSlides:!1,watchOverflow:!1,roundLengths:!1,touchRatio:1,touchAngle:45,simulateTouch:!0,shortSwipes:!0,longSwipes:!0,longSwipesRatio:.5,longSwipesMs:300,followFinger:!0,allowTouchMove:!0,threshold:0,touchMoveStopPropagation:!1,touchStartPreventDefault:!0,touchStartForcePreventDefault:!1,touchReleaseOnEdges:!1,uniqueNavElements:!0,resistance:!0,resistanceRatio:.85,watchSlidesProgress:!1,watchSlidesVisibility:!1,grabCursor:!1,preventClicks:!0,preventClicksPropagation:!0,slideToClickedSlide:!1,preloadImages:!0,updateOnImagesReady:!0,loop:!1,loopAdditionalSlides:0,loopedSlides:null,loopFillGroupWithBlank:!1,loopPreventsSlide:!0,allowSlidePrev:!0,allowSlideNext:!0,swipeHandler:null,noSwiping:!0,noSwipingClass:"swiper-no-swiping",noSwipingSelector:null,passiveListeners:!0,containerModifierClass:"swiper-container-",slideClass:"swiper-slide",slideBlankClass:"swiper-slide-invisible-blank",slideActiveClass:"swiper-slide-active",slideDuplicateActiveClass:"swiper-slide-duplicate-active",slideVisibleClass:"swiper-slide-visible",slideDuplicateClass:"swiper-slide-duplicate",slideNextClass:"swiper-slide-next",slideDuplicateNextClass:"swiper-slide-duplicate-next",slidePrevClass:"swiper-slide-prev",slideDuplicatePrevClass:"swiper-slide-duplicate-prev",wrapperClass:"swiper-wrapper",runCallbacksOnInit:!0,_emitClasses:!1},F={modular:{useParams:function(e){var t=this;t.modules&&Object.keys(t.modules).forEach((function(a){var i=t.modules[a];i.params&&M(e,i.params)}))},useModules:function(e){void 0===e&&(e={});var t=this;t.modules&&Object.keys(t.modules).forEach((function(a){var i=t.modules[a],s=e[a]||{};i.on&&t.on&&Object.keys(i.on).forEach((function(e){t.on(e,i.on[e])})),i.create&&i.create.bind(t)(s)}))}},eventsEmitter:{on:function(e,t,a){var i=this;if("function"!=typeof t)return i;var s=a?"unshift":"push";return e.split(" ").forEach((function(e){i.eventsListeners[e]||(i.eventsListeners[e]=[]),i.eventsListeners[e][s](t)})),i},once:function(e,t,a){var i=this;if("function"!=typeof t)return i;function s(){i.off(e,s),s.__emitterProxy&&delete s.__emitterProxy;for(var a=arguments.length,r=new Array(a),n=0;n<a;n++)r[n]=arguments[n];t.apply(i,r)}return s.__emitterProxy=t,i.on(e,s,a)},onAny:function(e,t){var a=this;if("function"!=typeof e)return a;var i=t?"unshift":"push";return a.eventsAnyListeners.indexOf(e)<0&&a.eventsAnyListeners[i](e),a},offAny:function(e){var t=this;if(!t.eventsAnyListeners)return t;var a=t.eventsAnyListeners.indexOf(e);return a>=0&&t.eventsAnyListeners.splice(a,1),t},off:function(e,t){var a=this;return a.eventsListeners?(e.split(" ").forEach((function(e){void 0===t?a.eventsListeners[e]=[]:a.eventsListeners[e]&&a.eventsListeners[e].forEach((function(i,s){(i===t||i.__emitterProxy&&i.__emitterProxy===t)&&a.eventsListeners[e].splice(s,1)}))})),a):a},emit:function(){var e,t,a,i=this;if(!i.eventsListeners)return i;for(var s=arguments.length,r=new Array(s),n=0;n<s;n++)r[n]=arguments[n];"string"==typeof r[0]||Array.isArray(r[0])?(e=r[0],t=r.slice(1,r.length),a=i):(e=r[0].events,t=r[0].data,a=r[0].context||i),t.unshift(a);var l=Array.isArray(e)?e:e.split(" ");return l.forEach((function(e){i.eventsAnyListeners&&i.eventsAnyListeners.length&&i.eventsAnyListeners.forEach((function(i){i.apply(a,[e].concat(t))})),i.eventsListeners&&i.eventsListeners[e]&&i.eventsListeners[e].forEach((function(e){e.apply(a,t)}))})),i}},update:{updateSize:function(){var e,t,a=this,i=a.$el;e=void 0!==a.params.width&&null!==a.params.width?a.params.width:i[0].clientWidth,t=void 0!==a.params.height&&null!==a.params.height?a.params.height:i[0].clientHeight,0===e&&a.isHorizontal()||0===t&&a.isVertical()||(e=e-parseInt(i.css("padding-left")||0,10)-parseInt(i.css("padding-right")||0,10),t=t-parseInt(i.css("padding-top")||0,10)-parseInt(i.css("padding-bottom")||0,10),Number.isNaN(e)&&(e=0),Number.isNaN(t)&&(t=0),M(a,{width:e,height:t,size:a.isHorizontal()?e:t}))},updateSlides:function(){var e=this;function t(t){return e.isHorizontal()?t:{width:"height","margin-top":"margin-left","margin-bottom ":"margin-right","margin-left":"margin-top","margin-right":"margin-bottom","padding-left":"padding-top","padding-right":"padding-bottom",marginRight:"marginBottom"}[t]}function a(e,a){return parseFloat(e.getPropertyValue(t(a))||0)}var i=e.params,s=e.$wrapperEl,r=e.size,n=e.rtlTranslate,l=e.wrongRTL,o=e.virtual&&i.virtual.enabled,d=o?e.virtual.slides.length:e.slides.length,p=s.children("."+e.params.slideClass),u=o?e.virtual.slides.length:p.length,c=[],h=[],v=[],f=i.slidesOffsetBefore;"function"==typeof f&&(f=i.slidesOffsetBefore.call(e));var m=i.slidesOffsetAfter;"function"==typeof m&&(m=i.slidesOffsetAfter.call(e));var g=e.snapGrid.length,b=e.slidesGrid.length,w=i.spaceBetween,y=-f,E=0,x=0;if(void 0!==r){var T,C;"string"==typeof w&&w.indexOf("%")>=0&&(w=parseFloat(w.replace("%",""))/100*r),e.virtualSize=-w,n?p.css({marginLeft:"",marginBottom:"",marginTop:""}):p.css({marginRight:"",marginBottom:"",marginTop:""}),i.slidesPerColumn>1&&(T=Math.floor(u/i.slidesPerColumn)===u/e.params.slidesPerColumn?u:Math.ceil(u/i.slidesPerColumn)*i.slidesPerColumn,"auto"!==i.slidesPerView&&"row"===i.slidesPerColumnFill&&(T=Math.max(T,i.slidesPerView*i.slidesPerColumn)));for(var S,z,P,k=i.slidesPerColumn,$=T/k,L=Math.floor(u/i.slidesPerColumn),I=0;I<u;I+=1){C=0;var O=p.eq(I);if(i.slidesPerColumn>1){var A=void 0,D=void 0,N=void 0;if("row"===i.slidesPerColumnFill&&i.slidesPerGroup>1){var G=Math.floor(I/(i.slidesPerGroup*i.slidesPerColumn)),B=I-i.slidesPerColumn*i.slidesPerGroup*G,H=0===G?i.slidesPerGroup:Math.min(Math.ceil((u-G*k*i.slidesPerGroup)/k),i.slidesPerGroup);A=(D=B-(N=Math.floor(B/H))*H+G*i.slidesPerGroup)+N*T/k,O.css({"-webkit-box-ordinal-group":A,"-moz-box-ordinal-group":A,"-ms-flex-order":A,"-webkit-order":A,order:A})}else"column"===i.slidesPerColumnFill?(N=I-(D=Math.floor(I/k))*k,(D>L||D===L&&N===k-1)&&(N+=1)>=k&&(N=0,D+=1)):D=I-(N=Math.floor(I/$))*$;O.css(t("margin-top"),0!==N?i.spaceBetween&&i.spaceBetween+"px":"")}if("none"!==O.css("display")){if("auto"===i.slidesPerView){var R=getComputedStyle(O[0]),X=O[0].style.transform,Y=O[0].style.webkitTransform;if(X&&(O[0].style.transform="none"),Y&&(O[0].style.webkitTransform="none"),i.roundLengths)C=e.isHorizontal()?O.outerWidth(!0):O.outerHeight(!0);else{var V=a(R,"width"),W=a(R,"padding-left"),F=a(R,"padding-right"),_=a(R,"margin-left"),q=a(R,"margin-right"),j=R.getPropertyValue("box-sizing");if(j&&"border-box"===j)C=V+_+q;else{var U=O[0],K=U.clientWidth;C=V+W+F+_+q+(U.offsetWidth-K)}}X&&(O[0].style.transform=X),Y&&(O[0].style.webkitTransform=Y),i.roundLengths&&(C=Math.floor(C))}else C=(r-(i.slidesPerView-1)*w)/i.slidesPerView,i.roundLengths&&(C=Math.floor(C)),p[I]&&(p[I].style[t("width")]=C+"px");p[I]&&(p[I].swiperSlideSize=C),v.push(C),i.centeredSlides?(y=y+C/2+E/2+w,0===E&&0!==I&&(y=y-r/2-w),0===I&&(y=y-r/2-w),Math.abs(y)<.001&&(y=0),i.roundLengths&&(y=Math.floor(y)),x%i.slidesPerGroup==0&&c.push(y),h.push(y)):(i.roundLengths&&(y=Math.floor(y)),(x-Math.min(e.params.slidesPerGroupSkip,x))%e.params.slidesPerGroup==0&&c.push(y),h.push(y),y=y+C+w),e.virtualSize+=C+w,E=C,x+=1}}if(e.virtualSize=Math.max(e.virtualSize,r)+m,n&&l&&("slide"===i.effect||"coverflow"===i.effect)&&s.css({width:e.virtualSize+i.spaceBetween+"px"}),i.setWrapperSize)s.css(((z={})[t("width")]=e.virtualSize+i.spaceBetween+"px",z));if(i.slidesPerColumn>1)if(e.virtualSize=(C+i.spaceBetween)*T,e.virtualSize=Math.ceil(e.virtualSize/i.slidesPerColumn)-i.spaceBetween,s.css(((P={})[t("width")]=e.virtualSize+i.spaceBetween+"px",P)),i.centeredSlides){S=[];for(var Z=0;Z<c.length;Z+=1){var J=c[Z];i.roundLengths&&(J=Math.floor(J)),c[Z]<e.virtualSize+c[0]&&S.push(J)}c=S}if(!i.centeredSlides){S=[];for(var Q=0;Q<c.length;Q+=1){var ee=c[Q];i.roundLengths&&(ee=Math.floor(ee)),c[Q]<=e.virtualSize-r&&S.push(ee)}c=S,Math.floor(e.virtualSize-r)-Math.floor(c[c.length-1])>1&&c.push(e.virtualSize-r)}if(0===c.length&&(c=[0]),0!==i.spaceBetween){var te,ae=e.isHorizontal()&&n?"marginLeft":t("marginRight");p.filter((function(e,t){return!i.cssMode||t!==p.length-1})).css(((te={})[ae]=w+"px",te))}if(i.centeredSlides&&i.centeredSlidesBounds){var ie=0;v.forEach((function(e){ie+=e+(i.spaceBetween?i.spaceBetween:0)}));var se=(ie-=i.spaceBetween)-r;c=c.map((function(e){return e<0?-f:e>se?se+m:e}))}if(i.centerInsufficientSlides){var re=0;if(v.forEach((function(e){re+=e+(i.spaceBetween?i.spaceBetween:0)})),(re-=i.spaceBetween)<r){var ne=(r-re)/2;c.forEach((function(e,t){c[t]=e-ne})),h.forEach((function(e,t){h[t]=e+ne}))}}M(e,{slides:p,snapGrid:c,slidesGrid:h,slidesSizesGrid:v}),u!==d&&e.emit("slidesLengthChange"),c.length!==g&&(e.params.watchOverflow&&e.checkOverflow(),e.emit("snapGridLengthChange")),h.length!==b&&e.emit("slidesGridLengthChange"),(i.watchSlidesProgress||i.watchSlidesVisibility)&&e.updateSlidesOffset()}},updateAutoHeight:function(e){var t,a=this,i=[],s=a.virtual&&a.params.virtual.enabled,r=0;"number"==typeof e?a.setTransition(e):!0===e&&a.setTransition(a.params.speed);var n=function(e){return s?a.slides.filter((function(t){return parseInt(t.getAttribute("data-swiper-slide-index"),10)===e}))[0]:a.slides.eq(e)[0]};if("auto"!==a.params.slidesPerView&&a.params.slidesPerView>1)if(a.params.centeredSlides)a.visibleSlides.each((function(e){i.push(e)}));else for(t=0;t<Math.ceil(a.params.slidesPerView);t+=1){var l=a.activeIndex+t;if(l>a.slides.length&&!s)break;i.push(n(l))}else i.push(n(a.activeIndex));for(t=0;t<i.length;t+=1)if(void 0!==i[t]){var o=i[t].offsetHeight;r=o>r?o:r}r&&a.$wrapperEl.css("height",r+"px")},updateSlidesOffset:function(){for(var e=this.slides,t=0;t<e.length;t+=1)e[t].swiperSlideOffset=this.isHorizontal()?e[t].offsetLeft:e[t].offsetTop},updateSlidesProgress:function(e){void 0===e&&(e=this&&this.translate||0);var t=this,a=t.params,i=t.slides,s=t.rtlTranslate;if(0!==i.length){void 0===i[0].swiperSlideOffset&&t.updateSlidesOffset();var r=-e;s&&(r=e),i.removeClass(a.slideVisibleClass),t.visibleSlidesIndexes=[],t.visibleSlides=[];for(var n=0;n<i.length;n+=1){var l=i[n],o=(r+(a.centeredSlides?t.minTranslate():0)-l.swiperSlideOffset)/(l.swiperSlideSize+a.spaceBetween);if(a.watchSlidesVisibility||a.centeredSlides&&a.autoHeight){var d=-(r-l.swiperSlideOffset),p=d+t.slidesSizesGrid[n];(d>=0&&d<t.size-1||p>1&&p<=t.size||d<=0&&p>=t.size)&&(t.visibleSlides.push(l),t.visibleSlidesIndexes.push(n),i.eq(n).addClass(a.slideVisibleClass))}l.progress=s?-o:o}t.visibleSlides=m(t.visibleSlides)}},updateProgress:function(e){var t=this;if(void 0===e){var a=t.rtlTranslate?-1:1;e=t&&t.translate&&t.translate*a||0}var i=t.params,s=t.maxTranslate()-t.minTranslate(),r=t.progress,n=t.isBeginning,l=t.isEnd,o=n,d=l;0===s?(r=0,n=!0,l=!0):(n=(r=(e-t.minTranslate())/s)<=0,l=r>=1),M(t,{progress:r,isBeginning:n,isEnd:l}),(i.watchSlidesProgress||i.watchSlidesVisibility||i.centeredSlides&&i.autoHeight)&&t.updateSlidesProgress(e),n&&!o&&t.emit("reachBeginning toEdge"),l&&!d&&t.emit("reachEnd toEdge"),(o&&!n||d&&!l)&&t.emit("fromEdge"),t.emit("progress",r)},updateSlidesClasses:function(){var e,t=this,a=t.slides,i=t.params,s=t.$wrapperEl,r=t.activeIndex,n=t.realIndex,l=t.virtual&&i.virtual.enabled;a.removeClass(i.slideActiveClass+" "+i.slideNextClass+" "+i.slidePrevClass+" "+i.slideDuplicateActiveClass+" "+i.slideDuplicateNextClass+" "+i.slideDuplicatePrevClass),(e=l?t.$wrapperEl.find("."+i.slideClass+'[data-swiper-slide-index="'+r+'"]'):a.eq(r)).addClass(i.slideActiveClass),i.loop&&(e.hasClass(i.slideDuplicateClass)?s.children("."+i.slideClass+":not(."+i.slideDuplicateClass+')[data-swiper-slide-index="'+n+'"]').addClass(i.slideDuplicateActiveClass):s.children("."+i.slideClass+"."+i.slideDuplicateClass+'[data-swiper-slide-index="'+n+'"]').addClass(i.slideDuplicateActiveClass));var o=e.nextAll("."+i.slideClass).eq(0).addClass(i.slideNextClass);i.loop&&0===o.length&&(o=a.eq(0)).addClass(i.slideNextClass);var d=e.prevAll("."+i.slideClass).eq(0).addClass(i.slidePrevClass);i.loop&&0===d.length&&(d=a.eq(-1)).addClass(i.slidePrevClass),i.loop&&(o.hasClass(i.slideDuplicateClass)?s.children("."+i.slideClass+":not(."+i.slideDuplicateClass+')[data-swiper-slide-index="'+o.attr("data-swiper-slide-index")+'"]').addClass(i.slideDuplicateNextClass):s.children("."+i.slideClass+"."+i.slideDuplicateClass+'[data-swiper-slide-index="'+o.attr("data-swiper-slide-index")+'"]').addClass(i.slideDuplicateNextClass),d.hasClass(i.slideDuplicateClass)?s.children("."+i.slideClass+":not(."+i.slideDuplicateClass+')[data-swiper-slide-index="'+d.attr("data-swiper-slide-index")+'"]').addClass(i.slideDuplicatePrevClass):s.children("."+i.slideClass+"."+i.slideDuplicateClass+'[data-swiper-slide-index="'+d.attr("data-swiper-slide-index")+'"]').addClass(i.slideDuplicatePrevClass)),t.emitSlidesClasses()},updateActiveIndex:function(e){var t,a=this,i=a.rtlTranslate?a.translate:-a.translate,s=a.slidesGrid,r=a.snapGrid,n=a.params,l=a.activeIndex,o=a.realIndex,d=a.snapIndex,p=e;if(void 0===p){for(var u=0;u<s.length;u+=1)void 0!==s[u+1]?i>=s[u]&&i<s[u+1]-(s[u+1]-s[u])/2?p=u:i>=s[u]&&i<s[u+1]&&(p=u+1):i>=s[u]&&(p=u);n.normalizeSlideIndex&&(p<0||void 0===p)&&(p=0)}if(r.indexOf(i)>=0)t=r.indexOf(i);else{var c=Math.min(n.slidesPerGroupSkip,p);t=c+Math.floor((p-c)/n.slidesPerGroup)}if(t>=r.length&&(t=r.length-1),p!==l){var h=parseInt(a.slides.eq(p).attr("data-swiper-slide-index")||p,10);M(a,{snapIndex:t,realIndex:h,previousIndex:l,activeIndex:p}),a.emit("activeIndexChange"),a.emit("snapIndexChange"),o!==h&&a.emit("realIndexChange"),(a.initialized||a.params.runCallbacksOnInit)&&a.emit("slideChange")}else t!==d&&(a.snapIndex=t,a.emit("snapIndexChange"))},updateClickedSlide:function(e){var t,a=this,i=a.params,s=m(e.target).closest("."+i.slideClass)[0],r=!1;if(s)for(var n=0;n<a.slides.length;n+=1)if(a.slides[n]===s){r=!0,t=n;break}if(!s||!r)return a.clickedSlide=void 0,void(a.clickedIndex=void 0);a.clickedSlide=s,a.virtual&&a.params.virtual.enabled?a.clickedIndex=parseInt(m(s).attr("data-swiper-slide-index"),10):a.clickedIndex=t,i.slideToClickedSlide&&void 0!==a.clickedIndex&&a.clickedIndex!==a.activeIndex&&a.slideToClickedSlide()}},translate:{getTranslate:function(e){void 0===e&&(e=this.isHorizontal()?"x":"y");var t=this,a=t.params,i=t.rtlTranslate,s=t.translate,r=t.$wrapperEl;if(a.virtualTranslate)return i?-s:s;if(a.cssMode)return s;var n=T(r[0],e);return i&&(n=-n),n||0},setTranslate:function(e,t){var a=this,i=a.rtlTranslate,s=a.params,r=a.$wrapperEl,n=a.wrapperEl,l=a.progress,o=0,d=0;a.isHorizontal()?o=i?-e:e:d=e,s.roundLengths&&(o=Math.floor(o),d=Math.floor(d)),s.cssMode?n[a.isHorizontal()?"scrollLeft":"scrollTop"]=a.isHorizontal()?-o:-d:s.virtualTranslate||r.transform("translate3d("+o+"px, "+d+"px, 0px)"),a.previousTranslate=a.translate,a.translate=a.isHorizontal()?o:d;var p=a.maxTranslate()-a.minTranslate();(0===p?0:(e-a.minTranslate())/p)!==l&&a.updateProgress(e),a.emit("setTranslate",a.translate,t)},minTranslate:function(){return-this.snapGrid[0]},maxTranslate:function(){return-this.snapGrid[this.snapGrid.length-1]},translateTo:function(e,t,a,i,s){void 0===e&&(e=0),void 0===t&&(t=this.params.speed),void 0===a&&(a=!0),void 0===i&&(i=!0);var r=this,n=r.params,l=r.wrapperEl;if(r.animating&&n.preventInteractionOnTransition)return!1;var o,d=r.minTranslate(),p=r.maxTranslate();if(o=i&&e>d?d:i&&e<p?p:e,r.updateProgress(o),n.cssMode){var u,c=r.isHorizontal();if(0===t)l[c?"scrollLeft":"scrollTop"]=-o;else if(l.scrollTo)l.scrollTo(((u={})[c?"left":"top"]=-o,u.behavior="smooth",u));else l[c?"scrollLeft":"scrollTop"]=-o;return!0}return 0===t?(r.setTransition(0),r.setTranslate(o),a&&(r.emit("beforeTransitionStart",t,s),r.emit("transitionEnd"))):(r.setTransition(t),r.setTranslate(o),a&&(r.emit("beforeTransitionStart",t,s),r.emit("transitionStart")),r.animating||(r.animating=!0,r.onTranslateToWrapperTransitionEnd||(r.onTranslateToWrapperTransitionEnd=function(e){r&&!r.destroyed&&e.target===this&&(r.$wrapperEl[0].removeEventListener("transitionend",r.onTranslateToWrapperTransitionEnd),r.$wrapperEl[0].removeEventListener("webkitTransitionEnd",r.onTranslateToWrapperTransitionEnd),r.onTranslateToWrapperTransitionEnd=null,delete r.onTranslateToWrapperTransitionEnd,a&&r.emit("transitionEnd"))}),r.$wrapperEl[0].addEventListener("transitionend",r.onTranslateToWrapperTransitionEnd),r.$wrapperEl[0].addEventListener("webkitTransitionEnd",r.onTranslateToWrapperTransitionEnd))),!0}},transition:{setTransition:function(e,t){var a=this;a.params.cssMode||a.$wrapperEl.transition(e),a.emit("setTransition",e,t)},transitionStart:function(e,t){void 0===e&&(e=!0);var a=this,i=a.activeIndex,s=a.params,r=a.previousIndex;if(!s.cssMode){s.autoHeight&&a.updateAutoHeight();var n=t;if(n||(n=i>r?"next":i<r?"prev":"reset"),a.emit("transitionStart"),e&&i!==r){if("reset"===n)return void a.emit("slideResetTransitionStart");a.emit("slideChangeTransitionStart"),"next"===n?a.emit("slideNextTransitionStart"):a.emit("slidePrevTransitionStart")}}},transitionEnd:function(e,t){void 0===e&&(e=!0);var a=this,i=a.activeIndex,s=a.previousIndex,r=a.params;if(a.animating=!1,!r.cssMode){a.setTransition(0);var n=t;if(n||(n=i>s?"next":i<s?"prev":"reset"),a.emit("transitionEnd"),e&&i!==s){if("reset"===n)return void a.emit("slideResetTransitionEnd");a.emit("slideChangeTransitionEnd"),"next"===n?a.emit("slideNextTransitionEnd"):a.emit("slidePrevTransitionEnd")}}}},slide:{slideTo:function(e,t,a,i,s){if(void 0===e&&(e=0),void 0===t&&(t=this.params.speed),void 0===a&&(a=!0),"number"!=typeof e&&"string"!=typeof e)throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. ["+typeof e+"] given.");if("string"==typeof e){var r=parseInt(e,10);if(!isFinite(r))throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. ["+e+"] given.");e=r}var n=this,l=e;l<0&&(l=0);var o=n.params,d=n.snapGrid,p=n.slidesGrid,u=n.previousIndex,c=n.activeIndex,h=n.rtlTranslate,v=n.wrapperEl,f=n.enabled;if(n.animating&&o.preventInteractionOnTransition||!f&&!i&&!s)return!1;var m=Math.min(n.params.slidesPerGroupSkip,l),g=m+Math.floor((l-m)/n.params.slidesPerGroup);g>=d.length&&(g=d.length-1),(c||o.initialSlide||0)===(u||0)&&a&&n.emit("beforeSlideChangeStart");var b,w=-d[g];if(n.updateProgress(w),o.normalizeSlideIndex)for(var y=0;y<p.length;y+=1){var E=-Math.floor(100*w),x=Math.floor(100*p[y]),T=Math.floor(100*p[y+1]);void 0!==p[y+1]?E>=x&&E<T-(T-x)/2?l=y:E>=x&&E<T&&(l=y+1):E>=x&&(l=y)}if(n.initialized&&l!==c){if(!n.allowSlideNext&&w<n.translate&&w<n.minTranslate())return!1;if(!n.allowSlidePrev&&w>n.translate&&w>n.maxTranslate()&&(c||0)!==l)return!1}if(b=l>c?"next":l<c?"prev":"reset",h&&-w===n.translate||!h&&w===n.translate)return n.updateActiveIndex(l),o.autoHeight&&n.updateAutoHeight(),n.updateSlidesClasses(),"slide"!==o.effect&&n.setTranslate(w),"reset"!==b&&(n.transitionStart(a,b),n.transitionEnd(a,b)),!1;if(o.cssMode){var C,S=n.isHorizontal(),M=-w;if(h&&(M=v.scrollWidth-v.offsetWidth-M),0===t)v[S?"scrollLeft":"scrollTop"]=M;else if(v.scrollTo)v.scrollTo(((C={})[S?"left":"top"]=M,C.behavior="smooth",C));else v[S?"scrollLeft":"scrollTop"]=M;return!0}return 0===t?(n.setTransition(0),n.setTranslate(w),n.updateActiveIndex(l),n.updateSlidesClasses(),n.emit("beforeTransitionStart",t,i),n.transitionStart(a,b),n.transitionEnd(a,b)):(n.setTransition(t),n.setTranslate(w),n.updateActiveIndex(l),n.updateSlidesClasses(),n.emit("beforeTransitionStart",t,i),n.transitionStart(a,b),n.animating||(n.animating=!0,n.onSlideToWrapperTransitionEnd||(n.onSlideToWrapperTransitionEnd=function(e){n&&!n.destroyed&&e.target===this&&(n.$wrapperEl[0].removeEventListener("transitionend",n.onSlideToWrapperTransitionEnd),n.$wrapperEl[0].removeEventListener("webkitTransitionEnd",n.onSlideToWrapperTransitionEnd),n.onSlideToWrapperTransitionEnd=null,delete n.onSlideToWrapperTransitionEnd,n.transitionEnd(a,b))}),n.$wrapperEl[0].addEventListener("transitionend",n.onSlideToWrapperTransitionEnd),n.$wrapperEl[0].addEventListener("webkitTransitionEnd",n.onSlideToWrapperTransitionEnd))),!0},slideToLoop:function(e,t,a,i){void 0===e&&(e=0),void 0===t&&(t=this.params.speed),void 0===a&&(a=!0);var s=this,r=e;return s.params.loop&&(r+=s.loopedSlides),s.slideTo(r,t,a,i)},slideNext:function(e,t,a){void 0===e&&(e=this.params.speed),void 0===t&&(t=!0);var i=this,s=i.params,r=i.animating;if(!i.enabled)return i;var n=i.activeIndex<s.slidesPerGroupSkip?1:s.slidesPerGroup;if(s.loop){if(r&&s.loopPreventsSlide)return!1;i.loopFix(),i._clientLeft=i.$wrapperEl[0].clientLeft}return i.slideTo(i.activeIndex+n,e,t,a)},slidePrev:function(e,t,a){void 0===e&&(e=this.params.speed),void 0===t&&(t=!0);var i=this,s=i.params,r=i.animating,n=i.snapGrid,l=i.slidesGrid,o=i.rtlTranslate;if(!i.enabled)return i;if(s.loop){if(r&&s.loopPreventsSlide)return!1;i.loopFix(),i._clientLeft=i.$wrapperEl[0].clientLeft}function d(e){return e<0?-Math.floor(Math.abs(e)):Math.floor(e)}var p,u=d(o?i.translate:-i.translate),c=n.map((function(e){return d(e)})),h=n[c.indexOf(u)-1];return void 0===h&&s.cssMode&&n.forEach((function(e){!h&&u>=e&&(h=e)})),void 0!==h&&(p=l.indexOf(h))<0&&(p=i.activeIndex-1),i.slideTo(p,e,t,a)},slideReset:function(e,t,a){return void 0===e&&(e=this.params.speed),void 0===t&&(t=!0),this.slideTo(this.activeIndex,e,t,a)},slideToClosest:function(e,t,a,i){void 0===e&&(e=this.params.speed),void 0===t&&(t=!0),void 0===i&&(i=.5);var s=this,r=s.activeIndex,n=Math.min(s.params.slidesPerGroupSkip,r),l=n+Math.floor((r-n)/s.params.slidesPerGroup),o=s.rtlTranslate?s.translate:-s.translate;if(o>=s.snapGrid[l]){var d=s.snapGrid[l];o-d>(s.snapGrid[l+1]-d)*i&&(r+=s.params.slidesPerGroup)}else{var p=s.snapGrid[l-1];o-p<=(s.snapGrid[l]-p)*i&&(r-=s.params.slidesPerGroup)}return r=Math.max(r,0),r=Math.min(r,s.slidesGrid.length-1),s.slideTo(r,e,t,a)},slideToClickedSlide:function(){var e,t=this,a=t.params,i=t.$wrapperEl,s="auto"===a.slidesPerView?t.slidesPerViewDynamic():a.slidesPerView,r=t.clickedIndex;if(a.loop){if(t.animating)return;e=parseInt(m(t.clickedSlide).attr("data-swiper-slide-index"),10),a.centeredSlides?r<t.loopedSlides-s/2||r>t.slides.length-t.loopedSlides+s/2?(t.loopFix(),r=i.children("."+a.slideClass+'[data-swiper-slide-index="'+e+'"]:not(.'+a.slideDuplicateClass+")").eq(0).index(),E((function(){t.slideTo(r)}))):t.slideTo(r):r>t.slides.length-s?(t.loopFix(),r=i.children("."+a.slideClass+'[data-swiper-slide-index="'+e+'"]:not(.'+a.slideDuplicateClass+")").eq(0).index(),E((function(){t.slideTo(r)}))):t.slideTo(r)}else t.slideTo(r)}},loop:{loopCreate:function(){var e=this,t=r(),a=e.params,i=e.$wrapperEl;i.children("."+a.slideClass+"."+a.slideDuplicateClass).remove();var s=i.children("."+a.slideClass);if(a.loopFillGroupWithBlank){var n=a.slidesPerGroup-s.length%a.slidesPerGroup;if(n!==a.slidesPerGroup){for(var l=0;l<n;l+=1){var o=m(t.createElement("div")).addClass(a.slideClass+" "+a.slideBlankClass);i.append(o)}s=i.children("."+a.slideClass)}}"auto"!==a.slidesPerView||a.loopedSlides||(a.loopedSlides=s.length),e.loopedSlides=Math.ceil(parseFloat(a.loopedSlides||a.slidesPerView,10)),e.loopedSlides+=a.loopAdditionalSlides,e.loopedSlides>s.length&&(e.loopedSlides=s.length);var d=[],p=[];s.each((function(t,a){var i=m(t);a<e.loopedSlides&&p.push(t),a<s.length&&a>=s.length-e.loopedSlides&&d.push(t),i.attr("data-swiper-slide-index",a)}));for(var u=0;u<p.length;u+=1)i.append(m(p[u].cloneNode(!0)).addClass(a.slideDuplicateClass));for(var c=d.length-1;c>=0;c-=1)i.prepend(m(d[c].cloneNode(!0)).addClass(a.slideDuplicateClass))},loopFix:function(){var e=this;e.emit("beforeLoopFix");var t,a=e.activeIndex,i=e.slides,s=e.loopedSlides,r=e.allowSlidePrev,n=e.allowSlideNext,l=e.snapGrid,o=e.rtlTranslate;e.allowSlidePrev=!0,e.allowSlideNext=!0;var d=-l[a]-e.getTranslate();if(a<s)t=i.length-3*s+a,t+=s,e.slideTo(t,0,!1,!0)&&0!==d&&e.setTranslate((o?-e.translate:e.translate)-d);else if(a>=i.length-s){t=-i.length+a+s,t+=s,e.slideTo(t,0,!1,!0)&&0!==d&&e.setTranslate((o?-e.translate:e.translate)-d)}e.allowSlidePrev=r,e.allowSlideNext=n,e.emit("loopFix")},loopDestroy:function(){var e=this,t=e.$wrapperEl,a=e.params,i=e.slides;t.children("."+a.slideClass+"."+a.slideDuplicateClass+",."+a.slideClass+"."+a.slideBlankClass).remove(),i.removeAttr("data-swiper-slide-index")}},grabCursor:{setGrabCursor:function(e){var t=this;if(!(t.support.touch||!t.params.simulateTouch||t.params.watchOverflow&&t.isLocked||t.params.cssMode)){var a=t.el;a.style.cursor="move",a.style.cursor=e?"-webkit-grabbing":"-webkit-grab",a.style.cursor=e?"-moz-grabbin":"-moz-grab",a.style.cursor=e?"grabbing":"grab"}},unsetGrabCursor:function(){var e=this;e.support.touch||e.params.watchOverflow&&e.isLocked||e.params.cssMode||(e.el.style.cursor="")}},manipulation:{appendSlide:function(e){var t=this,a=t.$wrapperEl,i=t.params;if(i.loop&&t.loopDestroy(),"object"==typeof e&&"length"in e)for(var s=0;s<e.length;s+=1)e[s]&&a.append(e[s]);else a.append(e);i.loop&&t.loopCreate(),i.observer&&t.support.observer||t.update()},prependSlide:function(e){var t=this,a=t.params,i=t.$wrapperEl,s=t.activeIndex;a.loop&&t.loopDestroy();var r=s+1;if("object"==typeof e&&"length"in e){for(var n=0;n<e.length;n+=1)e[n]&&i.prepend(e[n]);r=s+e.length}else i.prepend(e);a.loop&&t.loopCreate(),a.observer&&t.support.observer||t.update(),t.slideTo(r,0,!1)},addSlide:function(e,t){var a=this,i=a.$wrapperEl,s=a.params,r=a.activeIndex;s.loop&&(r-=a.loopedSlides,a.loopDestroy(),a.slides=i.children("."+s.slideClass));var n=a.slides.length;if(e<=0)a.prependSlide(t);else if(e>=n)a.appendSlide(t);else{for(var l=r>e?r+1:r,o=[],d=n-1;d>=e;d-=1){var p=a.slides.eq(d);p.remove(),o.unshift(p)}if("object"==typeof t&&"length"in t){for(var u=0;u<t.length;u+=1)t[u]&&i.append(t[u]);l=r>e?r+t.length:r}else i.append(t);for(var c=0;c<o.length;c+=1)i.append(o[c]);s.loop&&a.loopCreate(),s.observer&&a.support.observer||a.update(),s.loop?a.slideTo(l+a.loopedSlides,0,!1):a.slideTo(l,0,!1)}},removeSlide:function(e){var t=this,a=t.params,i=t.$wrapperEl,s=t.activeIndex;a.loop&&(s-=t.loopedSlides,t.loopDestroy(),t.slides=i.children("."+a.slideClass));var r,n=s;if("object"==typeof e&&"length"in e){for(var l=0;l<e.length;l+=1)r=e[l],t.slides[r]&&t.slides.eq(r).remove(),r<n&&(n-=1);n=Math.max(n,0)}else r=e,t.slides[r]&&t.slides.eq(r).remove(),r<n&&(n-=1),n=Math.max(n,0);a.loop&&t.loopCreate(),a.observer&&t.support.observer||t.update(),a.loop?t.slideTo(n+t.loopedSlides,0,!1):t.slideTo(n,0,!1)},removeAllSlides:function(){for(var e=[],t=0;t<this.slides.length;t+=1)e.push(t);this.removeSlide(e)}},events:{attachEvents:function(){var e=this,t=r(),a=e.params,i=e.touchEvents,s=e.el,n=e.wrapperEl,l=e.device,o=e.support;e.onTouchStart=N.bind(e),e.onTouchMove=G.bind(e),e.onTouchEnd=B.bind(e),a.cssMode&&(e.onScroll=X.bind(e)),e.onClick=R.bind(e);var d=!!a.nested;if(!o.touch&&o.pointerEvents)s.addEventListener(i.start,e.onTouchStart,!1),t.addEventListener(i.move,e.onTouchMove,d),t.addEventListener(i.end,e.onTouchEnd,!1);else{if(o.touch){var p=!("touchstart"!==i.start||!o.passiveListener||!a.passiveListeners)&&{passive:!0,capture:!1};s.addEventListener(i.start,e.onTouchStart,p),s.addEventListener(i.move,e.onTouchMove,o.passiveListener?{passive:!1,capture:d}:d),s.addEventListener(i.end,e.onTouchEnd,p),i.cancel&&s.addEventListener(i.cancel,e.onTouchEnd,p),Y||(t.addEventListener("touchstart",V),Y=!0)}(a.simulateTouch&&!l.ios&&!l.android||a.simulateTouch&&!o.touch&&l.ios)&&(s.addEventListener("mousedown",e.onTouchStart,!1),t.addEventListener("mousemove",e.onTouchMove,d),t.addEventListener("mouseup",e.onTouchEnd,!1))}(a.preventClicks||a.preventClicksPropagation)&&s.addEventListener("click",e.onClick,!0),a.cssMode&&n.addEventListener("scroll",e.onScroll),a.updateOnWindowResize?e.on(l.ios||l.android?"resize orientationchange observerUpdate":"resize observerUpdate",H,!0):e.on("observerUpdate",H,!0)},detachEvents:function(){var e=this,t=r(),a=e.params,i=e.touchEvents,s=e.el,n=e.wrapperEl,l=e.device,o=e.support,d=!!a.nested;if(!o.touch&&o.pointerEvents)s.removeEventListener(i.start,e.onTouchStart,!1),t.removeEventListener(i.move,e.onTouchMove,d),t.removeEventListener(i.end,e.onTouchEnd,!1);else{if(o.touch){var p=!("onTouchStart"!==i.start||!o.passiveListener||!a.passiveListeners)&&{passive:!0,capture:!1};s.removeEventListener(i.start,e.onTouchStart,p),s.removeEventListener(i.move,e.onTouchMove,d),s.removeEventListener(i.end,e.onTouchEnd,p),i.cancel&&s.removeEventListener(i.cancel,e.onTouchEnd,p)}(a.simulateTouch&&!l.ios&&!l.android||a.simulateTouch&&!o.touch&&l.ios)&&(s.removeEventListener("mousedown",e.onTouchStart,!1),t.removeEventListener("mousemove",e.onTouchMove,d),t.removeEventListener("mouseup",e.onTouchEnd,!1))}(a.preventClicks||a.preventClicksPropagation)&&s.removeEventListener("click",e.onClick,!0),a.cssMode&&n.removeEventListener("scroll",e.onScroll),e.off(l.ios||l.android?"resize orientationchange observerUpdate":"resize observerUpdate",H)}},breakpoints:{setBreakpoint:function(){var e=this,t=e.activeIndex,a=e.initialized,i=e.loopedSlides,s=void 0===i?0:i,r=e.params,n=e.$el,l=r.breakpoints;if(l&&(!l||0!==Object.keys(l).length)){var o=e.getBreakpoint(l,e.params.breakpointsBase,e.el);if(o&&e.currentBreakpoint!==o){var d=o in l?l[o]:void 0;d&&["slidesPerView","spaceBetween","slidesPerGroup","slidesPerGroupSkip","slidesPerColumn"].forEach((function(e){var t=d[e];void 0!==t&&(d[e]="slidesPerView"!==e||"AUTO"!==t&&"auto"!==t?"slidesPerView"===e?parseFloat(t):parseInt(t,10):"auto")}));var p=d||e.originalParams,u=r.slidesPerColumn>1,c=p.slidesPerColumn>1,h=r.enabled;u&&!c?(n.removeClass(r.containerModifierClass+"multirow "+r.containerModifierClass+"multirow-column"),e.emitContainerClasses()):!u&&c&&(n.addClass(r.containerModifierClass+"multirow"),(p.slidesPerColumnFill&&"column"===p.slidesPerColumnFill||!p.slidesPerColumnFill&&"column"===r.slidesPerColumnFill)&&n.addClass(r.containerModifierClass+"multirow-column"),e.emitContainerClasses());var v=p.direction&&p.direction!==r.direction,f=r.loop&&(p.slidesPerView!==r.slidesPerView||v);v&&a&&e.changeDirection(),M(e.params,p);var m=e.params.enabled;M(e,{allowTouchMove:e.params.allowTouchMove,allowSlideNext:e.params.allowSlideNext,allowSlidePrev:e.params.allowSlidePrev}),h&&!m?e.disable():!h&&m&&e.enable(),e.currentBreakpoint=o,e.emit("_beforeBreakpoint",p),f&&a&&(e.loopDestroy(),e.loopCreate(),e.updateSlides(),e.slideTo(t-s+e.loopedSlides,0,!1)),e.emit("breakpoint",p)}}},getBreakpoint:function(e,t,a){if(void 0===t&&(t="window"),e&&("container"!==t||a)){var i=!1,s=l(),r="window"===t?s.innerHeight:a.clientHeight,n=Object.keys(e).map((function(e){if("string"==typeof e&&0===e.indexOf("@")){var t=parseFloat(e.substr(1));return{value:r*t,point:e}}return{value:e,point:e}}));n.sort((function(e,t){return parseInt(e.value,10)-parseInt(t.value,10)}));for(var o=0;o<n.length;o+=1){var d=n[o],p=d.point,u=d.value;"window"===t?s.matchMedia("(min-width: "+u+"px)").matches&&(i=p):u<=a.clientWidth&&(i=p)}return i||"max"}}},checkOverflow:{checkOverflow:function(){var e=this,t=e.params,a=e.isLocked,i=e.slides.length>0&&t.slidesOffsetBefore+t.spaceBetween*(e.slides.length-1)+e.slides[0].offsetWidth*e.slides.length;t.slidesOffsetBefore&&t.slidesOffsetAfter&&i?e.isLocked=i<=e.size:e.isLocked=1===e.snapGrid.length,e.allowSlideNext=!e.isLocked,e.allowSlidePrev=!e.isLocked,a!==e.isLocked&&e.emit(e.isLocked?"lock":"unlock"),a&&a!==e.isLocked&&(e.isEnd=!1,e.navigation&&e.navigation.update())}},classes:{addClasses:function(){var e,t,a,i=this,s=i.classNames,r=i.params,n=i.rtl,l=i.$el,o=i.device,d=i.support,p=(e=["initialized",r.direction,{"pointer-events":d.pointerEvents&&!d.touch},{"free-mode":r.freeMode},{autoheight:r.autoHeight},{rtl:n},{multirow:r.slidesPerColumn>1},{"multirow-column":r.slidesPerColumn>1&&"column"===r.slidesPerColumnFill},{android:o.android},{ios:o.ios},{"css-mode":r.cssMode}],t=r.containerModifierClass,a=[],e.forEach((function(e){"object"==typeof e?Object.keys(e).forEach((function(i){e[i]&&a.push(t+i)})):"string"==typeof e&&a.push(t+e)})),a);s.push.apply(s,p),l.addClass([].concat(s).join(" ")),i.emitContainerClasses()},removeClasses:function(){var e=this,t=e.$el,a=e.classNames;t.removeClass(a.join(" ")),e.emitContainerClasses()}},images:{loadImage:function(e,t,a,i,s,r){var n,o=l();function d(){r&&r()}m(e).parent("picture")[0]||e.complete&&s?d():t?((n=new o.Image).onload=d,n.onerror=d,i&&(n.sizes=i),a&&(n.srcset=a),t&&(n.src=t)):d()},preloadImages:function(){var e=this;function t(){null!=e&&e&&!e.destroyed&&(void 0!==e.imagesLoaded&&(e.imagesLoaded+=1),e.imagesLoaded===e.imagesToLoad.length&&(e.params.updateOnImagesReady&&e.update(),e.emit("imagesReady")))}e.imagesToLoad=e.$el.find("img");for(var a=0;a<e.imagesToLoad.length;a+=1){var i=e.imagesToLoad[a];e.loadImage(i,i.currentSrc||i.getAttribute("src"),i.srcset||i.getAttribute("srcset"),i.sizes||i.getAttribute("sizes"),!0,t)}}}},_={},q=function(){function t(){for(var e,a,i=arguments.length,s=new Array(i),r=0;r<i;r++)s[r]=arguments[r];if(1===s.length&&s[0].constructor&&"Object"===Object.prototype.toString.call(s[0]).slice(8,-1)?a=s[0]:(e=s[0],a=s[1]),a||(a={}),a=M({},a),e&&!a.el&&(a.el=e),a.el&&m(a.el).length>1){var n=[];return m(a.el).each((function(e){var i=M({},a,{el:e});n.push(new t(i))})),n}var l=this;l.__swiper__=!0,l.support=$(),l.device=L({userAgent:a.userAgent}),l.browser=I(),l.eventsListeners={},l.eventsAnyListeners=[],void 0===l.modules&&(l.modules={}),Object.keys(l.modules).forEach((function(e){var t=l.modules[e];if(t.params){var i=Object.keys(t.params)[0],s=t.params[i];if("object"!=typeof s||null===s)return;if(["navigation","pagination","scrollbar"].indexOf(i)>=0&&!0===a[i]&&(a[i]={auto:!0}),!(i in a)||!("enabled"in s))return;!0===a[i]&&(a[i]={enabled:!0}),"object"!=typeof a[i]||"enabled"in a[i]||(a[i].enabled=!0),a[i]||(a[i]={enabled:!1})}}));var o,d,p=M({},W);return l.useParams(p),l.params=M({},p,_,a),l.originalParams=M({},l.params),l.passedParams=M({},a),l.params&&l.params.on&&Object.keys(l.params.on).forEach((function(e){l.on(e,l.params.on[e])})),l.params&&l.params.onAny&&l.onAny(l.params.onAny),l.$=m,M(l,{enabled:l.params.enabled,el:e,classNames:[],slides:m(),slidesGrid:[],snapGrid:[],slidesSizesGrid:[],isHorizontal:function(){return"horizontal"===l.params.direction},isVertical:function(){return"vertical"===l.params.direction},activeIndex:0,realIndex:0,isBeginning:!0,isEnd:!1,translate:0,previousTranslate:0,progress:0,velocity:0,animating:!1,allowSlideNext:l.params.allowSlideNext,allowSlidePrev:l.params.allowSlidePrev,touchEvents:(o=["touchstart","touchmove","touchend","touchcancel"],d=["mousedown","mousemove","mouseup"],l.support.pointerEvents&&(d=["pointerdown","pointermove","pointerup"]),l.touchEventsTouch={start:o[0],move:o[1],end:o[2],cancel:o[3]},l.touchEventsDesktop={start:d[0],move:d[1],end:d[2]},l.support.touch||!l.params.simulateTouch?l.touchEventsTouch:l.touchEventsDesktop),touchEventsData:{isTouched:void 0,isMoved:void 0,allowTouchCallbacks:void 0,touchStartTime:void 0,isScrolling:void 0,currentTranslate:void 0,startTranslate:void 0,allowThresholdMove:void 0,focusableElements:l.params.focusableElements,lastClickTime:x(),clickTimeout:void 0,velocities:[],allowMomentumBounce:void 0,isTouchEvent:void 0,startMoving:void 0},allowClick:!0,allowTouchMove:l.params.allowTouchMove,touches:{startX:0,startY:0,currentX:0,currentY:0,diff:0},imagesToLoad:[],imagesLoaded:0}),l.useModules(),l.emit("_swiper"),l.params.init&&l.init(),l}var a,i,s,n=t.prototype;return n.enable=function(){var e=this;e.enabled||(e.enabled=!0,e.params.grabCursor&&e.setGrabCursor(),e.emit("enable"))},n.disable=function(){var e=this;e.enabled&&(e.enabled=!1,e.params.grabCursor&&e.unsetGrabCursor(),e.emit("disable"))},n.setProgress=function(e,t){var a=this;e=Math.min(Math.max(e,0),1);var i=a.minTranslate(),s=(a.maxTranslate()-i)*e+i;a.translateTo(s,void 0===t?0:t),a.updateActiveIndex(),a.updateSlidesClasses()},n.emitContainerClasses=function(){var e=this;if(e.params._emitClasses&&e.el){var t=e.el.className.split(" ").filter((function(t){return 0===t.indexOf("swiper-container")||0===t.indexOf(e.params.containerModifierClass)}));e.emit("_containerClasses",t.join(" "))}},n.getSlideClasses=function(e){var t=this;return e.className.split(" ").filter((function(e){return 0===e.indexOf("swiper-slide")||0===e.indexOf(t.params.slideClass)})).join(" ")},n.emitSlidesClasses=function(){var e=this;if(e.params._emitClasses&&e.el){var t=[];e.slides.each((function(a){var i=e.getSlideClasses(a);t.push({slideEl:a,classNames:i}),e.emit("_slideClass",a,i)})),e.emit("_slideClasses",t)}},n.slidesPerViewDynamic=function(){var e=this,t=e.params,a=e.slides,i=e.slidesGrid,s=e.size,r=e.activeIndex,n=1;if(t.centeredSlides){for(var l,o=a[r].swiperSlideSize,d=r+1;d<a.length;d+=1)a[d]&&!l&&(n+=1,(o+=a[d].swiperSlideSize)>s&&(l=!0));for(var p=r-1;p>=0;p-=1)a[p]&&!l&&(n+=1,(o+=a[p].swiperSlideSize)>s&&(l=!0))}else for(var u=r+1;u<a.length;u+=1)i[u]-i[r]<s&&(n+=1);return n},n.update=function(){var e=this;if(e&&!e.destroyed){var t=e.snapGrid,a=e.params;a.breakpoints&&e.setBreakpoint(),e.updateSize(),e.updateSlides(),e.updateProgress(),e.updateSlidesClasses(),e.params.freeMode?(i(),e.params.autoHeight&&e.updateAutoHeight()):(("auto"===e.params.slidesPerView||e.params.slidesPerView>1)&&e.isEnd&&!e.params.centeredSlides?e.slideTo(e.slides.length-1,0,!1,!0):e.slideTo(e.activeIndex,0,!1,!0))||i(),a.watchOverflow&&t!==e.snapGrid&&e.checkOverflow(),e.emit("update")}function i(){var t=e.rtlTranslate?-1*e.translate:e.translate,a=Math.min(Math.max(t,e.maxTranslate()),e.minTranslate());e.setTranslate(a),e.updateActiveIndex(),e.updateSlidesClasses()}},n.changeDirection=function(e,t){void 0===t&&(t=!0);var a=this,i=a.params.direction;return e||(e="horizontal"===i?"vertical":"horizontal"),e===i||"horizontal"!==e&&"vertical"!==e||(a.$el.removeClass(""+a.params.containerModifierClass+i).addClass(""+a.params.containerModifierClass+e),a.emitContainerClasses(),a.params.direction=e,a.slides.each((function(t){"vertical"===e?t.style.width="":t.style.height=""})),a.emit("changeDirection"),t&&a.update()),a},n.mount=function(e){var t=this;if(t.mounted)return!0;var a=m(e||t.params.el);if(!(e=a[0]))return!1;e.swiper=t;var i=function(){return"."+(t.params.wrapperClass||"").trim().split(" ").join(".")},s=function(){if(e&&e.shadowRoot&&e.shadowRoot.querySelector){var t=m(e.shadowRoot.querySelector(i()));return t.children=function(e){return a.children(e)},t}return a.children(i())}();if(0===s.length&&t.params.createElements){var n=r().createElement("div");s=m(n),n.className=t.params.wrapperClass,a.append(n),a.children("."+t.params.slideClass).each((function(e){s.append(e)}))}return M(t,{$el:a,el:e,$wrapperEl:s,wrapperEl:s[0],mounted:!0,rtl:"rtl"===e.dir.toLowerCase()||"rtl"===a.css("direction"),rtlTranslate:"horizontal"===t.params.direction&&("rtl"===e.dir.toLowerCase()||"rtl"===a.css("direction")),wrongRTL:"-webkit-box"===s.css("display")}),!0},n.init=function(e){var t=this;return t.initialized||!1===t.mount(e)||(t.emit("beforeInit"),t.params.breakpoints&&t.setBreakpoint(),t.addClasses(),t.params.loop&&t.loopCreate(),t.updateSize(),t.updateSlides(),t.params.watchOverflow&&t.checkOverflow(),t.params.grabCursor&&t.enabled&&t.setGrabCursor(),t.params.preloadImages&&t.preloadImages(),t.params.loop?t.slideTo(t.params.initialSlide+t.loopedSlides,0,t.params.runCallbacksOnInit,!1,!0):t.slideTo(t.params.initialSlide,0,t.params.runCallbacksOnInit,!1,!0),t.attachEvents(),t.initialized=!0,t.emit("init"),t.emit("afterInit")),t},n.destroy=function(e,t){void 0===e&&(e=!0),void 0===t&&(t=!0);var a,i=this,s=i.params,r=i.$el,n=i.$wrapperEl,l=i.slides;return void 0===i.params||i.destroyed||(i.emit("beforeDestroy"),i.initialized=!1,i.detachEvents(),s.loop&&i.loopDestroy(),t&&(i.removeClasses(),r.removeAttr("style"),n.removeAttr("style"),l&&l.length&&l.removeClass([s.slideVisibleClass,s.slideActiveClass,s.slideNextClass,s.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")),i.emit("destroy"),Object.keys(i.eventsListeners).forEach((function(e){i.off(e)})),!1!==e&&(i.$el[0].swiper=null,a=i,Object.keys(a).forEach((function(e){try{a[e]=null}catch(e){}try{delete a[e]}catch(e){}}))),i.destroyed=!0),null},t.extendDefaults=function(e){M(_,e)},t.installModule=function(e){t.prototype.modules||(t.prototype.modules={});var a=e.name||Object.keys(t.prototype.modules).length+"_"+x();t.prototype.modules[a]=e},t.use=function(e){return Array.isArray(e)?(e.forEach((function(e){return t.installModule(e)})),t):(t.installModule(e),t)},a=t,s=[{key:"extendedDefaults",get:function(){return _}},{key:"defaults",get:function(){return W}}],(i=null)&&e(a.prototype,i),s&&e(a,s),t}();Object.keys(F).forEach((function(e){Object.keys(F[e]).forEach((function(t){q.prototype[t]=F[e][t]}))})),q.use([O,D]);var j={update:function(e){var t=this,a=t.params,i=a.slidesPerView,s=a.slidesPerGroup,r=a.centeredSlides,n=t.params.virtual,l=n.addSlidesBefore,o=n.addSlidesAfter,d=t.virtual,p=d.from,u=d.to,c=d.slides,h=d.slidesGrid,v=d.renderSlide,f=d.offset;t.updateActiveIndex();var m,g,b,w=t.activeIndex||0;m=t.rtlTranslate?"right":t.isHorizontal()?"left":"top",r?(g=Math.floor(i/2)+s+o,b=Math.floor(i/2)+s+l):(g=i+(s-1)+o,b=s+l);var y=Math.max((w||0)-b,0),E=Math.min((w||0)+g,c.length-1),x=(t.slidesGrid[y]||0)-(t.slidesGrid[0]||0);function T(){t.updateSlides(),t.updateProgress(),t.updateSlidesClasses(),t.lazy&&t.params.lazy.enabled&&t.lazy.load()}if(M(t.virtual,{from:y,to:E,offset:x,slidesGrid:t.slidesGrid}),p===y&&u===E&&!e)return t.slidesGrid!==h&&x!==f&&t.slides.css(m,x+"px"),void t.updateProgress();if(t.params.virtual.renderExternal)return t.params.virtual.renderExternal.call(t,{offset:x,from:y,to:E,slides:function(){for(var e=[],t=y;t<=E;t+=1)e.push(c[t]);return e}()}),void(t.params.virtual.renderExternalUpdate&&T());var C=[],S=[];if(e)t.$wrapperEl.find("."+t.params.slideClass).remove();else for(var z=p;z<=u;z+=1)(z<y||z>E)&&t.$wrapperEl.find("."+t.params.slideClass+'[data-swiper-slide-index="'+z+'"]').remove();for(var P=0;P<c.length;P+=1)P>=y&&P<=E&&(void 0===u||e?S.push(P):(P>u&&S.push(P),P<p&&C.push(P)));S.forEach((function(e){t.$wrapperEl.append(v(c[e],e))})),C.sort((function(e,t){return t-e})).forEach((function(e){t.$wrapperEl.prepend(v(c[e],e))})),t.$wrapperEl.children(".swiper-slide").css(m,x+"px"),T()},renderSlide:function(e,t){var a=this,i=a.params.virtual;if(i.cache&&a.virtual.cache[t])return a.virtual.cache[t];var s=i.renderSlide?m(i.renderSlide.call(a,e,t)):m('<div class="'+a.params.slideClass+'" data-swiper-slide-index="'+t+'">'+e+"</div>");return s.attr("data-swiper-slide-index")||s.attr("data-swiper-slide-index",t),i.cache&&(a.virtual.cache[t]=s),s},appendSlide:function(e){var t=this;if("object"==typeof e&&"length"in e)for(var a=0;a<e.length;a+=1)e[a]&&t.virtual.slides.push(e[a]);else t.virtual.slides.push(e);t.virtual.update(!0)},prependSlide:function(e){var t=this,a=t.activeIndex,i=a+1,s=1;if(Array.isArray(e)){for(var r=0;r<e.length;r+=1)e[r]&&t.virtual.slides.unshift(e[r]);i=a+e.length,s=e.length}else t.virtual.slides.unshift(e);if(t.params.virtual.cache){var n=t.virtual.cache,l={};Object.keys(n).forEach((function(e){var t=n[e],a=t.attr("data-swiper-slide-index");a&&t.attr("data-swiper-slide-index",parseInt(a,10)+1),l[parseInt(e,10)+s]=t})),t.virtual.cache=l}t.virtual.update(!0),t.slideTo(i,0)},removeSlide:function(e){var t=this;if(null!=e){var a=t.activeIndex;if(Array.isArray(e))for(var i=e.length-1;i>=0;i-=1)t.virtual.slides.splice(e[i],1),t.params.virtual.cache&&delete t.virtual.cache[e[i]],e[i]<a&&(a-=1),a=Math.max(a,0);else t.virtual.slides.splice(e,1),t.params.virtual.cache&&delete t.virtual.cache[e],e<a&&(a-=1),a=Math.max(a,0);t.virtual.update(!0),t.slideTo(a,0)}},removeAllSlides:function(){var e=this;e.virtual.slides=[],e.params.virtual.cache&&(e.virtual.cache={}),e.virtual.update(!0),e.slideTo(0,0)}},U={name:"virtual",params:{virtual:{enabled:!1,slides:[],cache:!0,renderSlide:null,renderExternal:null,renderExternalUpdate:!0,addSlidesBefore:0,addSlidesAfter:0}},create:function(){z(this,{virtual:t({},j,{slides:this.params.virtual.slides,cache:{}})})},on:{beforeInit:function(e){if(e.params.virtual.enabled){e.classNames.push(e.params.containerModifierClass+"virtual");var t={watchSlidesProgress:!0};M(e.params,t),M(e.originalParams,t),e.params.initialSlide||e.virtual.update()}},setTranslate:function(e){e.params.virtual.enabled&&e.virtual.update()}}},K={handle:function(e){var t=this;if(t.enabled){var a=l(),i=r(),s=t.rtlTranslate,n=e;n.originalEvent&&(n=n.originalEvent);var o=n.keyCode||n.charCode,d=t.params.keyboard.pageUpDown,p=d&&33===o,u=d&&34===o,c=37===o,h=39===o,v=38===o,f=40===o;if(!t.allowSlideNext&&(t.isHorizontal()&&h||t.isVertical()&&f||u))return!1;if(!t.allowSlidePrev&&(t.isHorizontal()&&c||t.isVertical()&&v||p))return!1;if(!(n.shiftKey||n.altKey||n.ctrlKey||n.metaKey||i.activeElement&&i.activeElement.nodeName&&("input"===i.activeElement.nodeName.toLowerCase()||"textarea"===i.activeElement.nodeName.toLowerCase()))){if(t.params.keyboard.onlyInViewport&&(p||u||c||h||v||f)){var m=!1;if(t.$el.parents("."+t.params.slideClass).length>0&&0===t.$el.parents("."+t.params.slideActiveClass).length)return;var g=t.$el,b=g[0].clientWidth,w=g[0].clientHeight,y=a.innerWidth,E=a.innerHeight,x=t.$el.offset();s&&(x.left-=t.$el[0].scrollLeft);for(var T=[[x.left,x.top],[x.left+b,x.top],[x.left,x.top+w],[x.left+b,x.top+w]],C=0;C<T.length;C+=1){var S=T[C];if(S[0]>=0&&S[0]<=y&&S[1]>=0&&S[1]<=E){if(0===S[0]&&0===S[1])continue;m=!0}}if(!m)return}t.isHorizontal()?((p||u||c||h)&&(n.preventDefault?n.preventDefault():n.returnValue=!1),((u||h)&&!s||(p||c)&&s)&&t.slideNext(),((p||c)&&!s||(u||h)&&s)&&t.slidePrev()):((p||u||v||f)&&(n.preventDefault?n.preventDefault():n.returnValue=!1),(u||f)&&t.slideNext(),(p||v)&&t.slidePrev()),t.emit("keyPress",o)}}},enable:function(){var e=this,t=r();e.keyboard.enabled||(m(t).on("keydown",e.keyboard.handle),e.keyboard.enabled=!0)},disable:function(){var e=this,t=r();e.keyboard.enabled&&(m(t).off("keydown",e.keyboard.handle),e.keyboard.enabled=!1)}},Z={name:"keyboard",params:{keyboard:{enabled:!1,onlyInViewport:!0,pageUpDown:!0}},create:function(){z(this,{keyboard:t({enabled:!1},K)})},on:{init:function(e){e.params.keyboard.enabled&&e.keyboard.enable()},destroy:function(e){e.keyboard.enabled&&e.keyboard.disable()}}};var J={lastScrollTime:x(),lastEventBeforeSnap:void 0,recentWheelEvents:[],event:function(){return l().navigator.userAgent.indexOf("firefox")>-1?"DOMMouseScroll":function(){var e=r(),t="onwheel",a=t in e;if(!a){var i=e.createElement("div");i.setAttribute(t,"return;"),a="function"==typeof i.onwheel}return!a&&e.implementation&&e.implementation.hasFeature&&!0!==e.implementation.hasFeature("","")&&(a=e.implementation.hasFeature("Events.wheel","3.0")),a}()?"wheel":"mousewheel"},normalize:function(e){var t=0,a=0,i=0,s=0;return"detail"in e&&(a=e.detail),"wheelDelta"in e&&(a=-e.wheelDelta/120),"wheelDeltaY"in e&&(a=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=a,a=0),i=10*t,s=10*a,"deltaY"in e&&(s=e.deltaY),"deltaX"in e&&(i=e.deltaX),e.shiftKey&&!i&&(i=s,s=0),(i||s)&&e.deltaMode&&(1===e.deltaMode?(i*=40,s*=40):(i*=800,s*=800)),i&&!t&&(t=i<1?-1:1),s&&!a&&(a=s<1?-1:1),{spinX:t,spinY:a,pixelX:i,pixelY:s}},handleMouseEnter:function(){this.enabled&&(this.mouseEntered=!0)},handleMouseLeave:function(){this.enabled&&(this.mouseEntered=!1)},handle:function(e){var t=e,a=this;if(a.enabled){var i=a.params.mousewheel;a.params.cssMode&&t.preventDefault();var s=a.$el;if("container"!==a.params.mousewheel.eventsTarget&&(s=m(a.params.mousewheel.eventsTarget)),!a.mouseEntered&&!s[0].contains(t.target)&&!i.releaseOnEdges)return!0;t.originalEvent&&(t=t.originalEvent);var r=0,n=a.rtlTranslate?-1:1,l=J.normalize(t);if(i.forceToAxis)if(a.isHorizontal()){if(!(Math.abs(l.pixelX)>Math.abs(l.pixelY)))return!0;r=-l.pixelX*n}else{if(!(Math.abs(l.pixelY)>Math.abs(l.pixelX)))return!0;r=-l.pixelY}else r=Math.abs(l.pixelX)>Math.abs(l.pixelY)?-l.pixelX*n:-l.pixelY;if(0===r)return!0;i.invert&&(r=-r);var o=a.getTranslate()+r*i.sensitivity;if(o>=a.minTranslate()&&(o=a.minTranslate()),o<=a.maxTranslate()&&(o=a.maxTranslate()),(!!a.params.loop||!(o===a.minTranslate()||o===a.maxTranslate()))&&a.params.nested&&t.stopPropagation(),a.params.freeMode){var d={time:x(),delta:Math.abs(r),direction:Math.sign(r)},p=a.mousewheel.lastEventBeforeSnap,u=p&&d.time<p.time+500&&d.delta<=p.delta&&d.direction===p.direction;if(!u){a.mousewheel.lastEventBeforeSnap=void 0,a.params.loop&&a.loopFix();var c=a.getTranslate()+r*i.sensitivity,h=a.isBeginning,v=a.isEnd;if(c>=a.minTranslate()&&(c=a.minTranslate()),c<=a.maxTranslate()&&(c=a.maxTranslate()),a.setTransition(0),a.setTranslate(c),a.updateProgress(),a.updateActiveIndex(),a.updateSlidesClasses(),(!h&&a.isBeginning||!v&&a.isEnd)&&a.updateSlidesClasses(),a.params.freeModeSticky){clearTimeout(a.mousewheel.timeout),a.mousewheel.timeout=void 0;var f=a.mousewheel.recentWheelEvents;f.length>=15&&f.shift();var g=f.length?f[f.length-1]:void 0,b=f[0];if(f.push(d),g&&(d.delta>g.delta||d.direction!==g.direction))f.splice(0);else if(f.length>=15&&d.time-b.time<500&&b.delta-d.delta>=1&&d.delta<=6){var w=r>0?.8:.2;a.mousewheel.lastEventBeforeSnap=d,f.splice(0),a.mousewheel.timeout=E((function(){a.slideToClosest(a.params.speed,!0,void 0,w)}),0)}a.mousewheel.timeout||(a.mousewheel.timeout=E((function(){a.mousewheel.lastEventBeforeSnap=d,f.splice(0),a.slideToClosest(a.params.speed,!0,void 0,.5)}),500))}if(u||a.emit("scroll",t),a.params.autoplay&&a.params.autoplayDisableOnInteraction&&a.autoplay.stop(),c===a.minTranslate()||c===a.maxTranslate())return!0}}else{var y={time:x(),delta:Math.abs(r),direction:Math.sign(r),raw:e},T=a.mousewheel.recentWheelEvents;T.length>=2&&T.shift();var C=T.length?T[T.length-1]:void 0;if(T.push(y),C?(y.direction!==C.direction||y.delta>C.delta||y.time>C.time+150)&&a.mousewheel.animateSlider(y):a.mousewheel.animateSlider(y),a.mousewheel.releaseScroll(y))return!0}return t.preventDefault?t.preventDefault():t.returnValue=!1,!1}},animateSlider:function(e){var t=this,a=l();return!(this.params.mousewheel.thresholdDelta&&e.delta<this.params.mousewheel.thresholdDelta)&&(!(this.params.mousewheel.thresholdTime&&x()-t.mousewheel.lastScrollTime<this.params.mousewheel.thresholdTime)&&(e.delta>=6&&x()-t.mousewheel.lastScrollTime<60||(e.direction<0?t.isEnd&&!t.params.loop||t.animating||(t.slideNext(),t.emit("scroll",e.raw)):t.isBeginning&&!t.params.loop||t.animating||(t.slidePrev(),t.emit("scroll",e.raw)),t.mousewheel.lastScrollTime=(new a.Date).getTime(),!1)))},releaseScroll:function(e){var t=this,a=t.params.mousewheel;if(e.direction<0){if(t.isEnd&&!t.params.loop&&a.releaseOnEdges)return!0}else if(t.isBeginning&&!t.params.loop&&a.releaseOnEdges)return!0;return!1},enable:function(){var e=this,t=J.event();if(e.params.cssMode)return e.wrapperEl.removeEventListener(t,e.mousewheel.handle),!0;if(!t)return!1;if(e.mousewheel.enabled)return!1;var a=e.$el;return"container"!==e.params.mousewheel.eventsTarget&&(a=m(e.params.mousewheel.eventsTarget)),a.on("mouseenter",e.mousewheel.handleMouseEnter),a.on("mouseleave",e.mousewheel.handleMouseLeave),a.on(t,e.mousewheel.handle),e.mousewheel.enabled=!0,!0},disable:function(){var e=this,t=J.event();if(e.params.cssMode)return e.wrapperEl.addEventListener(t,e.mousewheel.handle),!0;if(!t)return!1;if(!e.mousewheel.enabled)return!1;var a=e.$el;return"container"!==e.params.mousewheel.eventsTarget&&(a=m(e.params.mousewheel.eventsTarget)),a.off(t,e.mousewheel.handle),e.mousewheel.enabled=!1,!0}},Q={toggleEl:function(e,t){e[t?"addClass":"removeClass"](this.params.navigation.disabledClass),e[0]&&"BUTTON"===e[0].tagName&&(e[0].disabled=t)},update:function(){var e=this,t=e.params.navigation,a=e.navigation.toggleEl;if(!e.params.loop){var i=e.navigation,s=i.$nextEl,r=i.$prevEl;r&&r.length>0&&(e.isBeginning?a(r,!0):a(r,!1),e.params.watchOverflow&&e.enabled&&r[e.isLocked?"addClass":"removeClass"](t.lockClass)),s&&s.length>0&&(e.isEnd?a(s,!0):a(s,!1),e.params.watchOverflow&&e.enabled&&s[e.isLocked?"addClass":"removeClass"](t.lockClass))}},onPrevClick:function(e){var t=this;e.preventDefault(),t.isBeginning&&!t.params.loop||t.slidePrev()},onNextClick:function(e){var t=this;e.preventDefault(),t.isEnd&&!t.params.loop||t.slideNext()},init:function(){var e,t,a=this,i=a.params.navigation;(a.params.navigation=k(a.$el,a.params.navigation,a.params.createElements,{nextEl:"swiper-button-next",prevEl:"swiper-button-prev"}),i.nextEl||i.prevEl)&&(i.nextEl&&(e=m(i.nextEl),a.params.uniqueNavElements&&"string"==typeof i.nextEl&&e.length>1&&1===a.$el.find(i.nextEl).length&&(e=a.$el.find(i.nextEl))),i.prevEl&&(t=m(i.prevEl),a.params.uniqueNavElements&&"string"==typeof i.prevEl&&t.length>1&&1===a.$el.find(i.prevEl).length&&(t=a.$el.find(i.prevEl))),e&&e.length>0&&e.on("click",a.navigation.onNextClick),t&&t.length>0&&t.on("click",a.navigation.onPrevClick),M(a.navigation,{$nextEl:e,nextEl:e&&e[0],$prevEl:t,prevEl:t&&t[0]}),a.enabled||(e&&e.addClass(i.lockClass),t&&t.addClass(i.lockClass)))},destroy:function(){var e=this,t=e.navigation,a=t.$nextEl,i=t.$prevEl;a&&a.length&&(a.off("click",e.navigation.onNextClick),a.removeClass(e.params.navigation.disabledClass)),i&&i.length&&(i.off("click",e.navigation.onPrevClick),i.removeClass(e.params.navigation.disabledClass))}},ee={update:function(){var e=this,t=e.rtl,a=e.params.pagination;if(a.el&&e.pagination.el&&e.pagination.$el&&0!==e.pagination.$el.length){var i,s=e.virtual&&e.params.virtual.enabled?e.virtual.slides.length:e.slides.length,r=e.pagination.$el,n=e.params.loop?Math.ceil((s-2*e.loopedSlides)/e.params.slidesPerGroup):e.snapGrid.length;if(e.params.loop?((i=Math.ceil((e.activeIndex-e.loopedSlides)/e.params.slidesPerGroup))>s-1-2*e.loopedSlides&&(i-=s-2*e.loopedSlides),i>n-1&&(i-=n),i<0&&"bullets"!==e.params.paginationType&&(i=n+i)):i=void 0!==e.snapIndex?e.snapIndex:e.activeIndex||0,"bullets"===a.type&&e.pagination.bullets&&e.pagination.bullets.length>0){var l,o,d,p=e.pagination.bullets;if(a.dynamicBullets&&(e.pagination.bulletSize=p.eq(0)[e.isHorizontal()?"outerWidth":"outerHeight"](!0),r.css(e.isHorizontal()?"width":"height",e.pagination.bulletSize*(a.dynamicMainBullets+4)+"px"),a.dynamicMainBullets>1&&void 0!==e.previousIndex&&(e.pagination.dynamicBulletIndex+=i-e.previousIndex,e.pagination.dynamicBulletIndex>a.dynamicMainBullets-1?e.pagination.dynamicBulletIndex=a.dynamicMainBullets-1:e.pagination.dynamicBulletIndex<0&&(e.pagination.dynamicBulletIndex=0)),l=i-e.pagination.dynamicBulletIndex,d=((o=l+(Math.min(p.length,a.dynamicMainBullets)-1))+l)/2),p.removeClass(a.bulletActiveClass+" "+a.bulletActiveClass+"-next "+a.bulletActiveClass+"-next-next "+a.bulletActiveClass+"-prev "+a.bulletActiveClass+"-prev-prev "+a.bulletActiveClass+"-main"),r.length>1)p.each((function(e){var t=m(e),s=t.index();s===i&&t.addClass(a.bulletActiveClass),a.dynamicBullets&&(s>=l&&s<=o&&t.addClass(a.bulletActiveClass+"-main"),s===l&&t.prev().addClass(a.bulletActiveClass+"-prev").prev().addClass(a.bulletActiveClass+"-prev-prev"),s===o&&t.next().addClass(a.bulletActiveClass+"-next").next().addClass(a.bulletActiveClass+"-next-next"))}));else{var u=p.eq(i),c=u.index();if(u.addClass(a.bulletActiveClass),a.dynamicBullets){for(var h=p.eq(l),v=p.eq(o),f=l;f<=o;f+=1)p.eq(f).addClass(a.bulletActiveClass+"-main");if(e.params.loop)if(c>=p.length-a.dynamicMainBullets){for(var g=a.dynamicMainBullets;g>=0;g-=1)p.eq(p.length-g).addClass(a.bulletActiveClass+"-main");p.eq(p.length-a.dynamicMainBullets-1).addClass(a.bulletActiveClass+"-prev")}else h.prev().addClass(a.bulletActiveClass+"-prev").prev().addClass(a.bulletActiveClass+"-prev-prev"),v.next().addClass(a.bulletActiveClass+"-next").next().addClass(a.bulletActiveClass+"-next-next");else h.prev().addClass(a.bulletActiveClass+"-prev").prev().addClass(a.bulletActiveClass+"-prev-prev"),v.next().addClass(a.bulletActiveClass+"-next").next().addClass(a.bulletActiveClass+"-next-next")}}if(a.dynamicBullets){var b=Math.min(p.length,a.dynamicMainBullets+4),w=(e.pagination.bulletSize*b-e.pagination.bulletSize)/2-d*e.pagination.bulletSize,y=t?"right":"left";p.css(e.isHorizontal()?y:"top",w+"px")}}if("fraction"===a.type&&(r.find(P(a.currentClass)).text(a.formatFractionCurrent(i+1)),r.find(P(a.totalClass)).text(a.formatFractionTotal(n))),"progressbar"===a.type){var E;E=a.progressbarOpposite?e.isHorizontal()?"vertical":"horizontal":e.isHorizontal()?"horizontal":"vertical";var x=(i+1)/n,T=1,C=1;"horizontal"===E?T=x:C=x,r.find(P(a.progressbarFillClass)).transform("translate3d(0,0,0) scaleX("+T+") scaleY("+C+")").transition(e.params.speed)}"custom"===a.type&&a.renderCustom?(r.html(a.renderCustom(e,i+1,n)),e.emit("paginationRender",r[0])):e.emit("paginationUpdate",r[0]),e.params.watchOverflow&&e.enabled&&r[e.isLocked?"addClass":"removeClass"](a.lockClass)}},render:function(){var e=this,t=e.params.pagination;if(t.el&&e.pagination.el&&e.pagination.$el&&0!==e.pagination.$el.length){var a=e.virtual&&e.params.virtual.enabled?e.virtual.slides.length:e.slides.length,i=e.pagination.$el,s="";if("bullets"===t.type){var r=e.params.loop?Math.ceil((a-2*e.loopedSlides)/e.params.slidesPerGroup):e.snapGrid.length;e.params.freeMode&&!e.params.loop&&r>a&&(r=a);for(var n=0;n<r;n+=1)t.renderBullet?s+=t.renderBullet.call(e,n,t.bulletClass):s+="<"+t.bulletElement+' class="'+t.bulletClass+'"></'+t.bulletElement+">";i.html(s),e.pagination.bullets=i.find(P(t.bulletClass))}"fraction"===t.type&&(s=t.renderFraction?t.renderFraction.call(e,t.currentClass,t.totalClass):'<span class="'+t.currentClass+'"></span> / <span class="'+t.totalClass+'"></span>',i.html(s)),"progressbar"===t.type&&(s=t.renderProgressbar?t.renderProgressbar.call(e,t.progressbarFillClass):'<span class="'+t.progressbarFillClass+'"></span>',i.html(s)),"custom"!==t.type&&e.emit("paginationRender",e.pagination.$el[0])}},init:function(){var e=this;e.params.pagination=k(e.$el,e.params.pagination,e.params.createElements,{el:"swiper-pagination"});var t=e.params.pagination;if(t.el){var a=m(t.el);0!==a.length&&(e.params.uniqueNavElements&&"string"==typeof t.el&&a.length>1&&(a=e.$el.find(t.el)),"bullets"===t.type&&t.clickable&&a.addClass(t.clickableClass),a.addClass(t.modifierClass+t.type),"bullets"===t.type&&t.dynamicBullets&&(a.addClass(""+t.modifierClass+t.type+"-dynamic"),e.pagination.dynamicBulletIndex=0,t.dynamicMainBullets<1&&(t.dynamicMainBullets=1)),"progressbar"===t.type&&t.progressbarOpposite&&a.addClass(t.progressbarOppositeClass),t.clickable&&a.on("click",P(t.bulletClass),(function(t){t.preventDefault();var a=m(this).index()*e.params.slidesPerGroup;e.params.loop&&(a+=e.loopedSlides),e.slideTo(a)})),M(e.pagination,{$el:a,el:a[0]}),e.enabled||a.addClass(t.lockClass))}},destroy:function(){var e=this,t=e.params.pagination;if(t.el&&e.pagination.el&&e.pagination.$el&&0!==e.pagination.$el.length){var a=e.pagination.$el;a.removeClass(t.hiddenClass),a.removeClass(t.modifierClass+t.type),e.pagination.bullets&&e.pagination.bullets.removeClass(t.bulletActiveClass),t.clickable&&a.off("click",P(t.bulletClass))}}},te={setTranslate:function(){var e=this;if(e.params.scrollbar.el&&e.scrollbar.el){var t=e.scrollbar,a=e.rtlTranslate,i=e.progress,s=t.dragSize,r=t.trackSize,n=t.$dragEl,l=t.$el,o=e.params.scrollbar,d=s,p=(r-s)*i;a?(p=-p)>0?(d=s-p,p=0):-p+s>r&&(d=r+p):p<0?(d=s+p,p=0):p+s>r&&(d=r-p),e.isHorizontal()?(n.transform("translate3d("+p+"px, 0, 0)"),n[0].style.width=d+"px"):(n.transform("translate3d(0px, "+p+"px, 0)"),n[0].style.height=d+"px"),o.hide&&(clearTimeout(e.scrollbar.timeout),l[0].style.opacity=1,e.scrollbar.timeout=setTimeout((function(){l[0].style.opacity=0,l.transition(400)}),1e3))}},setTransition:function(e){var t=this;t.params.scrollbar.el&&t.scrollbar.el&&t.scrollbar.$dragEl.transition(e)},updateSize:function(){var e=this;if(e.params.scrollbar.el&&e.scrollbar.el){var t=e.scrollbar,a=t.$dragEl,i=t.$el;a[0].style.width="",a[0].style.height="";var s,r=e.isHorizontal()?i[0].offsetWidth:i[0].offsetHeight,n=e.size/e.virtualSize,l=n*(r/e.size);s="auto"===e.params.scrollbar.dragSize?r*n:parseInt(e.params.scrollbar.dragSize,10),e.isHorizontal()?a[0].style.width=s+"px":a[0].style.height=s+"px",i[0].style.display=n>=1?"none":"",e.params.scrollbar.hide&&(i[0].style.opacity=0),M(t,{trackSize:r,divider:n,moveDivider:l,dragSize:s}),e.params.watchOverflow&&e.enabled&&t.$el[e.isLocked?"addClass":"removeClass"](e.params.scrollbar.lockClass)}},getPointerPosition:function(e){return this.isHorizontal()?"touchstart"===e.type||"touchmove"===e.type?e.targetTouches[0].clientX:e.clientX:"touchstart"===e.type||"touchmove"===e.type?e.targetTouches[0].clientY:e.clientY},setDragPosition:function(e){var t,a=this,i=a.scrollbar,s=a.rtlTranslate,r=i.$el,n=i.dragSize,l=i.trackSize,o=i.dragStartPos;t=(i.getPointerPosition(e)-r.offset()[a.isHorizontal()?"left":"top"]-(null!==o?o:n/2))/(l-n),t=Math.max(Math.min(t,1),0),s&&(t=1-t);var d=a.minTranslate()+(a.maxTranslate()-a.minTranslate())*t;a.updateProgress(d),a.setTranslate(d),a.updateActiveIndex(),a.updateSlidesClasses()},onDragStart:function(e){var t=this,a=t.params.scrollbar,i=t.scrollbar,s=t.$wrapperEl,r=i.$el,n=i.$dragEl;t.scrollbar.isTouched=!0,t.scrollbar.dragStartPos=e.target===n[0]||e.target===n?i.getPointerPosition(e)-e.target.getBoundingClientRect()[t.isHorizontal()?"left":"top"]:null,e.preventDefault(),e.stopPropagation(),s.transition(100),n.transition(100),i.setDragPosition(e),clearTimeout(t.scrollbar.dragTimeout),r.transition(0),a.hide&&r.css("opacity",1),t.params.cssMode&&t.$wrapperEl.css("scroll-snap-type","none"),t.emit("scrollbarDragStart",e)},onDragMove:function(e){var t=this,a=t.scrollbar,i=t.$wrapperEl,s=a.$el,r=a.$dragEl;t.scrollbar.isTouched&&(e.preventDefault?e.preventDefault():e.returnValue=!1,a.setDragPosition(e),i.transition(0),s.transition(0),r.transition(0),t.emit("scrollbarDragMove",e))},onDragEnd:function(e){var t=this,a=t.params.scrollbar,i=t.scrollbar,s=t.$wrapperEl,r=i.$el;t.scrollbar.isTouched&&(t.scrollbar.isTouched=!1,t.params.cssMode&&(t.$wrapperEl.css("scroll-snap-type",""),s.transition("")),a.hide&&(clearTimeout(t.scrollbar.dragTimeout),t.scrollbar.dragTimeout=E((function(){r.css("opacity",0),r.transition(400)}),1e3)),t.emit("scrollbarDragEnd",e),a.snapOnRelease&&t.slideToClosest())},enableDraggable:function(){var e=this;if(e.params.scrollbar.el){var t=r(),a=e.scrollbar,i=e.touchEventsTouch,s=e.touchEventsDesktop,n=e.params,l=e.support,o=a.$el[0],d=!(!l.passiveListener||!n.passiveListeners)&&{passive:!1,capture:!1},p=!(!l.passiveListener||!n.passiveListeners)&&{passive:!0,capture:!1};o&&(l.touch?(o.addEventListener(i.start,e.scrollbar.onDragStart,d),o.addEventListener(i.move,e.scrollbar.onDragMove,d),o.addEventListener(i.end,e.scrollbar.onDragEnd,p)):(o.addEventListener(s.start,e.scrollbar.onDragStart,d),t.addEventListener(s.move,e.scrollbar.onDragMove,d),t.addEventListener(s.end,e.scrollbar.onDragEnd,p)))}},disableDraggable:function(){var e=this;if(e.params.scrollbar.el){var t=r(),a=e.scrollbar,i=e.touchEventsTouch,s=e.touchEventsDesktop,n=e.params,l=e.support,o=a.$el[0],d=!(!l.passiveListener||!n.passiveListeners)&&{passive:!1,capture:!1},p=!(!l.passiveListener||!n.passiveListeners)&&{passive:!0,capture:!1};o&&(l.touch?(o.removeEventListener(i.start,e.scrollbar.onDragStart,d),o.removeEventListener(i.move,e.scrollbar.onDragMove,d),o.removeEventListener(i.end,e.scrollbar.onDragEnd,p)):(o.removeEventListener(s.start,e.scrollbar.onDragStart,d),t.removeEventListener(s.move,e.scrollbar.onDragMove,d),t.removeEventListener(s.end,e.scrollbar.onDragEnd,p)))}},init:function(){var e=this,t=e.scrollbar,a=e.$el;e.params.scrollbar=k(a,e.params.scrollbar,e.params.createElements,{el:"swiper-scrollbar"});var i=e.params.scrollbar;if(i.el){var s=m(i.el);e.params.uniqueNavElements&&"string"==typeof i.el&&s.length>1&&1===a.find(i.el).length&&(s=a.find(i.el));var r=s.find("."+e.params.scrollbar.dragClass);0===r.length&&(r=m('<div class="'+e.params.scrollbar.dragClass+'"></div>'),s.append(r)),M(t,{$el:s,el:s[0],$dragEl:r,dragEl:r[0]}),i.draggable&&t.enableDraggable(),s&&s[e.enabled?"removeClass":"addClass"](e.params.scrollbar.lockClass)}},destroy:function(){this.scrollbar.disableDraggable()}},ae={setTransform:function(e,t){var a=this.rtl,i=m(e),s=a?-1:1,r=i.attr("data-swiper-parallax")||"0",n=i.attr("data-swiper-parallax-x"),l=i.attr("data-swiper-parallax-y"),o=i.attr("data-swiper-parallax-scale"),d=i.attr("data-swiper-parallax-opacity");if(n||l?(n=n||"0",l=l||"0"):this.isHorizontal()?(n=r,l="0"):(l=r,n="0"),n=n.indexOf("%")>=0?parseInt(n,10)*t*s+"%":n*t*s+"px",l=l.indexOf("%")>=0?parseInt(l,10)*t+"%":l*t+"px",null!=d){var p=d-(d-1)*(1-Math.abs(t));i[0].style.opacity=p}if(null==o)i.transform("translate3d("+n+", "+l+", 0px)");else{var u=o-(o-1)*(1-Math.abs(t));i.transform("translate3d("+n+", "+l+", 0px) scale("+u+")")}},setTranslate:function(){var e=this,t=e.$el,a=e.slides,i=e.progress,s=e.snapGrid;t.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((function(t){e.parallax.setTransform(t,i)})),a.each((function(t,a){var r=t.progress;e.params.slidesPerGroup>1&&"auto"!==e.params.slidesPerView&&(r+=Math.ceil(a/2)-i*(s.length-1)),r=Math.min(Math.max(r,-1),1),m(t).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((function(t){e.parallax.setTransform(t,r)}))}))},setTransition:function(e){void 0===e&&(e=this.params.speed);this.$el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((function(t){var a=m(t),i=parseInt(a.attr("data-swiper-parallax-duration"),10)||e;0===e&&(i=0),a.transition(i)}))}},ie={getDistanceBetweenTouches:function(e){if(e.targetTouches.length<2)return 1;var t=e.targetTouches[0].pageX,a=e.targetTouches[0].pageY,i=e.targetTouches[1].pageX,s=e.targetTouches[1].pageY;return Math.sqrt(Math.pow(i-t,2)+Math.pow(s-a,2))},onGestureStart:function(e){var t=this,a=t.support,i=t.params.zoom,s=t.zoom,r=s.gesture;if(s.fakeGestureTouched=!1,s.fakeGestureMoved=!1,!a.gestures){if("touchstart"!==e.type||"touchstart"===e.type&&e.targetTouches.length<2)return;s.fakeGestureTouched=!0,r.scaleStart=ie.getDistanceBetweenTouches(e)}r.$slideEl&&r.$slideEl.length||(r.$slideEl=m(e.target).closest("."+t.params.slideClass),0===r.$slideEl.length&&(r.$slideEl=t.slides.eq(t.activeIndex)),r.$imageEl=r.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"),r.$imageWrapEl=r.$imageEl.parent("."+i.containerClass),r.maxRatio=r.$imageWrapEl.attr("data-swiper-zoom")||i.maxRatio,0!==r.$imageWrapEl.length)?(r.$imageEl&&r.$imageEl.transition(0),t.zoom.isScaling=!0):r.$imageEl=void 0},onGestureChange:function(e){var t=this,a=t.support,i=t.params.zoom,s=t.zoom,r=s.gesture;if(!a.gestures){if("touchmove"!==e.type||"touchmove"===e.type&&e.targetTouches.length<2)return;s.fakeGestureMoved=!0,r.scaleMove=ie.getDistanceBetweenTouches(e)}r.$imageEl&&0!==r.$imageEl.length?(a.gestures?s.scale=e.scale*s.currentScale:s.scale=r.scaleMove/r.scaleStart*s.currentScale,s.scale>r.maxRatio&&(s.scale=r.maxRatio-1+Math.pow(s.scale-r.maxRatio+1,.5)),s.scale<i.minRatio&&(s.scale=i.minRatio+1-Math.pow(i.minRatio-s.scale+1,.5)),r.$imageEl.transform("translate3d(0,0,0) scale("+s.scale+")")):"gesturechange"===e.type&&s.onGestureStart(e)},onGestureEnd:function(e){var t=this,a=t.device,i=t.support,s=t.params.zoom,r=t.zoom,n=r.gesture;if(!i.gestures){if(!r.fakeGestureTouched||!r.fakeGestureMoved)return;if("touchend"!==e.type||"touchend"===e.type&&e.changedTouches.length<2&&!a.android)return;r.fakeGestureTouched=!1,r.fakeGestureMoved=!1}n.$imageEl&&0!==n.$imageEl.length&&(r.scale=Math.max(Math.min(r.scale,n.maxRatio),s.minRatio),n.$imageEl.transition(t.params.speed).transform("translate3d(0,0,0) scale("+r.scale+")"),r.currentScale=r.scale,r.isScaling=!1,1===r.scale&&(n.$slideEl=void 0))},onTouchStart:function(e){var t=this.device,a=this.zoom,i=a.gesture,s=a.image;i.$imageEl&&0!==i.$imageEl.length&&(s.isTouched||(t.android&&e.cancelable&&e.preventDefault(),s.isTouched=!0,s.touchesStart.x="touchstart"===e.type?e.targetTouches[0].pageX:e.pageX,s.touchesStart.y="touchstart"===e.type?e.targetTouches[0].pageY:e.pageY))},onTouchMove:function(e){var t=this,a=t.zoom,i=a.gesture,s=a.image,r=a.velocity;if(i.$imageEl&&0!==i.$imageEl.length&&(t.allowClick=!1,s.isTouched&&i.$slideEl)){s.isMoved||(s.width=i.$imageEl[0].offsetWidth,s.height=i.$imageEl[0].offsetHeight,s.startX=T(i.$imageWrapEl[0],"x")||0,s.startY=T(i.$imageWrapEl[0],"y")||0,i.slideWidth=i.$slideEl[0].offsetWidth,i.slideHeight=i.$slideEl[0].offsetHeight,i.$imageWrapEl.transition(0));var n=s.width*a.scale,l=s.height*a.scale;if(!(n<i.slideWidth&&l<i.slideHeight)){if(s.minX=Math.min(i.slideWidth/2-n/2,0),s.maxX=-s.minX,s.minY=Math.min(i.slideHeight/2-l/2,0),s.maxY=-s.minY,s.touchesCurrent.x="touchmove"===e.type?e.targetTouches[0].pageX:e.pageX,s.touchesCurrent.y="touchmove"===e.type?e.targetTouches[0].pageY:e.pageY,!s.isMoved&&!a.isScaling){if(t.isHorizontal()&&(Math.floor(s.minX)===Math.floor(s.startX)&&s.touchesCurrent.x<s.touchesStart.x||Math.floor(s.maxX)===Math.floor(s.startX)&&s.touchesCurrent.x>s.touchesStart.x))return void(s.isTouched=!1);if(!t.isHorizontal()&&(Math.floor(s.minY)===Math.floor(s.startY)&&s.touchesCurrent.y<s.touchesStart.y||Math.floor(s.maxY)===Math.floor(s.startY)&&s.touchesCurrent.y>s.touchesStart.y))return void(s.isTouched=!1)}e.cancelable&&e.preventDefault(),e.stopPropagation(),s.isMoved=!0,s.currentX=s.touchesCurrent.x-s.touchesStart.x+s.startX,s.currentY=s.touchesCurrent.y-s.touchesStart.y+s.startY,s.currentX<s.minX&&(s.currentX=s.minX+1-Math.pow(s.minX-s.currentX+1,.8)),s.currentX>s.maxX&&(s.currentX=s.maxX-1+Math.pow(s.currentX-s.maxX+1,.8)),s.currentY<s.minY&&(s.currentY=s.minY+1-Math.pow(s.minY-s.currentY+1,.8)),s.currentY>s.maxY&&(s.currentY=s.maxY-1+Math.pow(s.currentY-s.maxY+1,.8)),r.prevPositionX||(r.prevPositionX=s.touchesCurrent.x),r.prevPositionY||(r.prevPositionY=s.touchesCurrent.y),r.prevTime||(r.prevTime=Date.now()),r.x=(s.touchesCurrent.x-r.prevPositionX)/(Date.now()-r.prevTime)/2,r.y=(s.touchesCurrent.y-r.prevPositionY)/(Date.now()-r.prevTime)/2,Math.abs(s.touchesCurrent.x-r.prevPositionX)<2&&(r.x=0),Math.abs(s.touchesCurrent.y-r.prevPositionY)<2&&(r.y=0),r.prevPositionX=s.touchesCurrent.x,r.prevPositionY=s.touchesCurrent.y,r.prevTime=Date.now(),i.$imageWrapEl.transform("translate3d("+s.currentX+"px, "+s.currentY+"px,0)")}}},onTouchEnd:function(){var e=this.zoom,t=e.gesture,a=e.image,i=e.velocity;if(t.$imageEl&&0!==t.$imageEl.length){if(!a.isTouched||!a.isMoved)return a.isTouched=!1,void(a.isMoved=!1);a.isTouched=!1,a.isMoved=!1;var s=300,r=300,n=i.x*s,l=a.currentX+n,o=i.y*r,d=a.currentY+o;0!==i.x&&(s=Math.abs((l-a.currentX)/i.x)),0!==i.y&&(r=Math.abs((d-a.currentY)/i.y));var p=Math.max(s,r);a.currentX=l,a.currentY=d;var u=a.width*e.scale,c=a.height*e.scale;a.minX=Math.min(t.slideWidth/2-u/2,0),a.maxX=-a.minX,a.minY=Math.min(t.slideHeight/2-c/2,0),a.maxY=-a.minY,a.currentX=Math.max(Math.min(a.currentX,a.maxX),a.minX),a.currentY=Math.max(Math.min(a.currentY,a.maxY),a.minY),t.$imageWrapEl.transition(p).transform("translate3d("+a.currentX+"px, "+a.currentY+"px,0)")}},onTransitionEnd:function(){var e=this,t=e.zoom,a=t.gesture;a.$slideEl&&e.previousIndex!==e.activeIndex&&(a.$imageEl&&a.$imageEl.transform("translate3d(0,0,0) scale(1)"),a.$imageWrapEl&&a.$imageWrapEl.transform("translate3d(0,0,0)"),t.scale=1,t.currentScale=1,a.$slideEl=void 0,a.$imageEl=void 0,a.$imageWrapEl=void 0)},toggle:function(e){var t=this.zoom;t.scale&&1!==t.scale?t.out():t.in(e)},in:function(e){var t,a,i,s,r,n,o,d,p,u,c,h,v,f,g,b,w=this,y=l(),E=w.zoom,x=w.params.zoom,T=E.gesture,C=E.image;(T.$slideEl||(e&&e.target&&(T.$slideEl=m(e.target).closest("."+w.params.slideClass)),T.$slideEl||(w.params.virtual&&w.params.virtual.enabled&&w.virtual?T.$slideEl=w.$wrapperEl.children("."+w.params.slideActiveClass):T.$slideEl=w.slides.eq(w.activeIndex)),T.$imageEl=T.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"),T.$imageWrapEl=T.$imageEl.parent("."+x.containerClass)),T.$imageEl&&0!==T.$imageEl.length&&T.$imageWrapEl&&0!==T.$imageWrapEl.length)&&(T.$slideEl.addClass(""+x.zoomedSlideClass),void 0===C.touchesStart.x&&e?(t="touchend"===e.type?e.changedTouches[0].pageX:e.pageX,a="touchend"===e.type?e.changedTouches[0].pageY:e.pageY):(t=C.touchesStart.x,a=C.touchesStart.y),E.scale=T.$imageWrapEl.attr("data-swiper-zoom")||x.maxRatio,E.currentScale=T.$imageWrapEl.attr("data-swiper-zoom")||x.maxRatio,e?(g=T.$slideEl[0].offsetWidth,b=T.$slideEl[0].offsetHeight,i=T.$slideEl.offset().left+y.scrollX+g/2-t,s=T.$slideEl.offset().top+y.scrollY+b/2-a,o=T.$imageEl[0].offsetWidth,d=T.$imageEl[0].offsetHeight,p=o*E.scale,u=d*E.scale,v=-(c=Math.min(g/2-p/2,0)),f=-(h=Math.min(b/2-u/2,0)),(r=i*E.scale)<c&&(r=c),r>v&&(r=v),(n=s*E.scale)<h&&(n=h),n>f&&(n=f)):(r=0,n=0),T.$imageWrapEl.transition(300).transform("translate3d("+r+"px, "+n+"px,0)"),T.$imageEl.transition(300).transform("translate3d(0,0,0) scale("+E.scale+")"))},out:function(){var e=this,t=e.zoom,a=e.params.zoom,i=t.gesture;i.$slideEl||(e.params.virtual&&e.params.virtual.enabled&&e.virtual?i.$slideEl=e.$wrapperEl.children("."+e.params.slideActiveClass):i.$slideEl=e.slides.eq(e.activeIndex),i.$imageEl=i.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"),i.$imageWrapEl=i.$imageEl.parent("."+a.containerClass)),i.$imageEl&&0!==i.$imageEl.length&&i.$imageWrapEl&&0!==i.$imageWrapEl.length&&(t.scale=1,t.currentScale=1,i.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"),i.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"),i.$slideEl.removeClass(""+a.zoomedSlideClass),i.$slideEl=void 0)},toggleGestures:function(e){var t=this,a=t.zoom,i=a.slideSelector,s=a.passiveListener;t.$wrapperEl[e]("gesturestart",i,a.onGestureStart,s),t.$wrapperEl[e]("gesturechange",i,a.onGestureChange,s),t.$wrapperEl[e]("gestureend",i,a.onGestureEnd,s)},enableGestures:function(){this.zoom.gesturesEnabled||(this.zoom.gesturesEnabled=!0,this.zoom.toggleGestures("on"))},disableGestures:function(){this.zoom.gesturesEnabled&&(this.zoom.gesturesEnabled=!1,this.zoom.toggleGestures("off"))},enable:function(){var e=this,t=e.support,a=e.zoom;if(!a.enabled){a.enabled=!0;var i=!("touchstart"!==e.touchEvents.start||!t.passiveListener||!e.params.passiveListeners)&&{passive:!0,capture:!1},s=!t.passiveListener||{passive:!1,capture:!0},r="."+e.params.slideClass;e.zoom.passiveListener=i,e.zoom.slideSelector=r,t.gestures?(e.$wrapperEl.on(e.touchEvents.start,e.zoom.enableGestures,i),e.$wrapperEl.on(e.touchEvents.end,e.zoom.disableGestures,i)):"touchstart"===e.touchEvents.start&&(e.$wrapperEl.on(e.touchEvents.start,r,a.onGestureStart,i),e.$wrapperEl.on(e.touchEvents.move,r,a.onGestureChange,s),e.$wrapperEl.on(e.touchEvents.end,r,a.onGestureEnd,i),e.touchEvents.cancel&&e.$wrapperEl.on(e.touchEvents.cancel,r,a.onGestureEnd,i)),e.$wrapperEl.on(e.touchEvents.move,"."+e.params.zoom.containerClass,a.onTouchMove,s)}},disable:function(){var e=this,t=e.zoom;if(t.enabled){var a=e.support;e.zoom.enabled=!1;var i=!("touchstart"!==e.touchEvents.start||!a.passiveListener||!e.params.passiveListeners)&&{passive:!0,capture:!1},s=!a.passiveListener||{passive:!1,capture:!0},r="."+e.params.slideClass;a.gestures?(e.$wrapperEl.off(e.touchEvents.start,e.zoom.enableGestures,i),e.$wrapperEl.off(e.touchEvents.end,e.zoom.disableGestures,i)):"touchstart"===e.touchEvents.start&&(e.$wrapperEl.off(e.touchEvents.start,r,t.onGestureStart,i),e.$wrapperEl.off(e.touchEvents.move,r,t.onGestureChange,s),e.$wrapperEl.off(e.touchEvents.end,r,t.onGestureEnd,i),e.touchEvents.cancel&&e.$wrapperEl.off(e.touchEvents.cancel,r,t.onGestureEnd,i)),e.$wrapperEl.off(e.touchEvents.move,"."+e.params.zoom.containerClass,t.onTouchMove,s)}}},se={loadInSlide:function(e,t){void 0===t&&(t=!0);var a=this,i=a.params.lazy;if(void 0!==e&&0!==a.slides.length){var s=a.virtual&&a.params.virtual.enabled?a.$wrapperEl.children("."+a.params.slideClass+'[data-swiper-slide-index="'+e+'"]'):a.slides.eq(e),r=s.find("."+i.elementClass+":not(."+i.loadedClass+"):not(."+i.loadingClass+")");!s.hasClass(i.elementClass)||s.hasClass(i.loadedClass)||s.hasClass(i.loadingClass)||r.push(s[0]),0!==r.length&&r.each((function(e){var r=m(e);r.addClass(i.loadingClass);var n=r.attr("data-background"),l=r.attr("data-src"),o=r.attr("data-srcset"),d=r.attr("data-sizes"),p=r.parent("picture");a.loadImage(r[0],l||n,o,d,!1,(function(){if(null!=a&&a&&(!a||a.params)&&!a.destroyed){if(n?(r.css("background-image",'url("'+n+'")'),r.removeAttr("data-background")):(o&&(r.attr("srcset",o),r.removeAttr("data-srcset")),d&&(r.attr("sizes",d),r.removeAttr("data-sizes")),p.length&&p.children("source").each((function(e){var t=m(e);t.attr("data-srcset")&&(t.attr("srcset",t.attr("data-srcset")),t.removeAttr("data-srcset"))})),l&&(r.attr("src",l),r.removeAttr("data-src"))),r.addClass(i.loadedClass).removeClass(i.loadingClass),s.find("."+i.preloaderClass).remove(),a.params.loop&&t){var e=s.attr("data-swiper-slide-index");if(s.hasClass(a.params.slideDuplicateClass)){var u=a.$wrapperEl.children('[data-swiper-slide-index="'+e+'"]:not(.'+a.params.slideDuplicateClass+")");a.lazy.loadInSlide(u.index(),!1)}else{var c=a.$wrapperEl.children("."+a.params.slideDuplicateClass+'[data-swiper-slide-index="'+e+'"]');a.lazy.loadInSlide(c.index(),!1)}}a.emit("lazyImageReady",s[0],r[0]),a.params.autoHeight&&a.updateAutoHeight()}})),a.emit("lazyImageLoad",s[0],r[0])}))}},load:function(){var e=this,t=e.$wrapperEl,a=e.params,i=e.slides,s=e.activeIndex,r=e.virtual&&a.virtual.enabled,n=a.lazy,l=a.slidesPerView;function o(e){if(r){if(t.children("."+a.slideClass+'[data-swiper-slide-index="'+e+'"]').length)return!0}else if(i[e])return!0;return!1}function d(e){return r?m(e).attr("data-swiper-slide-index"):m(e).index()}if("auto"===l&&(l=0),e.lazy.initialImageLoaded||(e.lazy.initialImageLoaded=!0),e.params.watchSlidesVisibility)t.children("."+a.slideVisibleClass).each((function(t){var a=r?m(t).attr("data-swiper-slide-index"):m(t).index();e.lazy.loadInSlide(a)}));else if(l>1)for(var p=s;p<s+l;p+=1)o(p)&&e.lazy.loadInSlide(p);else e.lazy.loadInSlide(s);if(n.loadPrevNext)if(l>1||n.loadPrevNextAmount&&n.loadPrevNextAmount>1){for(var u=n.loadPrevNextAmount,c=l,h=Math.min(s+c+Math.max(u,c),i.length),v=Math.max(s-Math.max(c,u),0),f=s+l;f<h;f+=1)o(f)&&e.lazy.loadInSlide(f);for(var g=v;g<s;g+=1)o(g)&&e.lazy.loadInSlide(g)}else{var b=t.children("."+a.slideNextClass);b.length>0&&e.lazy.loadInSlide(d(b));var w=t.children("."+a.slidePrevClass);w.length>0&&e.lazy.loadInSlide(d(w))}},checkInViewOnLoad:function(){var e=l(),t=this;if(t&&!t.destroyed){var a=t.params.lazy.scrollingElement?m(t.params.lazy.scrollingElement):m(e),i=a[0]===e,s=i?e.innerWidth:a[0].offsetWidth,r=i?e.innerHeight:a[0].offsetHeight,n=t.$el.offset(),o=!1;t.rtlTranslate&&(n.left-=t.$el[0].scrollLeft);for(var d=[[n.left,n.top],[n.left+t.width,n.top],[n.left,n.top+t.height],[n.left+t.width,n.top+t.height]],p=0;p<d.length;p+=1){var u=d[p];if(u[0]>=0&&u[0]<=s&&u[1]>=0&&u[1]<=r){if(0===u[0]&&0===u[1])continue;o=!0}}var c=!("touchstart"!==t.touchEvents.start||!t.support.passiveListener||!t.params.passiveListeners)&&{passive:!0,capture:!1};o?(t.lazy.load(),a.off("scroll",t.lazy.checkInViewOnLoad,c)):t.lazy.scrollHandlerAttached||(t.lazy.scrollHandlerAttached=!0,a.on("scroll",t.lazy.checkInViewOnLoad,c))}}},re={LinearSpline:function(e,t){var a,i,s,r,n,l=function(e,t){for(i=-1,a=e.length;a-i>1;)e[s=a+i>>1]<=t?i=s:a=s;return a};return this.x=e,this.y=t,this.lastIndex=e.length-1,this.interpolate=function(e){return e?(n=l(this.x,e),r=n-1,(e-this.x[r])*(this.y[n]-this.y[r])/(this.x[n]-this.x[r])+this.y[r]):0},this},getInterpolateFunction:function(e){var t=this;t.controller.spline||(t.controller.spline=t.params.loop?new re.LinearSpline(t.slidesGrid,e.slidesGrid):new re.LinearSpline(t.snapGrid,e.snapGrid))},setTranslate:function(e,t){var a,i,s=this,r=s.controller.control,n=s.constructor;function l(e){var t=s.rtlTranslate?-s.translate:s.translate;"slide"===s.params.controller.by&&(s.controller.getInterpolateFunction(e),i=-s.controller.spline.interpolate(-t)),i&&"container"!==s.params.controller.by||(a=(e.maxTranslate()-e.minTranslate())/(s.maxTranslate()-s.minTranslate()),i=(t-s.minTranslate())*a+e.minTranslate()),s.params.controller.inverse&&(i=e.maxTranslate()-i),e.updateProgress(i),e.setTranslate(i,s),e.updateActiveIndex(),e.updateSlidesClasses()}if(Array.isArray(r))for(var o=0;o<r.length;o+=1)r[o]!==t&&r[o]instanceof n&&l(r[o]);else r instanceof n&&t!==r&&l(r)},setTransition:function(e,t){var a,i=this,s=i.constructor,r=i.controller.control;function n(t){t.setTransition(e,i),0!==e&&(t.transitionStart(),t.params.autoHeight&&E((function(){t.updateAutoHeight()})),t.$wrapperEl.transitionEnd((function(){r&&(t.params.loop&&"slide"===i.params.controller.by&&t.loopFix(),t.transitionEnd())})))}if(Array.isArray(r))for(a=0;a<r.length;a+=1)r[a]!==t&&r[a]instanceof s&&n(r[a]);else r instanceof s&&t!==r&&n(r)}},ne={getRandomNumber:function(e){void 0===e&&(e=16);return"x".repeat(e).replace(/x/g,(function(){return Math.round(16*Math.random()).toString(16)}))},makeElFocusable:function(e){return e.attr("tabIndex","0"),e},makeElNotFocusable:function(e){return e.attr("tabIndex","-1"),e},addElRole:function(e,t){return e.attr("role",t),e},addElRoleDescription:function(e,t){return e.attr("aria-roledescription",t),e},addElControls:function(e,t){return e.attr("aria-controls",t),e},addElLabel:function(e,t){return e.attr("aria-label",t),e},addElId:function(e,t){return e.attr("id",t),e},addElLive:function(e,t){return e.attr("aria-live",t),e},disableEl:function(e){return e.attr("aria-disabled",!0),e},enableEl:function(e){return e.attr("aria-disabled",!1),e},onEnterOrSpaceKey:function(e){if(13===e.keyCode||32===e.keyCode){var t=this,a=t.params.a11y,i=m(e.target);t.navigation&&t.navigation.$nextEl&&i.is(t.navigation.$nextEl)&&(t.isEnd&&!t.params.loop||t.slideNext(),t.isEnd?t.a11y.notify(a.lastSlideMessage):t.a11y.notify(a.nextSlideMessage)),t.navigation&&t.navigation.$prevEl&&i.is(t.navigation.$prevEl)&&(t.isBeginning&&!t.params.loop||t.slidePrev(),t.isBeginning?t.a11y.notify(a.firstSlideMessage):t.a11y.notify(a.prevSlideMessage)),t.pagination&&i.is(P(t.params.pagination.bulletClass))&&i[0].click()}},notify:function(e){var t=this.a11y.liveRegion;0!==t.length&&(t.html(""),t.html(e))},updateNavigation:function(){var e=this;if(!e.params.loop&&e.navigation){var t=e.navigation,a=t.$nextEl,i=t.$prevEl;i&&i.length>0&&(e.isBeginning?(e.a11y.disableEl(i),e.a11y.makeElNotFocusable(i)):(e.a11y.enableEl(i),e.a11y.makeElFocusable(i))),a&&a.length>0&&(e.isEnd?(e.a11y.disableEl(a),e.a11y.makeElNotFocusable(a)):(e.a11y.enableEl(a),e.a11y.makeElFocusable(a)))}},updatePagination:function(){var e=this,t=e.params.a11y;e.pagination&&e.params.pagination.clickable&&e.pagination.bullets&&e.pagination.bullets.length&&e.pagination.bullets.each((function(a){var i=m(a);e.a11y.makeElFocusable(i),e.params.pagination.renderBullet||(e.a11y.addElRole(i,"button"),e.a11y.addElLabel(i,t.paginationBulletMessage.replace(/\{\{index\}\}/,i.index()+1)))}))},init:function(){var e=this,t=e.params.a11y;e.$el.append(e.a11y.liveRegion);var a=e.$el;t.containerRoleDescriptionMessage&&e.a11y.addElRoleDescription(a,t.containerRoleDescriptionMessage),t.containerMessage&&e.a11y.addElLabel(a,t.containerMessage);var i=e.$wrapperEl,s=i.attr("id")||"swiper-wrapper-"+e.a11y.getRandomNumber(16),r=e.params.autoplay&&e.params.autoplay.enabled?"off":"polite";e.a11y.addElId(i,s),e.a11y.addElLive(i,r),t.itemRoleDescriptionMessage&&e.a11y.addElRoleDescription(m(e.slides),t.itemRoleDescriptionMessage),e.a11y.addElRole(m(e.slides),t.slideRole);var n,l,o=e.params.loop?e.slides.filter((function(t){return!t.classList.contains(e.params.slideDuplicateClass)})).length:e.slides.length;e.slides.each((function(a,i){var s=m(a),r=e.params.loop?parseInt(s.attr("data-swiper-slide-index"),10):i,n=t.slideLabelMessage.replace(/\{\{index\}\}/,r+1).replace(/\{\{slidesLength\}\}/,o);e.a11y.addElLabel(s,n)})),e.navigation&&e.navigation.$nextEl&&(n=e.navigation.$nextEl),e.navigation&&e.navigation.$prevEl&&(l=e.navigation.$prevEl),n&&n.length&&(e.a11y.makeElFocusable(n),"BUTTON"!==n[0].tagName&&(e.a11y.addElRole(n,"button"),n.on("keydown",e.a11y.onEnterOrSpaceKey)),e.a11y.addElLabel(n,t.nextSlideMessage),e.a11y.addElControls(n,s)),l&&l.length&&(e.a11y.makeElFocusable(l),"BUTTON"!==l[0].tagName&&(e.a11y.addElRole(l,"button"),l.on("keydown",e.a11y.onEnterOrSpaceKey)),e.a11y.addElLabel(l,t.prevSlideMessage),e.a11y.addElControls(l,s)),e.pagination&&e.params.pagination.clickable&&e.pagination.bullets&&e.pagination.bullets.length&&e.pagination.$el.on("keydown",P(e.params.pagination.bulletClass),e.a11y.onEnterOrSpaceKey)},destroy:function(){var e,t,a=this;a.a11y.liveRegion&&a.a11y.liveRegion.length>0&&a.a11y.liveRegion.remove(),a.navigation&&a.navigation.$nextEl&&(e=a.navigation.$nextEl),a.navigation&&a.navigation.$prevEl&&(t=a.navigation.$prevEl),e&&e.off("keydown",a.a11y.onEnterOrSpaceKey),t&&t.off("keydown",a.a11y.onEnterOrSpaceKey),a.pagination&&a.params.pagination.clickable&&a.pagination.bullets&&a.pagination.bullets.length&&a.pagination.$el.off("keydown",P(a.params.pagination.bulletClass),a.a11y.onEnterOrSpaceKey)}},le={init:function(){var e=this,t=l();if(e.params.history){if(!t.history||!t.history.pushState)return e.params.history.enabled=!1,void(e.params.hashNavigation.enabled=!0);var a=e.history;a.initialized=!0,a.paths=le.getPathValues(e.params.url),(a.paths.key||a.paths.value)&&(a.scrollToSlide(0,a.paths.value,e.params.runCallbacksOnInit),e.params.history.replaceState||t.addEventListener("popstate",e.history.setHistoryPopState))}},destroy:function(){var e=l();this.params.history.replaceState||e.removeEventListener("popstate",this.history.setHistoryPopState)},setHistoryPopState:function(){var e=this;e.history.paths=le.getPathValues(e.params.url),e.history.scrollToSlide(e.params.speed,e.history.paths.value,!1)},getPathValues:function(e){var t=l(),a=(e?new URL(e):t.location).pathname.slice(1).split("/").filter((function(e){return""!==e})),i=a.length;return{key:a[i-2],value:a[i-1]}},setHistory:function(e,t){var a=this,i=l();if(a.history.initialized&&a.params.history.enabled){var s;s=a.params.url?new URL(a.params.url):i.location;var r=a.slides.eq(t),n=le.slugify(r.attr("data-history"));if(a.params.history.root.length>0){var o=a.params.history.root;"/"===o[o.length-1]&&(o=o.slice(0,o.length-1)),n=o+"/"+e+"/"+n}else s.pathname.includes(e)||(n=e+"/"+n);var d=i.history.state;d&&d.value===n||(a.params.history.replaceState?i.history.replaceState({value:n},null,n):i.history.pushState({value:n},null,n))}},slugify:function(e){return e.toString().replace(/\s+/g,"-").replace(/[^\w-]+/g,"").replace(/--+/g,"-").replace(/^-+/,"").replace(/-+$/,"")},scrollToSlide:function(e,t,a){var i=this;if(t)for(var s=0,r=i.slides.length;s<r;s+=1){var n=i.slides.eq(s);if(le.slugify(n.attr("data-history"))===t&&!n.hasClass(i.params.slideDuplicateClass)){var l=n.index();i.slideTo(l,e,a)}}else i.slideTo(0,e,a)}},oe={onHashChange:function(){var e=this,t=r();e.emit("hashChange");var a=t.location.hash.replace("#","");if(a!==e.slides.eq(e.activeIndex).attr("data-hash")){var i=e.$wrapperEl.children("."+e.params.slideClass+'[data-hash="'+a+'"]').index();if(void 0===i)return;e.slideTo(i)}},setHash:function(){var e=this,t=l(),a=r();if(e.hashNavigation.initialized&&e.params.hashNavigation.enabled)if(e.params.hashNavigation.replaceState&&t.history&&t.history.replaceState)t.history.replaceState(null,null,"#"+e.slides.eq(e.activeIndex).attr("data-hash")||""),e.emit("hashSet");else{var i=e.slides.eq(e.activeIndex),s=i.attr("data-hash")||i.attr("data-history");a.location.hash=s||"",e.emit("hashSet")}},init:function(){var e=this,t=r(),a=l();if(!(!e.params.hashNavigation.enabled||e.params.history&&e.params.history.enabled)){e.hashNavigation.initialized=!0;var i=t.location.hash.replace("#","");if(i)for(var s=0,n=e.slides.length;s<n;s+=1){var o=e.slides.eq(s);if((o.attr("data-hash")||o.attr("data-history"))===i&&!o.hasClass(e.params.slideDuplicateClass)){var d=o.index();e.slideTo(d,0,e.params.runCallbacksOnInit,!0)}}e.params.hashNavigation.watchState&&m(a).on("hashchange",e.hashNavigation.onHashChange)}},destroy:function(){var e=l();this.params.hashNavigation.watchState&&m(e).off("hashchange",this.hashNavigation.onHashChange)}},de={run:function(){var e=this,t=e.slides.eq(e.activeIndex),a=e.params.autoplay.delay;t.attr("data-swiper-autoplay")&&(a=t.attr("data-swiper-autoplay")||e.params.autoplay.delay),clearTimeout(e.autoplay.timeout),e.autoplay.timeout=E((function(){var t;e.params.autoplay.reverseDirection?e.params.loop?(e.loopFix(),t=e.slidePrev(e.params.speed,!0,!0),e.emit("autoplay")):e.isBeginning?e.params.autoplay.stopOnLastSlide?e.autoplay.stop():(t=e.slideTo(e.slides.length-1,e.params.speed,!0,!0),e.emit("autoplay")):(t=e.slidePrev(e.params.speed,!0,!0),e.emit("autoplay")):e.params.loop?(e.loopFix(),t=e.slideNext(e.params.speed,!0,!0),e.emit("autoplay")):e.isEnd?e.params.autoplay.stopOnLastSlide?e.autoplay.stop():(t=e.slideTo(0,e.params.speed,!0,!0),e.emit("autoplay")):(t=e.slideNext(e.params.speed,!0,!0),e.emit("autoplay")),(e.params.cssMode&&e.autoplay.running||!1===t)&&e.autoplay.run()}),a)},start:function(){var e=this;return void 0===e.autoplay.timeout&&(!e.autoplay.running&&(e.autoplay.running=!0,e.emit("autoplayStart"),e.autoplay.run(),!0))},stop:function(){var e=this;return!!e.autoplay.running&&(void 0!==e.autoplay.timeout&&(e.autoplay.timeout&&(clearTimeout(e.autoplay.timeout),e.autoplay.timeout=void 0),e.autoplay.running=!1,e.emit("autoplayStop"),!0))},pause:function(e){var t=this;t.autoplay.running&&(t.autoplay.paused||(t.autoplay.timeout&&clearTimeout(t.autoplay.timeout),t.autoplay.paused=!0,0!==e&&t.params.autoplay.waitForTransition?["transitionend","webkitTransitionEnd"].forEach((function(e){t.$wrapperEl[0].addEventListener(e,t.autoplay.onTransitionEnd)})):(t.autoplay.paused=!1,t.autoplay.run())))},onVisibilityChange:function(){var e=this,t=r();"hidden"===t.visibilityState&&e.autoplay.running&&e.autoplay.pause(),"visible"===t.visibilityState&&e.autoplay.paused&&(e.autoplay.run(),e.autoplay.paused=!1)},onTransitionEnd:function(e){var t=this;t&&!t.destroyed&&t.$wrapperEl&&e.target===t.$wrapperEl[0]&&(["transitionend","webkitTransitionEnd"].forEach((function(e){t.$wrapperEl[0].removeEventListener(e,t.autoplay.onTransitionEnd)})),t.autoplay.paused=!1,t.autoplay.running?t.autoplay.run():t.autoplay.stop())},onMouseEnter:function(){var e=this;e.params.autoplay.disableOnInteraction?e.autoplay.stop():e.autoplay.pause(),["transitionend","webkitTransitionEnd"].forEach((function(t){e.$wrapperEl[0].removeEventListener(t,e.autoplay.onTransitionEnd)}))},onMouseLeave:function(){var e=this;e.params.autoplay.disableOnInteraction||(e.autoplay.paused=!1,e.autoplay.run())},attachMouseEvents:function(){var e=this;e.params.autoplay.pauseOnMouseEnter&&(e.$el.on("mouseenter",e.autoplay.onMouseEnter),e.$el.on("mouseleave",e.autoplay.onMouseLeave))},detachMouseEvents:function(){var e=this;e.$el.off("mouseenter",e.autoplay.onMouseEnter),e.$el.off("mouseleave",e.autoplay.onMouseLeave)}},pe={setTranslate:function(){for(var e=this,t=e.slides,a=0;a<t.length;a+=1){var i=e.slides.eq(a),s=-i[0].swiperSlideOffset;e.params.virtualTranslate||(s-=e.translate);var r=0;e.isHorizontal()||(r=s,s=0);var n=e.params.fadeEffect.crossFade?Math.max(1-Math.abs(i[0].progress),0):1+Math.min(Math.max(i[0].progress,-1),0);i.css({opacity:n}).transform("translate3d("+s+"px, "+r+"px, 0px)")}},setTransition:function(e){var t=this,a=t.slides,i=t.$wrapperEl;if(a.transition(e),t.params.virtualTranslate&&0!==e){var s=!1;a.transitionEnd((function(){if(!s&&t&&!t.destroyed){s=!0,t.animating=!1;for(var e=["webkitTransitionEnd","transitionend"],a=0;a<e.length;a+=1)i.trigger(e[a])}}))}}},ue={setTranslate:function(){var e,t=this,a=t.$el,i=t.$wrapperEl,s=t.slides,r=t.width,n=t.height,l=t.rtlTranslate,o=t.size,d=t.browser,p=t.params.cubeEffect,u=t.isHorizontal(),c=t.virtual&&t.params.virtual.enabled,h=0;p.shadow&&(u?(0===(e=i.find(".swiper-cube-shadow")).length&&(e=m('<div class="swiper-cube-shadow"></div>'),i.append(e)),e.css({height:r+"px"})):0===(e=a.find(".swiper-cube-shadow")).length&&(e=m('<div class="swiper-cube-shadow"></div>'),a.append(e)));for(var v=0;v<s.length;v+=1){var f=s.eq(v),g=v;c&&(g=parseInt(f.attr("data-swiper-slide-index"),10));var b=90*g,w=Math.floor(b/360);l&&(b=-b,w=Math.floor(-b/360));var y=Math.max(Math.min(f[0].progress,1),-1),E=0,x=0,T=0;g%4==0?(E=4*-w*o,T=0):(g-1)%4==0?(E=0,T=4*-w*o):(g-2)%4==0?(E=o+4*w*o,T=o):(g-3)%4==0&&(E=-o,T=3*o+4*o*w),l&&(E=-E),u||(x=E,E=0);var C="rotateX("+(u?0:-b)+"deg) rotateY("+(u?b:0)+"deg) translate3d("+E+"px, "+x+"px, "+T+"px)";if(y<=1&&y>-1&&(h=90*g+90*y,l&&(h=90*-g-90*y)),f.transform(C),p.slideShadows){var S=u?f.find(".swiper-slide-shadow-left"):f.find(".swiper-slide-shadow-top"),M=u?f.find(".swiper-slide-shadow-right"):f.find(".swiper-slide-shadow-bottom");0===S.length&&(S=m('<div class="swiper-slide-shadow-'+(u?"left":"top")+'"></div>'),f.append(S)),0===M.length&&(M=m('<div class="swiper-slide-shadow-'+(u?"right":"bottom")+'"></div>'),f.append(M)),S.length&&(S[0].style.opacity=Math.max(-y,0)),M.length&&(M[0].style.opacity=Math.max(y,0))}}if(i.css({"-webkit-transform-origin":"50% 50% -"+o/2+"px","-moz-transform-origin":"50% 50% -"+o/2+"px","-ms-transform-origin":"50% 50% -"+o/2+"px","transform-origin":"50% 50% -"+o/2+"px"}),p.shadow)if(u)e.transform("translate3d(0px, "+(r/2+p.shadowOffset)+"px, "+-r/2+"px) rotateX(90deg) rotateZ(0deg) scale("+p.shadowScale+")");else{var z=Math.abs(h)-90*Math.floor(Math.abs(h)/90),P=1.5-(Math.sin(2*z*Math.PI/360)/2+Math.cos(2*z*Math.PI/360)/2),k=p.shadowScale,$=p.shadowScale/P,L=p.shadowOffset;e.transform("scale3d("+k+", 1, "+$+") translate3d(0px, "+(n/2+L)+"px, "+-n/2/$+"px) rotateX(-90deg)")}var I=d.isSafari||d.isWebView?-o/2:0;i.transform("translate3d(0px,0,"+I+"px) rotateX("+(t.isHorizontal()?0:h)+"deg) rotateY("+(t.isHorizontal()?-h:0)+"deg)")},setTransition:function(e){var t=this,a=t.$el;t.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e),t.params.cubeEffect.shadow&&!t.isHorizontal()&&a.find(".swiper-cube-shadow").transition(e)}},ce={setTranslate:function(){for(var e=this,t=e.slides,a=e.rtlTranslate,i=0;i<t.length;i+=1){var s=t.eq(i),r=s[0].progress;e.params.flipEffect.limitRotation&&(r=Math.max(Math.min(s[0].progress,1),-1));var n=-180*r,l=0,o=-s[0].swiperSlideOffset,d=0;if(e.isHorizontal()?a&&(n=-n):(d=o,o=0,l=-n,n=0),s[0].style.zIndex=-Math.abs(Math.round(r))+t.length,e.params.flipEffect.slideShadows){var p=e.isHorizontal()?s.find(".swiper-slide-shadow-left"):s.find(".swiper-slide-shadow-top"),u=e.isHorizontal()?s.find(".swiper-slide-shadow-right"):s.find(".swiper-slide-shadow-bottom");0===p.length&&(p=m('<div class="swiper-slide-shadow-'+(e.isHorizontal()?"left":"top")+'"></div>'),s.append(p)),0===u.length&&(u=m('<div class="swiper-slide-shadow-'+(e.isHorizontal()?"right":"bottom")+'"></div>'),s.append(u)),p.length&&(p[0].style.opacity=Math.max(-r,0)),u.length&&(u[0].style.opacity=Math.max(r,0))}s.transform("translate3d("+o+"px, "+d+"px, 0px) rotateX("+l+"deg) rotateY("+n+"deg)")}},setTransition:function(e){var t=this,a=t.slides,i=t.activeIndex,s=t.$wrapperEl;if(a.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e),t.params.virtualTranslate&&0!==e){var r=!1;a.eq(i).transitionEnd((function(){if(!r&&t&&!t.destroyed){r=!0,t.animating=!1;for(var e=["webkitTransitionEnd","transitionend"],a=0;a<e.length;a+=1)s.trigger(e[a])}}))}}},he={setTranslate:function(){for(var e=this,t=e.width,a=e.height,i=e.slides,s=e.slidesSizesGrid,r=e.params.coverflowEffect,n=e.isHorizontal(),l=e.translate,o=n?t/2-l:a/2-l,d=n?r.rotate:-r.rotate,p=r.depth,u=0,c=i.length;u<c;u+=1){var h=i.eq(u),v=s[u],f=(o-h[0].swiperSlideOffset-v/2)/v*r.modifier,g=n?d*f:0,b=n?0:d*f,w=-p*Math.abs(f),y=r.stretch;"string"==typeof y&&-1!==y.indexOf("%")&&(y=parseFloat(r.stretch)/100*v);var E=n?0:y*f,x=n?y*f:0,T=1-(1-r.scale)*Math.abs(f);Math.abs(x)<.001&&(x=0),Math.abs(E)<.001&&(E=0),Math.abs(w)<.001&&(w=0),Math.abs(g)<.001&&(g=0),Math.abs(b)<.001&&(b=0),Math.abs(T)<.001&&(T=0);var C="translate3d("+x+"px,"+E+"px,"+w+"px)  rotateX("+b+"deg) rotateY("+g+"deg) scale("+T+")";if(h.transform(C),h[0].style.zIndex=1-Math.abs(Math.round(f)),r.slideShadows){var S=n?h.find(".swiper-slide-shadow-left"):h.find(".swiper-slide-shadow-top"),M=n?h.find(".swiper-slide-shadow-right"):h.find(".swiper-slide-shadow-bottom");0===S.length&&(S=m('<div class="swiper-slide-shadow-'+(n?"left":"top")+'"></div>'),h.append(S)),0===M.length&&(M=m('<div class="swiper-slide-shadow-'+(n?"right":"bottom")+'"></div>'),h.append(M)),S.length&&(S[0].style.opacity=f>0?f:0),M.length&&(M[0].style.opacity=-f>0?-f:0)}}},setTransition:function(e){this.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e)}},ve={init:function(){var e=this,t=e.params.thumbs;if(e.thumbs.initialized)return!1;e.thumbs.initialized=!0;var a=e.constructor;return t.swiper instanceof a?(e.thumbs.swiper=t.swiper,M(e.thumbs.swiper.originalParams,{watchSlidesProgress:!0,slideToClickedSlide:!1}),M(e.thumbs.swiper.params,{watchSlidesProgress:!0,slideToClickedSlide:!1})):C(t.swiper)&&(e.thumbs.swiper=new a(M({},t.swiper,{watchSlidesVisibility:!0,watchSlidesProgress:!0,slideToClickedSlide:!1})),e.thumbs.swiperCreated=!0),e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass),e.thumbs.swiper.on("tap",e.thumbs.onThumbClick),!0},onThumbClick:function(){var e=this,t=e.thumbs.swiper;if(t){var a=t.clickedIndex,i=t.clickedSlide;if(!(i&&m(i).hasClass(e.params.thumbs.slideThumbActiveClass)||null==a)){var s;if(s=t.params.loop?parseInt(m(t.clickedSlide).attr("data-swiper-slide-index"),10):a,e.params.loop){var r=e.activeIndex;e.slides.eq(r).hasClass(e.params.slideDuplicateClass)&&(e.loopFix(),e._clientLeft=e.$wrapperEl[0].clientLeft,r=e.activeIndex);var n=e.slides.eq(r).prevAll('[data-swiper-slide-index="'+s+'"]').eq(0).index(),l=e.slides.eq(r).nextAll('[data-swiper-slide-index="'+s+'"]').eq(0).index();s=void 0===n?l:void 0===l?n:l-r<r-n?l:n}e.slideTo(s)}}},update:function(e){var t=this,a=t.thumbs.swiper;if(a){var i="auto"===a.params.slidesPerView?a.slidesPerViewDynamic():a.params.slidesPerView,s=t.params.thumbs.autoScrollOffset,r=s&&!a.params.loop;if(t.realIndex!==a.realIndex||r){var n,l,o=a.activeIndex;if(a.params.loop){a.slides.eq(o).hasClass(a.params.slideDuplicateClass)&&(a.loopFix(),a._clientLeft=a.$wrapperEl[0].clientLeft,o=a.activeIndex);var d=a.slides.eq(o).prevAll('[data-swiper-slide-index="'+t.realIndex+'"]').eq(0).index(),p=a.slides.eq(o).nextAll('[data-swiper-slide-index="'+t.realIndex+'"]').eq(0).index();n=void 0===d?p:void 0===p?d:p-o==o-d?a.params.slidesPerGroup>1?p:o:p-o<o-d?p:d,l=t.activeIndex>t.previousIndex?"next":"prev"}else l=(n=t.realIndex)>t.previousIndex?"next":"prev";r&&(n+="next"===l?s:-1*s),a.visibleSlidesIndexes&&a.visibleSlidesIndexes.indexOf(n)<0&&(a.params.centeredSlides?n=n>o?n-Math.floor(i/2)+1:n+Math.floor(i/2)-1:n>o&&a.params.slidesPerGroup,a.slideTo(n,e?0:void 0))}var u=1,c=t.params.thumbs.slideThumbActiveClass;if(t.params.slidesPerView>1&&!t.params.centeredSlides&&(u=t.params.slidesPerView),t.params.thumbs.multipleActiveThumbs||(u=1),u=Math.floor(u),a.slides.removeClass(c),a.params.loop||a.params.virtual&&a.params.virtual.enabled)for(var h=0;h<u;h+=1)a.$wrapperEl.children('[data-swiper-slide-index="'+(t.realIndex+h)+'"]').addClass(c);else for(var v=0;v<u;v+=1)a.slides.eq(t.realIndex+v).addClass(c)}}},fe=[U,Z,{name:"mousewheel",params:{mousewheel:{enabled:!1,releaseOnEdges:!1,invert:!1,forceToAxis:!1,sensitivity:1,eventsTarget:"container",thresholdDelta:null,thresholdTime:null}},create:function(){z(this,{mousewheel:{enabled:!1,lastScrollTime:x(),lastEventBeforeSnap:void 0,recentWheelEvents:[],enable:J.enable,disable:J.disable,handle:J.handle,handleMouseEnter:J.handleMouseEnter,handleMouseLeave:J.handleMouseLeave,animateSlider:J.animateSlider,releaseScroll:J.releaseScroll}})},on:{init:function(e){!e.params.mousewheel.enabled&&e.params.cssMode&&e.mousewheel.disable(),e.params.mousewheel.enabled&&e.mousewheel.enable()},destroy:function(e){e.params.cssMode&&e.mousewheel.enable(),e.mousewheel.enabled&&e.mousewheel.disable()}}},{name:"navigation",params:{navigation:{nextEl:null,prevEl:null,hideOnClick:!1,disabledClass:"swiper-button-disabled",hiddenClass:"swiper-button-hidden",lockClass:"swiper-button-lock"}},create:function(){z(this,{navigation:t({},Q)})},on:{init:function(e){e.navigation.init(),e.navigation.update()},toEdge:function(e){e.navigation.update()},fromEdge:function(e){e.navigation.update()},destroy:function(e){e.navigation.destroy()},"enable disable":function(e){var t=e.navigation,a=t.$nextEl,i=t.$prevEl;a&&a[e.enabled?"removeClass":"addClass"](e.params.navigation.lockClass),i&&i[e.enabled?"removeClass":"addClass"](e.params.navigation.lockClass)},click:function(e,t){var a=e.navigation,i=a.$nextEl,s=a.$prevEl,r=t.target;if(e.params.navigation.hideOnClick&&!m(r).is(s)&&!m(r).is(i)){if(e.pagination&&e.params.pagination&&e.params.pagination.clickable&&(e.pagination.el===r||e.pagination.el.contains(r)))return;var n;i?n=i.hasClass(e.params.navigation.hiddenClass):s&&(n=s.hasClass(e.params.navigation.hiddenClass)),!0===n?e.emit("navigationShow"):e.emit("navigationHide"),i&&i.toggleClass(e.params.navigation.hiddenClass),s&&s.toggleClass(e.params.navigation.hiddenClass)}}}},{name:"pagination",params:{pagination:{el:null,bulletElement:"span",clickable:!1,hideOnClick:!1,renderBullet:null,renderProgressbar:null,renderFraction:null,renderCustom:null,progressbarOpposite:!1,type:"bullets",dynamicBullets:!1,dynamicMainBullets:1,formatFractionCurrent:function(e){return e},formatFractionTotal:function(e){return e},bulletClass:"swiper-pagination-bullet",bulletActiveClass:"swiper-pagination-bullet-active",modifierClass:"swiper-pagination-",currentClass:"swiper-pagination-current",totalClass:"swiper-pagination-total",hiddenClass:"swiper-pagination-hidden",progressbarFillClass:"swiper-pagination-progressbar-fill",progressbarOppositeClass:"swiper-pagination-progressbar-opposite",clickableClass:"swiper-pagination-clickable",lockClass:"swiper-pagination-lock"}},create:function(){z(this,{pagination:t({dynamicBulletIndex:0},ee)})},on:{init:function(e){e.pagination.init(),e.pagination.render(),e.pagination.update()},activeIndexChange:function(e){(e.params.loop||void 0===e.snapIndex)&&e.pagination.update()},snapIndexChange:function(e){e.params.loop||e.pagination.update()},slidesLengthChange:function(e){e.params.loop&&(e.pagination.render(),e.pagination.update())},snapGridLengthChange:function(e){e.params.loop||(e.pagination.render(),e.pagination.update())},destroy:function(e){e.pagination.destroy()},"enable disable":function(e){var t=e.pagination.$el;t&&t[e.enabled?"removeClass":"addClass"](e.params.pagination.lockClass)},click:function(e,t){var a=t.target;if(e.params.pagination.el&&e.params.pagination.hideOnClick&&e.pagination.$el.length>0&&!m(a).hasClass(e.params.pagination.bulletClass)){if(e.navigation&&(e.navigation.nextEl&&a===e.navigation.nextEl||e.navigation.prevEl&&a===e.navigation.prevEl))return;!0===e.pagination.$el.hasClass(e.params.pagination.hiddenClass)?e.emit("paginationShow"):e.emit("paginationHide"),e.pagination.$el.toggleClass(e.params.pagination.hiddenClass)}}}},{name:"scrollbar",params:{scrollbar:{el:null,dragSize:"auto",hide:!1,draggable:!1,snapOnRelease:!0,lockClass:"swiper-scrollbar-lock",dragClass:"swiper-scrollbar-drag"}},create:function(){z(this,{scrollbar:t({isTouched:!1,timeout:null,dragTimeout:null},te)})},on:{init:function(e){e.scrollbar.init(),e.scrollbar.updateSize(),e.scrollbar.setTranslate()},update:function(e){e.scrollbar.updateSize()},resize:function(e){e.scrollbar.updateSize()},observerUpdate:function(e){e.scrollbar.updateSize()},setTranslate:function(e){e.scrollbar.setTranslate()},setTransition:function(e,t){e.scrollbar.setTransition(t)},"enable disable":function(e){var t=e.scrollbar.$el;t&&t[e.enabled?"removeClass":"addClass"](e.params.scrollbar.lockClass)},destroy:function(e){e.scrollbar.destroy()}}},{name:"parallax",params:{parallax:{enabled:!1}},create:function(){z(this,{parallax:t({},ae)})},on:{beforeInit:function(e){e.params.parallax.enabled&&(e.params.watchSlidesProgress=!0,e.originalParams.watchSlidesProgress=!0)},init:function(e){e.params.parallax.enabled&&e.parallax.setTranslate()},setTranslate:function(e){e.params.parallax.enabled&&e.parallax.setTranslate()},setTransition:function(e,t){e.params.parallax.enabled&&e.parallax.setTransition(t)}}},{name:"zoom",params:{zoom:{enabled:!1,maxRatio:3,minRatio:1,toggle:!0,containerClass:"swiper-zoom-container",zoomedSlideClass:"swiper-slide-zoomed"}},create:function(){var e=this;z(e,{zoom:t({enabled:!1,scale:1,currentScale:1,isScaling:!1,gesture:{$slideEl:void 0,slideWidth:void 0,slideHeight:void 0,$imageEl:void 0,$imageWrapEl:void 0,maxRatio:3},image:{isTouched:void 0,isMoved:void 0,currentX:void 0,currentY:void 0,minX:void 0,minY:void 0,maxX:void 0,maxY:void 0,width:void 0,height:void 0,startX:void 0,startY:void 0,touchesStart:{},touchesCurrent:{}},velocity:{x:void 0,y:void 0,prevPositionX:void 0,prevPositionY:void 0,prevTime:void 0}},ie)});var a=1;Object.defineProperty(e.zoom,"scale",{get:function(){return a},set:function(t){if(a!==t){var i=e.zoom.gesture.$imageEl?e.zoom.gesture.$imageEl[0]:void 0,s=e.zoom.gesture.$slideEl?e.zoom.gesture.$slideEl[0]:void 0;e.emit("zoomChange",t,i,s)}a=t}})},on:{init:function(e){e.params.zoom.enabled&&e.zoom.enable()},destroy:function(e){e.zoom.disable()},touchStart:function(e,t){e.zoom.enabled&&e.zoom.onTouchStart(t)},touchEnd:function(e,t){e.zoom.enabled&&e.zoom.onTouchEnd(t)},doubleTap:function(e,t){!e.animating&&e.params.zoom.enabled&&e.zoom.enabled&&e.params.zoom.toggle&&e.zoom.toggle(t)},transitionEnd:function(e){e.zoom.enabled&&e.params.zoom.enabled&&e.zoom.onTransitionEnd()},slideChange:function(e){e.zoom.enabled&&e.params.zoom.enabled&&e.params.cssMode&&e.zoom.onTransitionEnd()}}},{name:"lazy",params:{lazy:{checkInView:!1,enabled:!1,loadPrevNext:!1,loadPrevNextAmount:1,loadOnTransitionStart:!1,scrollingElement:"",elementClass:"swiper-lazy",loadingClass:"swiper-lazy-loading",loadedClass:"swiper-lazy-loaded",preloaderClass:"swiper-lazy-preloader"}},create:function(){z(this,{lazy:t({initialImageLoaded:!1},se)})},on:{beforeInit:function(e){e.params.lazy.enabled&&e.params.preloadImages&&(e.params.preloadImages=!1)},init:function(e){e.params.lazy.enabled&&!e.params.loop&&0===e.params.initialSlide&&(e.params.lazy.checkInView?e.lazy.checkInViewOnLoad():e.lazy.load())},scroll:function(e){e.params.freeMode&&!e.params.freeModeSticky&&e.lazy.load()},"scrollbarDragMove resize _freeModeNoMomentumRelease":function(e){e.params.lazy.enabled&&e.lazy.load()},transitionStart:function(e){e.params.lazy.enabled&&(e.params.lazy.loadOnTransitionStart||!e.params.lazy.loadOnTransitionStart&&!e.lazy.initialImageLoaded)&&e.lazy.load()},transitionEnd:function(e){e.params.lazy.enabled&&!e.params.lazy.loadOnTransitionStart&&e.lazy.load()},slideChange:function(e){var t=e.params,a=t.lazy,i=t.cssMode,s=t.watchSlidesVisibility,r=t.watchSlidesProgress,n=t.touchReleaseOnEdges,l=t.resistanceRatio;a.enabled&&(i||(s||r)&&(n||0===l))&&e.lazy.load()}}},{name:"controller",params:{controller:{control:void 0,inverse:!1,by:"slide"}},create:function(){z(this,{controller:t({control:this.params.controller.control},re)})},on:{update:function(e){e.controller.control&&e.controller.spline&&(e.controller.spline=void 0,delete e.controller.spline)},resize:function(e){e.controller.control&&e.controller.spline&&(e.controller.spline=void 0,delete e.controller.spline)},observerUpdate:function(e){e.controller.control&&e.controller.spline&&(e.controller.spline=void 0,delete e.controller.spline)},setTranslate:function(e,t,a){e.controller.control&&e.controller.setTranslate(t,a)},setTransition:function(e,t,a){e.controller.control&&e.controller.setTransition(t,a)}}},{name:"a11y",params:{a11y:{enabled:!0,notificationClass:"swiper-notification",prevSlideMessage:"Previous slide",nextSlideMessage:"Next slide",firstSlideMessage:"This is the first slide",lastSlideMessage:"This is the last slide",paginationBulletMessage:"Go to slide {{index}}",slideLabelMessage:"{{index}} / {{slidesLength}}",containerMessage:null,containerRoleDescriptionMessage:null,itemRoleDescriptionMessage:null,slideRole:"group"}},create:function(){z(this,{a11y:t({},ne,{liveRegion:m('<span class="'+this.params.a11y.notificationClass+'" aria-live="assertive" aria-atomic="true"></span>')})})},on:{afterInit:function(e){e.params.a11y.enabled&&(e.a11y.init(),e.a11y.updateNavigation())},toEdge:function(e){e.params.a11y.enabled&&e.a11y.updateNavigation()},fromEdge:function(e){e.params.a11y.enabled&&e.a11y.updateNavigation()},paginationUpdate:function(e){e.params.a11y.enabled&&e.a11y.updatePagination()},destroy:function(e){e.params.a11y.enabled&&e.a11y.destroy()}}},{name:"history",params:{history:{enabled:!1,root:"",replaceState:!1,key:"slides"}},create:function(){z(this,{history:t({},le)})},on:{init:function(e){e.params.history.enabled&&e.history.init()},destroy:function(e){e.params.history.enabled&&e.history.destroy()},"transitionEnd _freeModeNoMomentumRelease":function(e){e.history.initialized&&e.history.setHistory(e.params.history.key,e.activeIndex)},slideChange:function(e){e.history.initialized&&e.params.cssMode&&e.history.setHistory(e.params.history.key,e.activeIndex)}}},{name:"hash-navigation",params:{hashNavigation:{enabled:!1,replaceState:!1,watchState:!1}},create:function(){z(this,{hashNavigation:t({initialized:!1},oe)})},on:{init:function(e){e.params.hashNavigation.enabled&&e.hashNavigation.init()},destroy:function(e){e.params.hashNavigation.enabled&&e.hashNavigation.destroy()},"transitionEnd _freeModeNoMomentumRelease":function(e){e.hashNavigation.initialized&&e.hashNavigation.setHash()},slideChange:function(e){e.hashNavigation.initialized&&e.params.cssMode&&e.hashNavigation.setHash()}}},{name:"autoplay",params:{autoplay:{enabled:!1,delay:3e3,waitForTransition:!0,disableOnInteraction:!0,stopOnLastSlide:!1,reverseDirection:!1,pauseOnMouseEnter:!1}},create:function(){z(this,{autoplay:t({},de,{running:!1,paused:!1})})},on:{init:function(e){e.params.autoplay.enabled&&(e.autoplay.start(),r().addEventListener("visibilitychange",e.autoplay.onVisibilityChange),e.autoplay.attachMouseEvents())},beforeTransitionStart:function(e,t,a){e.autoplay.running&&(a||!e.params.autoplay.disableOnInteraction?e.autoplay.pause(t):e.autoplay.stop())},sliderFirstMove:function(e){e.autoplay.running&&(e.params.autoplay.disableOnInteraction?e.autoplay.stop():e.autoplay.pause())},touchEnd:function(e){e.params.cssMode&&e.autoplay.paused&&!e.params.autoplay.disableOnInteraction&&e.autoplay.run()},destroy:function(e){e.autoplay.detachMouseEvents(),e.autoplay.running&&e.autoplay.stop(),r().removeEventListener("visibilitychange",e.autoplay.onVisibilityChange)}}},{name:"effect-fade",params:{fadeEffect:{crossFade:!1}},create:function(){z(this,{fadeEffect:t({},pe)})},on:{beforeInit:function(e){if("fade"===e.params.effect){e.classNames.push(e.params.containerModifierClass+"fade");var t={slidesPerView:1,slidesPerColumn:1,slidesPerGroup:1,watchSlidesProgress:!0,spaceBetween:0,virtualTranslate:!0};M(e.params,t),M(e.originalParams,t)}},setTranslate:function(e){"fade"===e.params.effect&&e.fadeEffect.setTranslate()},setTransition:function(e,t){"fade"===e.params.effect&&e.fadeEffect.setTransition(t)}}},{name:"effect-cube",params:{cubeEffect:{slideShadows:!0,shadow:!0,shadowOffset:20,shadowScale:.94}},create:function(){z(this,{cubeEffect:t({},ue)})},on:{beforeInit:function(e){if("cube"===e.params.effect){e.classNames.push(e.params.containerModifierClass+"cube"),e.classNames.push(e.params.containerModifierClass+"3d");var t={slidesPerView:1,slidesPerColumn:1,slidesPerGroup:1,watchSlidesProgress:!0,resistanceRatio:0,spaceBetween:0,centeredSlides:!1,virtualTranslate:!0};M(e.params,t),M(e.originalParams,t)}},setTranslate:function(e){"cube"===e.params.effect&&e.cubeEffect.setTranslate()},setTransition:function(e,t){"cube"===e.params.effect&&e.cubeEffect.setTransition(t)}}},{name:"effect-flip",params:{flipEffect:{slideShadows:!0,limitRotation:!0}},create:function(){z(this,{flipEffect:t({},ce)})},on:{beforeInit:function(e){if("flip"===e.params.effect){e.classNames.push(e.params.containerModifierClass+"flip"),e.classNames.push(e.params.containerModifierClass+"3d");var t={slidesPerView:1,slidesPerColumn:1,slidesPerGroup:1,watchSlidesProgress:!0,spaceBetween:0,virtualTranslate:!0};M(e.params,t),M(e.originalParams,t)}},setTranslate:function(e){"flip"===e.params.effect&&e.flipEffect.setTranslate()},setTransition:function(e,t){"flip"===e.params.effect&&e.flipEffect.setTransition(t)}}},{name:"effect-coverflow",params:{coverflowEffect:{rotate:50,stretch:0,depth:100,scale:1,modifier:1,slideShadows:!0}},create:function(){z(this,{coverflowEffect:t({},he)})},on:{beforeInit:function(e){"coverflow"===e.params.effect&&(e.classNames.push(e.params.containerModifierClass+"coverflow"),e.classNames.push(e.params.containerModifierClass+"3d"),e.params.watchSlidesProgress=!0,e.originalParams.watchSlidesProgress=!0)},setTranslate:function(e){"coverflow"===e.params.effect&&e.coverflowEffect.setTranslate()},setTransition:function(e,t){"coverflow"===e.params.effect&&e.coverflowEffect.setTransition(t)}}},{name:"thumbs",params:{thumbs:{swiper:null,multipleActiveThumbs:!0,autoScrollOffset:0,slideThumbActiveClass:"swiper-slide-thumb-active",thumbsContainerClass:"swiper-container-thumbs"}},create:function(){z(this,{thumbs:t({swiper:null,initialized:!1},ve)})},on:{beforeInit:function(e){var t=e.params.thumbs;t&&t.swiper&&(e.thumbs.init(),e.thumbs.update(!0))},slideChange:function(e){e.thumbs.swiper&&e.thumbs.update()},update:function(e){e.thumbs.swiper&&e.thumbs.update()},resize:function(e){e.thumbs.swiper&&e.thumbs.update()},observerUpdate:function(e){e.thumbs.swiper&&e.thumbs.update()},setTransition:function(e,t){var a=e.thumbs.swiper;a&&a.setTransition(t)},beforeDestroy:function(e){var t=e.thumbs.swiper;t&&e.thumbs.swiperCreated&&t&&t.destroy()}}}];return q.use(fe),q}));
 //# sourceMappingURL=swiper-bundle.min.js.map
/**
 * tooltipster http://calebjacob.github.io/tooltipster/
 * A rockin' custom tooltip jQuery plugin
 * Developed by Caleb Jacob and Louis Ameline
 * MIT license
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define(["jquery"], function (a0) {
      return (factory(a0));
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory(require("jquery"));
  } else {
    factory(jQuery);
  }
}(this, function ($) {

// This file will be UMDified by a build task.

var defaults = {
		animation: 'fade',
		animationDuration: 350,
		content: null,
		contentAsHTML: false,
		contentCloning: false,
		debug: true,
		delay: 300,
		delayTouch: [300, 500],
		functionInit: null,
		functionBefore: null,
		functionReady: null,
		functionAfter: null,
		functionFormat: null,
		IEmin: 6,
		interactive: false,
		multiple: false,
		// will default to document.body, or must be an element positioned at (0, 0)
		// in the document, typically like the very top views of an app.
		parent: null,
		plugins: ['sideTip'],
		repositionOnScroll: false,
		restoration: 'none',
		selfDestruction: true,
		theme: [],
		timer: 0,
		trackerInterval: 500,
		trackOrigin: false,
		trackTooltip: false,
		trigger: 'hover',
		triggerClose: {
			click: false,
			mouseleave: false,
			originClick: false,
			scroll: false,
			tap: false,
			touchleave: false
		},
		triggerOpen: {
			click: false,
			mouseenter: false,
			tap: false,
			touchstart: false
		},
		updateAnimation: 'rotate',
		zIndex: 9999999
	},
	// we'll avoid using the 'window' global as a good practice but npm's
	// jquery@<2.1.0 package actually requires a 'window' global, so not sure
	// it's useful at all
	win = (typeof window != 'undefined') ? window : null,
	// env will be proxied by the core for plugins to have access its properties
	env = {
		// detect if this device can trigger touch events. Better have a false
		// positive (unused listeners, that's ok) than a false negative.
		// https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
		// http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript
		hasTouchCapability: !!(
			win
			&&	(	'ontouchstart' in win
				||	(win.DocumentTouch && win.document instanceof win.DocumentTouch)
				||	win.navigator.maxTouchPoints
			)
		),
		hasTransitions: transitionSupport(),
		IE: false,
		// don't set manually, it will be updated by a build task after the manifest
		semVer: '4.2.8',
		window: win
	},
	core = function() {
		
		// core variables
		
		// the core emitters
		this.__$emitterPrivate = $({});
		this.__$emitterPublic = $({});
		this.__instancesLatestArr = [];
		// collects plugin constructors
		this.__plugins = {};
		// proxy env variables for plugins who might use them
		this._env = env;
	};

// core methods
core.prototype = {
	
	/**
	 * A function to proxy the public methods of an object onto another
	 *
	 * @param {object} constructor The constructor to bridge
	 * @param {object} obj The object that will get new methods (an instance or the core)
	 * @param {string} pluginName A plugin name for the console log message
	 * @return {core}
	 * @private
	 */
	__bridge: function(constructor, obj, pluginName) {
		
		// if it's not already bridged
		if (!obj[pluginName]) {
			
			var fn = function() {};
			fn.prototype = constructor;
			
			var pluginInstance = new fn();
			
			// the _init method has to exist in instance constructors but might be missing
			// in core constructors
			if (pluginInstance.__init) {
				pluginInstance.__init(obj);
			}
			
			$.each(constructor, function(methodName, fn) {
				
				// don't proxy "private" methods, only "protected" and public ones
				if (methodName.indexOf('__') != 0) {
					
					// if the method does not exist yet
					if (!obj[methodName]) {
						
						obj[methodName] = function() {
							return pluginInstance[methodName].apply(pluginInstance, Array.prototype.slice.apply(arguments));
						};
						
						// remember to which plugin this method corresponds (several plugins may
						// have methods of the same name, we need to be sure)
						obj[methodName].bridged = pluginInstance;
					}
					else if (defaults.debug) {
						
						console.log('The '+ methodName +' method of the '+ pluginName
							+' plugin conflicts with another plugin or native methods');
					}
				}
			});
			
			obj[pluginName] = pluginInstance;
		}
		
		return this;
	},
	
	/**
	 * For mockup in Node env if need be, for testing purposes
	 *
	 * @return {core}
	 * @private
	 */
	__setWindow: function(window) {
		env.window = window;
		return this;
	},
	
	/**
	 * Returns a ruler, a tool to help measure the size of a tooltip under
	 * various settings. Meant for plugins
	 * 
	 * @see Ruler
	 * @return {object} A Ruler instance
	 * @protected
	 */
	_getRuler: function($tooltip) {
		return new Ruler($tooltip);
	},
	
	/**
	 * For internal use by plugins, if needed
	 *
	 * @return {core}
	 * @protected
	 */
	_off: function() {
		this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
		return this;
	},
	
	/**
	 * For internal use by plugins, if needed
	 *
	 * @return {core}
	 * @protected
	 */
	_on: function() {
		this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
		return this;
	},
	
	/**
	 * For internal use by plugins, if needed
	 *
	 * @return {core}
	 * @protected
	 */
	_one: function() {
		this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
		return this;
	},
	
	/**
	 * Returns (getter) or adds (setter) a plugin
	 *
	 * @param {string|object} plugin Provide a string (in the full form
	 * "namespace.name") to use as as getter, an object to use as a setter
	 * @return {object|core}
	 * @protected
	 */
	_plugin: function(plugin) {
		
		var self = this;
		
		// getter
		if (typeof plugin == 'string') {
			
			var pluginName = plugin,
				p = null;
			
			// if the namespace is provided, it's easy to search
			if (pluginName.indexOf('.') > 0) {
				p = self.__plugins[pluginName];
			}
			// otherwise, return the first name that matches
			else {
				$.each(self.__plugins, function(i, plugin) {
					
					if (plugin.name.substring(plugin.name.length - pluginName.length - 1) == '.'+ pluginName) {
						p = plugin;
						return false;
					}
				});
			}
			
			return p;
		}
		// setter
		else {
			
			// force namespaces
			if (plugin.name.indexOf('.') < 0) {
				throw new Error('Plugins must be namespaced');
			}
			
			self.__plugins[plugin.name] = plugin;
			
			// if the plugin has core features
			if (plugin.core) {
				
				// bridge non-private methods onto the core to allow new core methods
				self.__bridge(plugin.core, self, plugin.name);
			}
			
			return this;
		}
	},
	
	/**
	 * Trigger events on the core emitters
	 * 
	 * @returns {core}
	 * @protected
	 */
	_trigger: function() {
		
		var args = Array.prototype.slice.apply(arguments);
		
		if (typeof args[0] == 'string') {
			args[0] = { type: args[0] };
		}
		
		// note: the order of emitters matters
		this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);
		this.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);
		
		return this;
	},
	
	/**
	 * Returns instances of all tooltips in the page or an a given element
	 *
	 * @param {string|HTML object collection} selector optional Use this
	 * parameter to restrict the set of objects that will be inspected
	 * for the retrieval of instances. By default, all instances in the
	 * page are returned.
	 * @return {array} An array of instance objects
	 * @public
	 */
	instances: function(selector) {
		
		var instances = [],
			sel = selector || '.tooltipstered';
		
		$(sel).each(function() {
			
			var $this = $(this),
				ns = $this.data('tooltipster-ns');
			
			if (ns) {
				
				$.each(ns, function(i, namespace) {
					instances.push($this.data(namespace));
				});
			}
		});
		
		return instances;
	},
	
	/**
	 * Returns the Tooltipster objects generated by the last initializing call
	 *
	 * @return {array} An array of instance objects
	 * @public
	 */
	instancesLatest: function() {
		return this.__instancesLatestArr;
	},
	
	/**
	 * For public use only, not to be used by plugins (use ::_off() instead)
	 *
	 * @return {core}
	 * @public
	 */
	off: function() {
		this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
		return this;
	},
	
	/**
	 * For public use only, not to be used by plugins (use ::_on() instead)
	 *
	 * @return {core}
	 * @public
	 */
	on: function() {
		this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
		return this;
	},
	
	/**
	 * For public use only, not to be used by plugins (use ::_one() instead)
	 * 
	 * @return {core}
	 * @public
	 */
	one: function() {
		this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
		return this;
	},
	
	/**
	 * Returns all HTML elements which have one or more tooltips
	 *
	 * @param {string} selector optional Use this to restrict the results
	 * to the descendants of an element
	 * @return {array} An array of HTML elements
	 * @public
	 */
	origins: function(selector) {
		
		var sel = selector ?
			selector +' ' :
			'';
		
		return $(sel +'.tooltipstered').toArray();
	},
	
	/**
	 * Change default options for all future instances
	 *
	 * @param {object} d The options that should be made defaults
	 * @return {core}
	 * @public
	 */
	setDefaults: function(d) {
		$.extend(defaults, d);
		return this;
	},
	
	/**
	 * For users to trigger their handlers on the public emitter
	 * 
	 * @returns {core}
	 * @public
	 */
	triggerHandler: function() {
		this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
		return this;
	}
};

// $.tooltipster will be used to call core methods
$.tooltipster = new core();

// the Tooltipster instance class (mind the capital T)
$.Tooltipster = function(element, options) {
	
	// list of instance variables
	
	// stack of custom callbacks provided as parameters to API methods
	this.__callbacks = {
		close: [],
		open: []
	};
	// the schedule time of DOM removal
	this.__closingTime;
	// this will be the user content shown in the tooltip. A capital "C" is used
	// because there is also a method called content()
	this.__Content;
	// for the size tracker
	this.__contentBcr;
	// to disable the tooltip after destruction
	this.__destroyed = false;
	// we can't emit directly on the instance because if a method with the same
	// name as the event exists, it will be called by jQuery. Se we use a plain
	// object as emitter. This emitter is for internal use by plugins,
	// if needed.
	this.__$emitterPrivate = $({});
	// this emitter is for the user to listen to events without risking to mess
	// with our internal listeners
	this.__$emitterPublic = $({});
	this.__enabled = true;
	// the reference to the gc interval
	this.__garbageCollector;
	// various position and size data recomputed before each repositioning
	this.__Geometry;
	// the tooltip position, saved after each repositioning by a plugin
	this.__lastPosition;
	// a unique namespace per instance
	this.__namespace = 'tooltipster-'+ Math.round(Math.random()*1000000);
	this.__options;
	// will be used to support origins in scrollable areas
	this.__$originParents;
	this.__pointerIsOverOrigin = false;
	// to remove themes if needed
	this.__previousThemes = [];
	// the state can be either: appearing, stable, disappearing, closed
	this.__state = 'closed';
	// timeout references
	this.__timeouts = {
		close: [],
		open: null
	};
	// store touch events to be able to detect emulated mouse events
	this.__touchEvents = [];
	// the reference to the tracker interval
	this.__tracker = null;
	// the element to which this tooltip is associated
	this._$origin;
	// this will be the tooltip element (jQuery wrapped HTML element).
	// It's the job of a plugin to create it and append it to the DOM
	this._$tooltip;
	
	// launch
	this.__init(element, options);
};

$.Tooltipster.prototype = {
	
	/**
	 * @param origin
	 * @param options
	 * @private
	 */
	__init: function(origin, options) {
		
		var self = this;
		
		self._$origin = $(origin);
		self.__options = $.extend(true, {}, defaults, options);
		
		// some options may need to be reformatted
		self.__optionsFormat();
		
		// don't run on old IE if asked no to
		if (	!env.IE
			||	env.IE >= self.__options.IEmin
		) {
			
			// note: the content is null (empty) by default and can stay that
			// way if the plugin remains initialized but not fed any content. The
			// tooltip will just not appear.
			
			// let's save the initial value of the title attribute for later
			// restoration if need be.
			var initialTitle = null;
			
			// it will already have been saved in case of multiple tooltips
			if (self._$origin.data('tooltipster-initialTitle') === undefined) {
				
				initialTitle = self._$origin.attr('title');
				
				// we do not want initialTitle to be "undefined" because
				// of how jQuery's .data() method works
				if (initialTitle === undefined) initialTitle = null;
				
				self._$origin.data('tooltipster-initialTitle', initialTitle);
			}
			
			// If content is provided in the options, it has precedence over the
			// title attribute.
			// Note: an empty string is considered content, only 'null' represents
			// the absence of content.
			// Also, an existing title="" attribute will result in an empty string
			// content
			if (self.__options.content !== null) {
				self.__contentSet(self.__options.content);
			}
			else {
				
				var selector = self._$origin.attr('data-tooltip-content'),
					$el;
				
				if (selector){
					$el = $(selector);
				}
				
				if ($el && $el[0]) {
					self.__contentSet($el.first());
				}
				else {
					self.__contentSet(initialTitle);
				}
			}
			
			self._$origin
				// strip the title off of the element to prevent the default tooltips
				// from popping up
				.removeAttr('title')
				// to be able to find all instances on the page later (upon window
				// events in particular)
				.addClass('tooltipstered');
			
			// set listeners on the origin
			self.__prepareOrigin();
			
			// set the garbage collector
			self.__prepareGC();
			
			// init plugins
			$.each(self.__options.plugins, function(i, pluginName) {
				self._plug(pluginName);
			});
			
			// to detect swiping
			if (env.hasTouchCapability) {
				$(env.window.document.body).on('touchmove.'+ self.__namespace +'-triggerOpen', function(event) {
					self._touchRecordEvent(event);
				});
			}
			
			self
				// prepare the tooltip when it gets created. This event must
				// be fired by a plugin
				._on('created', function() {
					self.__prepareTooltip();
				})
				// save position information when it's sent by a plugin
				._on('repositioned', function(e) {
					self.__lastPosition = e.position;
				});
		}
		else {
			self.__options.disabled = true;
		}
	},
	
	/**
	 * Insert the content into the appropriate HTML element of the tooltip
	 * 
	 * @returns {self}
	 * @private
	 */
	__contentInsert: function() {
		
		var self = this,
			$el = self._$tooltip.find('.tooltipster-content'),
			formattedContent = self.__Content,
			format = function(content) {
				formattedContent = content;
			};
		
		self._trigger({
			type: 'format',
			content: self.__Content,
			format: format
		});
		
		if (self.__options.functionFormat) {
			
			formattedContent = self.__options.functionFormat.call(
				self,
				self,
				{ origin: self._$origin[0] },
				self.__Content
			);
		}
		
		if (typeof formattedContent === 'string' && !self.__options.contentAsHTML) {
			$el.text(formattedContent);
		}
		else {
			$el
				.empty()
				.append(formattedContent);
		}
		
		return self;
	},
	
	/**
	 * Save the content, cloning it beforehand if need be
	 * 
	 * @param content
	 * @returns {self}
	 * @private
	 */
	__contentSet: function(content) {
		
		// clone if asked. Cloning the object makes sure that each instance has its
		// own version of the content (in case a same object were provided for several
		// instances)
		// reminder: typeof null === object
		if (content instanceof $ && this.__options.contentCloning) {
			content = content.clone(true);
		}
		
		this.__Content = content;
		
		this._trigger({
			type: 'updated',
			content: content
		});
		
		return this;
	},
	
	/**
	 * Error message about a method call made after destruction
	 * 
	 * @private
	 */
	__destroyError: function() {
		throw new Error('This tooltip has been destroyed and cannot execute your method call.');
	},
	
	/**
	 * Gather all information about dimensions and available space,
	 * called before every repositioning
	 * 
	 * @private
	 * @returns {object}
	 */
	__geometry: function() {
		
		var	self = this,
			$target = self._$origin,
			originIsArea = self._$origin.is('area');
		
		// if this._$origin is a map area, the target we'll need
		// the dimensions of is actually the image using the map,
		// not the area itself
		if (originIsArea) {
			
			var mapName = self._$origin.parent().attr('name');
			
			$target = $('img[usemap="#'+ mapName +'"]');
		}
		
		var bcr = $target[0].getBoundingClientRect(),
			$document = $(env.window.document),
			$window = $(env.window),
			$parent = $target,
			// some useful properties of important elements
			geo = {
				// available space for the tooltip, see down below
				available: {
					document: null,
					window: null
				},
				document: {
					size: {
						height: $document.height(),
						width: $document.width()
					}
				},
				window: {
					scroll: {
						// the second ones are for IE compatibility
						left: env.window.scrollX || env.window.document.documentElement.scrollLeft,
						top: env.window.scrollY || env.window.document.documentElement.scrollTop
					},
					size: {
						height: $window.height(),
						width: $window.width()
					}
				},
				origin: {
					// the origin has a fixed lineage if itself or one of its
					// ancestors has a fixed position
					fixedLineage: false,
					// relative to the document
					offset: {},
					size: {
						height: bcr.bottom - bcr.top,
						width: bcr.right - bcr.left
					},
					usemapImage: originIsArea ? $target[0] : null,
					// relative to the window
					windowOffset: {
						bottom: bcr.bottom,
						left: bcr.left,
						right: bcr.right,
						top: bcr.top
					}
				}
			},
			geoFixed = false;
		
		// if the element is a map area, some properties may need
		// to be recalculated
		if (originIsArea) {
			
			var shape = self._$origin.attr('shape'),
				coords = self._$origin.attr('coords');
			
			if (coords) {
				
				coords = coords.split(',');
				
				$.map(coords, function(val, i) {
					coords[i] = parseInt(val);
				});
			}
			
			// if the image itself is the area, nothing more to do
			if (shape != 'default') {
				
				switch(shape) {
					
					case 'circle':
						
						var circleCenterLeft = coords[0],
							circleCenterTop = coords[1],
							circleRadius = coords[2],
							areaTopOffset = circleCenterTop - circleRadius,
							areaLeftOffset = circleCenterLeft - circleRadius;
						
						geo.origin.size.height = circleRadius * 2;
						geo.origin.size.width = geo.origin.size.height;
						
						geo.origin.windowOffset.left += areaLeftOffset;
						geo.origin.windowOffset.top += areaTopOffset;
						
						break;
					
					case 'rect':
						
						var areaLeft = coords[0],
							areaTop = coords[1],
							areaRight = coords[2],
							areaBottom = coords[3];
						
						geo.origin.size.height = areaBottom - areaTop;
						geo.origin.size.width = areaRight - areaLeft;
						
						geo.origin.windowOffset.left += areaLeft;
						geo.origin.windowOffset.top += areaTop;
						
						break;
					
					case 'poly':
						
						var areaSmallestX = 0,
							areaSmallestY = 0,
							areaGreatestX = 0,
							areaGreatestY = 0,
							arrayAlternate = 'even';
						
						for (var i = 0; i < coords.length; i++) {
							
							var areaNumber = coords[i];
							
							if (arrayAlternate == 'even') {
								
								if (areaNumber > areaGreatestX) {
									
									areaGreatestX = areaNumber;
									
									if (i === 0) {
										areaSmallestX = areaGreatestX;
									}
								}
								
								if (areaNumber < areaSmallestX) {
									areaSmallestX = areaNumber;
								}
								
								arrayAlternate = 'odd';
							}
							else {
								if (areaNumber > areaGreatestY) {
									
									areaGreatestY = areaNumber;
									
									if (i == 1) {
										areaSmallestY = areaGreatestY;
									}
								}
								
								if (areaNumber < areaSmallestY) {
									areaSmallestY = areaNumber;
								}
								
								arrayAlternate = 'even';
							}
						}
						
						geo.origin.size.height = areaGreatestY - areaSmallestY;
						geo.origin.size.width = areaGreatestX - areaSmallestX;
						
						geo.origin.windowOffset.left += areaSmallestX;
						geo.origin.windowOffset.top += areaSmallestY;
						
						break;
				}
			}
		}
		
		// user callback through an event
		var edit = function(r) {
			geo.origin.size.height = r.height,
				geo.origin.windowOffset.left = r.left,
				geo.origin.windowOffset.top = r.top,
				geo.origin.size.width = r.width
		};
		
		self._trigger({
			type: 'geometry',
			edit: edit,
			geometry: {
				height: geo.origin.size.height,
				left: geo.origin.windowOffset.left,
				top: geo.origin.windowOffset.top,
				width: geo.origin.size.width
			}
		});
		
		// calculate the remaining properties with what we got
		
		geo.origin.windowOffset.right = geo.origin.windowOffset.left + geo.origin.size.width;
		geo.origin.windowOffset.bottom = geo.origin.windowOffset.top + geo.origin.size.height;
		
		geo.origin.offset.left = geo.origin.windowOffset.left + geo.window.scroll.left;
		geo.origin.offset.top = geo.origin.windowOffset.top + geo.window.scroll.top;
		geo.origin.offset.bottom = geo.origin.offset.top + geo.origin.size.height;
		geo.origin.offset.right = geo.origin.offset.left + geo.origin.size.width;
		
		// the space that is available to display the tooltip relatively to the document
		geo.available.document = {
			bottom: {
				height: geo.document.size.height - geo.origin.offset.bottom,
				width: geo.document.size.width
			},
			left: {
				height: geo.document.size.height,
				width: geo.origin.offset.left
			},
			right: {
				height: geo.document.size.height,
				width: geo.document.size.width - geo.origin.offset.right
			},
			top: {
				height: geo.origin.offset.top,
				width: geo.document.size.width
			}
		};
		
		// the space that is available to display the tooltip relatively to the viewport
		// (the resulting values may be negative if the origin overflows the viewport)
		geo.available.window = {
			bottom: {
				// the inner max is here to make sure the available height is no bigger
				// than the viewport height (when the origin is off screen at the top).
				// The outer max just makes sure that the height is not negative (when
				// the origin overflows at the bottom).
				height: Math.max(geo.window.size.height - Math.max(geo.origin.windowOffset.bottom, 0), 0),
				width: geo.window.size.width
			},
			left: {
				height: geo.window.size.height,
				width: Math.max(geo.origin.windowOffset.left, 0)
			},
			right: {
				height: geo.window.size.height,
				width: Math.max(geo.window.size.width - Math.max(geo.origin.windowOffset.right, 0), 0)
			},
			top: {
				height: Math.max(geo.origin.windowOffset.top, 0),
				width: geo.window.size.width
			}
		};
		
		while ($parent[0].tagName.toLowerCase() != 'html') {
			
			if ($parent.css('position') == 'fixed') {
				geo.origin.fixedLineage = true;
				break;
			}
			
			$parent = $parent.parent();
		}
		
		return geo;
	},
	
	/**
	 * Some options may need to be formated before being used
	 * 
	 * @returns {self}
	 * @private
	 */
	__optionsFormat: function() {
		
		if (typeof this.__options.animationDuration == 'number') {
			this.__options.animationDuration = [this.__options.animationDuration, this.__options.animationDuration];
		}
		
		if (typeof this.__options.delay == 'number') {
			this.__options.delay = [this.__options.delay, this.__options.delay];
		}
		
		if (typeof this.__options.delayTouch == 'number') {
			this.__options.delayTouch = [this.__options.delayTouch, this.__options.delayTouch];
		}
		
		if (typeof this.__options.theme == 'string') {
			this.__options.theme = [this.__options.theme];
		}
		
		// determine the future parent
		if (this.__options.parent === null) {
			this.__options.parent = $(env.window.document.body);
		}
		else if (typeof this.__options.parent == 'string') {
			this.__options.parent = $(this.__options.parent);
		}
		
		if (this.__options.trigger == 'hover') {
			
			this.__options.triggerOpen = {
				mouseenter: true,
				touchstart: true
			};
			
			this.__options.triggerClose = {
				mouseleave: true,
				originClick: true,
				touchleave: true
			};
		}
		else if (this.__options.trigger == 'click') {
			
			this.__options.triggerOpen = {
				click: true,
				tap: true
			};
			
			this.__options.triggerClose = {
				click: true,
				tap: true
			};
		}
		
		// for the plugins
		this._trigger('options');
		
		return this;
	},
	
	/**
	 * Schedules or cancels the garbage collector task
	 *
	 * @returns {self}
	 * @private
	 */
	__prepareGC: function() {
		
		var self = this;
		
		// in case the selfDestruction option has been changed by a method call
		if (self.__options.selfDestruction) {
			
			// the GC task
			self.__garbageCollector = setInterval(function() {
				
				var now = new Date().getTime();
				
				// forget the old events
				self.__touchEvents = $.grep(self.__touchEvents, function(event, i) {
					// 1 minute
					return now - event.time > 60000;
				});
				
				// auto-destruct if the origin is gone
				if (!bodyContains(self._$origin)) {
					
					self.close(function(){
						self.destroy();
					});
				}
			}, 20000);
		}
		else {
			clearInterval(self.__garbageCollector);
		}
		
		return self;
	},
	
	/**
	 * Sets listeners on the origin if the open triggers require them.
	 * Unlike the listeners set at opening time, these ones
	 * remain even when the tooltip is closed. It has been made a
	 * separate method so it can be called when the triggers are
	 * changed in the options. Closing is handled in _open()
	 * because of the bindings that may be needed on the tooltip
	 * itself
	 *
	 * @returns {self}
	 * @private
	 */
	__prepareOrigin: function() {
		
		var self = this;
		
		// in case we're resetting the triggers
		self._$origin.off('.'+ self.__namespace +'-triggerOpen');
		
		// if the device is touch capable, even if only mouse triggers
		// are asked, we need to listen to touch events to know if the mouse
		// events are actually emulated (so we can ignore them)
		if (env.hasTouchCapability) {
			
			self._$origin.on(
				'touchstart.'+ self.__namespace +'-triggerOpen ' +
				'touchend.'+ self.__namespace +'-triggerOpen ' +
				'touchcancel.'+ self.__namespace +'-triggerOpen',
				function(event){
					self._touchRecordEvent(event);
				}
			);
		}
		
		// mouse click and touch tap work the same way
		if (	self.__options.triggerOpen.click
			||	(self.__options.triggerOpen.tap && env.hasTouchCapability)
		) {
			
			var eventNames = '';
			if (self.__options.triggerOpen.click) {
				eventNames += 'click.'+ self.__namespace +'-triggerOpen ';
			}
			if (self.__options.triggerOpen.tap && env.hasTouchCapability) {
				eventNames += 'touchend.'+ self.__namespace +'-triggerOpen';
			}
			
			self._$origin.on(eventNames, function(event) {
				if (self._touchIsMeaningfulEvent(event)) {
					self._open(event);
				}
			});
		}
		
		// mouseenter and touch start work the same way
		if (	self.__options.triggerOpen.mouseenter
			||	(self.__options.triggerOpen.touchstart && env.hasTouchCapability)
		) {
			
			var eventNames = '';
			if (self.__options.triggerOpen.mouseenter) {
				eventNames += 'mouseenter.'+ self.__namespace +'-triggerOpen ';
			}
			if (self.__options.triggerOpen.touchstart && env.hasTouchCapability) {
				eventNames += 'touchstart.'+ self.__namespace +'-triggerOpen';
			}
			
			self._$origin.on(eventNames, function(event) {
				if (	self._touchIsTouchEvent(event)
					||	!self._touchIsEmulatedEvent(event)
				) {
					self.__pointerIsOverOrigin = true;
					self._openShortly(event);
				}
			});
		}
		
		// info for the mouseleave/touchleave close triggers when they use a delay
		if (	self.__options.triggerClose.mouseleave
			||	(self.__options.triggerClose.touchleave && env.hasTouchCapability)
		) {
			
			var eventNames = '';
			if (self.__options.triggerClose.mouseleave) {
				eventNames += 'mouseleave.'+ self.__namespace +'-triggerOpen ';
			}
			if (self.__options.triggerClose.touchleave && env.hasTouchCapability) {
				eventNames += 'touchend.'+ self.__namespace +'-triggerOpen touchcancel.'+ self.__namespace +'-triggerOpen';
			}
			
			self._$origin.on(eventNames, function(event) {
				
				if (self._touchIsMeaningfulEvent(event)) {
					self.__pointerIsOverOrigin = false;
				}
			});
		}
		
		return self;
	},
	
	/**
	 * Do the things that need to be done only once after the tooltip
	 * HTML element it has been created. It has been made a separate
	 * method so it can be called when options are changed. Remember
	 * that the tooltip may actually exist in the DOM before it is
	 * opened, and present after it has been closed: it's the display
	 * plugin that takes care of handling it.
	 * 
	 * @returns {self}
	 * @private
	 */
	__prepareTooltip: function() {
		
		var self = this,
			p = self.__options.interactive ? 'auto' : '';
		
		// this will be useful to know quickly if the tooltip is in
		// the DOM or not 
		self._$tooltip
			.attr('id', self.__namespace)
			.css({
				// pointer events
				'pointer-events': p,
				zIndex: self.__options.zIndex
			});
		
		// themes
		// remove the old ones and add the new ones
		$.each(self.__previousThemes, function(i, theme) {
			self._$tooltip.removeClass(theme);
		});
		$.each(self.__options.theme, function(i, theme) {
			self._$tooltip.addClass(theme);
		});
		
		self.__previousThemes = $.merge([], self.__options.theme);
		
		return self;
	},
	
	/**
	 * Handles the scroll on any of the parents of the origin (when the
	 * tooltip is open)
	 *
	 * @param {object} event
	 * @returns {self}
	 * @private
	 */
	__scrollHandler: function(event) {
		
		var self = this;
		
		if (self.__options.triggerClose.scroll) {
			self._close(event);
		}
		else {
			
			// if the origin or tooltip have been removed: do nothing, the tracker will
			// take care of it later
			if (bodyContains(self._$origin) && bodyContains(self._$tooltip)) {
				
				var geo = null;
				
				// if the scroll happened on the window
				if (event.target === env.window.document) {
					
					// if the origin has a fixed lineage, window scroll will have no
					// effect on its position nor on the position of the tooltip
					if (!self.__Geometry.origin.fixedLineage) {
						
						// we don't need to do anything unless repositionOnScroll is true
						// because the tooltip will already have moved with the window
						// (and of course with the origin)
						if (self.__options.repositionOnScroll) {
							self.reposition(event);
						}
					}
				}
				// if the scroll happened on another parent of the tooltip, it means
				// that it's in a scrollable area and now needs to have its position
				// adjusted or recomputed, depending ont the repositionOnScroll
				// option. Also, if the origin is partly hidden due to a parent that
				// hides its overflow, we'll just hide (not close) the tooltip.
				else {
					
					geo = self.__geometry();
					
					var overflows = false;
					
					// a fixed position origin is not affected by the overflow hiding
					// of a parent
					if (self._$origin.css('position') != 'fixed') {
						
						self.__$originParents.each(function(i, el) {
							
							var $el = $(el),
								overflowX = $el.css('overflow-x'),
								overflowY = $el.css('overflow-y');
							
							if (overflowX != 'visible' || overflowY != 'visible') {
								
								var bcr = el.getBoundingClientRect();
								
								if (overflowX != 'visible') {
									
									if (	geo.origin.windowOffset.left < bcr.left
										||	geo.origin.windowOffset.right > bcr.right
									) {
										overflows = true;
										return false;
									}
								}
								
								if (overflowY != 'visible') {
									
									if (	geo.origin.windowOffset.top < bcr.top
										||	geo.origin.windowOffset.bottom > bcr.bottom
									) {
										overflows = true;
										return false;
									}
								}
							}
							
							// no need to go further if fixed, for the same reason as above
							if ($el.css('position') == 'fixed') {
								return false;
							}
						});
					}
					
					if (overflows) {
						self._$tooltip.css('visibility', 'hidden');
					}
					else {
						
						self._$tooltip.css('visibility', 'visible');
						
						// reposition
						if (self.__options.repositionOnScroll) {
							self.reposition(event);
						}
						// or just adjust offset
						else {
							
							// we have to use offset and not windowOffset because this way,
							// only the scroll distance of the scrollable areas are taken into
							// account (the scrolltop value of the main window must be
							// ignored since the tooltip already moves with it)
							var offsetLeft = geo.origin.offset.left - self.__Geometry.origin.offset.left,
								offsetTop = geo.origin.offset.top - self.__Geometry.origin.offset.top;
							
							// add the offset to the position initially computed by the display plugin
							self._$tooltip.css({
								left: self.__lastPosition.coord.left + offsetLeft,
								top: self.__lastPosition.coord.top + offsetTop
							});
						}
					}
				}
				
				self._trigger({
					type: 'scroll',
					event: event,
					geo: geo
				});
			}
		}
		
		return self;
	},
	
	/**
	 * Changes the state of the tooltip
	 *
	 * @param {string} state
	 * @returns {self}
	 * @private
	 */
	__stateSet: function(state) {
		
		this.__state = state;
		
		this._trigger({
			type: 'state',
			state: state
		});
		
		return this;
	},
	
	/**
	 * Clear appearance timeouts
	 *
	 * @returns {self}
	 * @private
	 */
	__timeoutsClear: function() {
		
		// there is only one possible open timeout: the delayed opening
		// when the mouseenter/touchstart open triggers are used
		clearTimeout(this.__timeouts.open);
		this.__timeouts.open = null;
		
		// ... but several close timeouts: the delayed closing when the
		// mouseleave close trigger is used and the timer option
		$.each(this.__timeouts.close, function(i, timeout) {
			clearTimeout(timeout);
		});
		this.__timeouts.close = [];
		
		return this;
	},
	
	/**
	 * Start the tracker that will make checks at regular intervals
	 * 
	 * @returns {self}
	 * @private
	 */
	__trackerStart: function() {
		
		var self = this,
			$content = self._$tooltip.find('.tooltipster-content');
		
		// get the initial content size
		if (self.__options.trackTooltip) {
			self.__contentBcr = $content[0].getBoundingClientRect();
		}
		
		self.__tracker = setInterval(function() {
			
			// if the origin or tooltip elements have been removed.
			// Note: we could destroy the instance now if the origin has
			// been removed but we'll leave that task to our garbage collector
			if (!bodyContains(self._$origin) || !bodyContains(self._$tooltip)) {
				self._close();
			}
			// if everything is alright
			else {
				
				// compare the former and current positions of the origin to reposition
				// the tooltip if need be
				if (self.__options.trackOrigin) {
					
					var g = self.__geometry(),
						identical = false;
					
					// compare size first (a change requires repositioning too)
					if (areEqual(g.origin.size, self.__Geometry.origin.size)) {
						
						// for elements that have a fixed lineage (see __geometry()), we track the
						// top and left properties (relative to window)
						if (self.__Geometry.origin.fixedLineage) {
							if (areEqual(g.origin.windowOffset, self.__Geometry.origin.windowOffset)) {
								identical = true;
							}
						}
						// otherwise, track total offset (relative to document)
						else {
							if (areEqual(g.origin.offset, self.__Geometry.origin.offset)) {
								identical = true;
							}
						}
					}
					
					if (!identical) {
						
						// close the tooltip when using the mouseleave close trigger
						// (see https://github.com/calebjacob/tooltipster/pull/253)
						if (self.__options.triggerClose.mouseleave) {
							self._close();
						}
						else {
							self.reposition();
						}
					}
				}
				
				if (self.__options.trackTooltip) {
					
					var currentBcr = $content[0].getBoundingClientRect();
					
					if (	currentBcr.height !== self.__contentBcr.height
						||	currentBcr.width !== self.__contentBcr.width
					) {
						self.reposition();
						self.__contentBcr = currentBcr;
					}
				}
			}
		}, self.__options.trackerInterval);
		
		return self;
	},
	
	/**
	 * Closes the tooltip (after the closing delay)
	 * 
	 * @param event
	 * @param callback
	 * @param force Set to true to override a potential refusal of the user's function
	 * @returns {self}
	 * @protected
	 */
	_close: function(event, callback, force) {
		
		var self = this,
			ok = true;
		
		self._trigger({
			type: 'close',
			event: event,
			stop: function() {
				ok = false;
			}
		});
		
		// a destroying tooltip (force == true) may not refuse to close
		if (ok || force) {
			
			// save the method custom callback and cancel any open method custom callbacks
			if (callback) self.__callbacks.close.push(callback);
			self.__callbacks.open = [];
			
			// clear open/close timeouts
			self.__timeoutsClear();
			
			var finishCallbacks = function() {
				
				// trigger any close method custom callbacks and reset them
				$.each(self.__callbacks.close, function(i,c) {
					c.call(self, self, {
						event: event,
						origin: self._$origin[0]
					});
				});
				
				self.__callbacks.close = [];
			};
			
			if (self.__state != 'closed') {
				
				var necessary = true,
					d = new Date(),
					now = d.getTime(),
					newClosingTime = now + self.__options.animationDuration[1];
				
				// the tooltip may already already be disappearing, but if a new
				// call to close() is made after the animationDuration was changed
				// to 0 (for example), we ought to actually close it sooner than
				// previously scheduled. In that case it should be noted that the
				// browser will not adapt the animation duration to the new
				// animationDuration that was set after the start of the closing
				// animation.
				// Note: the same thing could be considered at opening, but is not
				// really useful since the tooltip is actually opened immediately
				// upon a call to _open(). Since it would not make the opening
				// animation finish sooner, its sole impact would be to trigger the
				// state event and the open callbacks sooner than the actual end of
				// the opening animation, which is not great.
				if (self.__state == 'disappearing') {
					
					if (	newClosingTime > self.__closingTime
						// in case closing is actually overdue because the script
						// execution was suspended. See #679
						&&	self.__options.animationDuration[1] > 0
					) {
						necessary = false;
					}
				}
				
				if (necessary) {
					
					self.__closingTime = newClosingTime;
					
					if (self.__state != 'disappearing') {
						self.__stateSet('disappearing');
					}
					
					var finish = function() {
						
						// stop the tracker
						clearInterval(self.__tracker);
						
						// a "beforeClose" option has been asked several times but would
						// probably useless since the content element is still accessible
						// via ::content(), and because people can always use listeners
						// inside their content to track what's going on. For the sake of
						// simplicity, this has been denied. Bur for the rare people who
						// really need the option (for old browsers or for the case where
						// detaching the content is actually destructive, for file or
						// password inputs for example), this event will do the work.
						self._trigger({
							type: 'closing',
							event: event
						});
						
						// unbind listeners which are no longer needed
						
						self._$tooltip
							.off('.'+ self.__namespace +'-triggerClose')
							.removeClass('tooltipster-dying');
						
						// orientationchange, scroll and resize listeners
						$(env.window).off('.'+ self.__namespace +'-triggerClose');
						
						// scroll listeners
						self.__$originParents.each(function(i, el) {
							$(el).off('scroll.'+ self.__namespace +'-triggerClose');
						});
						// clear the array to prevent memory leaks
						self.__$originParents = null;
						
						$(env.window.document.body).off('.'+ self.__namespace +'-triggerClose');
						
						self._$origin.off('.'+ self.__namespace +'-triggerClose');
						
						self._off('dismissable');
						
						// a plugin that would like to remove the tooltip from the
						// DOM when closed should bind on this
						self.__stateSet('closed');
						
						// trigger event
						self._trigger({
							type: 'after',
							event: event
						});
						
						// call our constructor custom callback function
						if (self.__options.functionAfter) {
							self.__options.functionAfter.call(self, self, {
								event: event,
								origin: self._$origin[0]
							});
						}
						
						// call our method custom callbacks functions
						finishCallbacks();
					};
					
					if (env.hasTransitions) {
						
						self._$tooltip.css({
							'-moz-animation-duration': self.__options.animationDuration[1] + 'ms',
							'-ms-animation-duration': self.__options.animationDuration[1] + 'ms',
							'-o-animation-duration': self.__options.animationDuration[1] + 'ms',
							'-webkit-animation-duration': self.__options.animationDuration[1] + 'ms',
							'animation-duration': self.__options.animationDuration[1] + 'ms',
							'transition-duration': self.__options.animationDuration[1] + 'ms'
						});
						
						self._$tooltip
							// clear both potential open and close tasks
							.clearQueue()
							.removeClass('tooltipster-show')
							// for transitions only
							.addClass('tooltipster-dying');
						
						if (self.__options.animationDuration[1] > 0) {
							self._$tooltip.delay(self.__options.animationDuration[1]);
						}
						
						self._$tooltip.queue(finish);
					}
					else {
						
						self._$tooltip
							.stop()
							.fadeOut(self.__options.animationDuration[1], finish);
					}
				}
			}
			// if the tooltip is already closed, we still need to trigger
			// the method custom callbacks
			else {
				finishCallbacks();
			}
		}
		
		return self;
	},
	
	/**
	 * For internal use by plugins, if needed
	 * 
	 * @returns {self}
	 * @protected
	 */
	_off: function() {
		this.__$emitterPrivate.off.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
		return this;
	},
	
	/**
	 * For internal use by plugins, if needed
	 *
	 * @returns {self}
	 * @protected
	 */
	_on: function() {
		this.__$emitterPrivate.on.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
		return this;
	},
	
	/**
	 * For internal use by plugins, if needed
	 *
	 * @returns {self}
	 * @protected
	 */
	_one: function() {
		this.__$emitterPrivate.one.apply(this.__$emitterPrivate, Array.prototype.slice.apply(arguments));
		return this;
	},
	
	/**
	 * Opens the tooltip right away.
	 *
	 * @param event
	 * @param callback Will be called when the opening animation is over
	 * @returns {self}
	 * @protected
	 */
	_open: function(event, callback) {
		
		var self = this;
		
		// if the destruction process has not begun and if this was not
		// triggered by an unwanted emulated click event
		if (!self.__destroying) {
			
			// check that the origin is still in the DOM
			if (	bodyContains(self._$origin)
				// if the tooltip is enabled
				&&	self.__enabled
			) {
				
				var ok = true;
				
				// if the tooltip is not open yet, we need to call functionBefore.
				// otherwise we can jst go on
				if (self.__state == 'closed') {
					
					// trigger an event. The event.stop function allows the callback
					// to prevent the opening of the tooltip
					self._trigger({
						type: 'before',
						event: event,
						stop: function() {
							ok = false;
						}
					});
					
					if (ok && self.__options.functionBefore) {
						
						// call our custom function before continuing
						ok = self.__options.functionBefore.call(self, self, {
							event: event,
							origin: self._$origin[0]
						});
					}
				}
				
				if (ok !== false) {
					
					// if there is some content
					if (self.__Content !== null) {
						
						// save the method callback and cancel close method callbacks
						if (callback) {
							self.__callbacks.open.push(callback);
						}
						self.__callbacks.close = [];
						
						// get rid of any appearance timeouts
						self.__timeoutsClear();
						
						var extraTime,
							finish = function() {
								
								if (self.__state != 'stable') {
									self.__stateSet('stable');
								}
								
								// trigger any open method custom callbacks and reset them
								$.each(self.__callbacks.open, function(i,c) {
									c.call(self, self, {
										origin: self._$origin[0],
										tooltip: self._$tooltip[0]
									});
								});
								
								self.__callbacks.open = [];
							};
						
						// if the tooltip is already open
						if (self.__state !== 'closed') {
							
							// the timer (if any) will start (or restart) right now
							extraTime = 0;
							
							// if it was disappearing, cancel that
							if (self.__state === 'disappearing') {
								
								self.__stateSet('appearing');
								
								if (env.hasTransitions) {
									
									self._$tooltip
										.clearQueue()
										.removeClass('tooltipster-dying')
										.addClass('tooltipster-show');
									
									if (self.__options.animationDuration[0] > 0) {
										self._$tooltip.delay(self.__options.animationDuration[0]);
									}
									
									self._$tooltip.queue(finish);
								}
								else {
									// in case the tooltip was currently fading out, bring it back
									// to life
									self._$tooltip
										.stop()
										.fadeIn(finish);
								}
							}
							// if the tooltip is already open, we still need to trigger the method
							// custom callback
							else if (self.__state == 'stable') {
								finish();
							}
						}
						// if the tooltip isn't already open, open it
						else {
							
							// a plugin must bind on this and store the tooltip in this._$tooltip
							self.__stateSet('appearing');
							
							// the timer (if any) will start when the tooltip has fully appeared
							// after its transition
							extraTime = self.__options.animationDuration[0];
							
							// insert the content inside the tooltip
							self.__contentInsert();
							
							// reposition the tooltip and attach to the DOM
							self.reposition(event, true);
							
							// animate in the tooltip. If the display plugin wants no css
							// animations, it may override the animation option with a
							// dummy value that will produce no effect
							if (env.hasTransitions) {
								
								// note: there seems to be an issue with start animations which
								// are randomly not played on fast devices in both Chrome and FF,
								// couldn't find a way to solve it yet. It seems that applying
								// the classes before appending to the DOM helps a little, but
								// it messes up some CSS transitions. The issue almost never
								// happens when delay[0]==0 though
								self._$tooltip
									.addClass('tooltipster-'+ self.__options.animation)
									.addClass('tooltipster-initial')
									.css({
										'-moz-animation-duration': self.__options.animationDuration[0] + 'ms',
										'-ms-animation-duration': self.__options.animationDuration[0] + 'ms',
										'-o-animation-duration': self.__options.animationDuration[0] + 'ms',
										'-webkit-animation-duration': self.__options.animationDuration[0] + 'ms',
										'animation-duration': self.__options.animationDuration[0] + 'ms',
										'transition-duration': self.__options.animationDuration[0] + 'ms'
									});
								
								setTimeout(
									function() {
										
										// a quick hover may have already triggered a mouseleave
										if (self.__state != 'closed') {
											
											self._$tooltip
												.addClass('tooltipster-show')
												.removeClass('tooltipster-initial');
											
											if (self.__options.animationDuration[0] > 0) {
												self._$tooltip.delay(self.__options.animationDuration[0]);
											}
											
											self._$tooltip.queue(finish);
										}
									},
									0
								);
							}
							else {
								
								// old browsers will have to live with this
								self._$tooltip
									.css('display', 'none')
									.fadeIn(self.__options.animationDuration[0], finish);
							}
							
							// checks if the origin is removed while the tooltip is open
							self.__trackerStart();
							
							// NOTE: the listeners below have a '-triggerClose' namespace
							// because we'll remove them when the tooltip closes (unlike
							// the '-triggerOpen' listeners). So some of them are actually
							// not about close triggers, rather about positioning.
							
							$(env.window)
								// reposition on resize
								.on('resize.'+ self.__namespace +'-triggerClose', function(e) {
									
									var $ae = $(document.activeElement);
									
									// reposition only if the resize event was not triggered upon the opening
									// of a virtual keyboard due to an input field being focused within the tooltip
									// (otherwise the repositioning would lose the focus)
									if (	(!$ae.is('input') && !$ae.is('textarea'))
										||	!$.contains(self._$tooltip[0], $ae[0])
									) {
										self.reposition(e);
									}
								})
								// same as below for parents
								.on('scroll.'+ self.__namespace +'-triggerClose', function(e) {
									self.__scrollHandler(e);
								});
							
							self.__$originParents = self._$origin.parents();
							
							// scrolling may require the tooltip to be moved or even
							// repositioned in some cases
							self.__$originParents.each(function(i, parent) {
								
								$(parent).on('scroll.'+ self.__namespace +'-triggerClose', function(e) {
									self.__scrollHandler(e);
								});
							});
							
							if (	self.__options.triggerClose.mouseleave
								||	(self.__options.triggerClose.touchleave && env.hasTouchCapability)
							) {
								
								// we use an event to allow users/plugins to control when the mouseleave/touchleave
								// close triggers will come to action. It allows to have more triggering elements
								// than just the origin and the tooltip for example, or to cancel/delay the closing,
								// or to make the tooltip interactive even if it wasn't when it was open, etc.
								self._on('dismissable', function(event) {
									
									if (event.dismissable) {
										
										if (event.delay) {
											
											timeout = setTimeout(function() {
												// event.event may be undefined
												self._close(event.event);
											}, event.delay);
											
											self.__timeouts.close.push(timeout);
										}
										else {
											self._close(event);
										}
									}
									else {
										clearTimeout(timeout);
									}
								});
								
								// now set the listeners that will trigger 'dismissable' events
								var $elements = self._$origin,
									eventNamesIn = '',
									eventNamesOut = '',
									timeout = null;
								
								// if we have to allow interaction, bind on the tooltip too
								if (self.__options.interactive) {
									$elements = $elements.add(self._$tooltip);
								}
								
								if (self.__options.triggerClose.mouseleave) {
									eventNamesIn += 'mouseenter.'+ self.__namespace +'-triggerClose ';
									eventNamesOut += 'mouseleave.'+ self.__namespace +'-triggerClose ';
								}
								if (self.__options.triggerClose.touchleave && env.hasTouchCapability) {
									eventNamesIn += 'touchstart.'+ self.__namespace +'-triggerClose';
									eventNamesOut += 'touchend.'+ self.__namespace +'-triggerClose touchcancel.'+ self.__namespace +'-triggerClose';
								}
								
								$elements
									// close after some time spent outside of the elements
									.on(eventNamesOut, function(event) {
										
										// it's ok if the touch gesture ended up to be a swipe,
										// it's still a "touch leave" situation
										if (	self._touchIsTouchEvent(event)
											||	!self._touchIsEmulatedEvent(event)
										) {
											
											var delay = (event.type == 'mouseleave') ?
												self.__options.delay :
												self.__options.delayTouch;
											
											self._trigger({
												delay: delay[1],
												dismissable: true,
												event: event,
												type: 'dismissable'
											});
										}
									})
									// suspend the mouseleave timeout when the pointer comes back
									// over the elements
									.on(eventNamesIn, function(event) {
										
										// it's also ok if the touch event is a swipe gesture
										if (	self._touchIsTouchEvent(event)
											||	!self._touchIsEmulatedEvent(event)
										) {
											self._trigger({
												dismissable: false,
												event: event,
												type: 'dismissable'
											});
										}
									});
							}
							
							// close the tooltip when the origin gets a mouse click (common behavior of
							// native tooltips)
							if (self.__options.triggerClose.originClick) {
								
								self._$origin.on('click.'+ self.__namespace + '-triggerClose', function(event) {
									
									// we could actually let a tap trigger this but this feature just
									// does not make sense on touch devices
									if (	!self._touchIsTouchEvent(event)
										&&	!self._touchIsEmulatedEvent(event)
									) {
										self._close(event);
									}
								});
							}
							
							// set the same bindings for click and touch on the body to close the tooltip
							if (	self.__options.triggerClose.click
								||	(self.__options.triggerClose.tap && env.hasTouchCapability)
							) {
								
								// don't set right away since the click/tap event which triggered this method
								// (if it was a click/tap) is going to bubble up to the body, we don't want it
								// to close the tooltip immediately after it opened
								setTimeout(function() {
									
									if (self.__state != 'closed') {
										
										var eventNames = '',
											$body = $(env.window.document.body);
										
										if (self.__options.triggerClose.click) {
											eventNames += 'click.'+ self.__namespace +'-triggerClose ';
										}
										if (self.__options.triggerClose.tap && env.hasTouchCapability) {
											eventNames += 'touchend.'+ self.__namespace +'-triggerClose';
										}
										
										$body.on(eventNames, function(event) {
											
											if (self._touchIsMeaningfulEvent(event)) {
												
												self._touchRecordEvent(event);
												
												if (!self.__options.interactive || !$.contains(self._$tooltip[0], event.target)) {
													self._close(event);
												}
											}
										});
										
										// needed to detect and ignore swiping
										if (self.__options.triggerClose.tap && env.hasTouchCapability) {
											
											$body.on('touchstart.'+ self.__namespace +'-triggerClose', function(event) {
												self._touchRecordEvent(event);
											});
										}
									}
								}, 0);
							}
							
							self._trigger('ready');
							
							// call our custom callback
							if (self.__options.functionReady) {
								self.__options.functionReady.call(self, self, {
									origin: self._$origin[0],
									tooltip: self._$tooltip[0]
								});
							}
						}
						
						// if we have a timer set, let the countdown begin
						if (self.__options.timer > 0) {
							
							var timeout = setTimeout(function() {
								self._close();
							}, self.__options.timer + extraTime);
							
							self.__timeouts.close.push(timeout);
						}
					}
				}
			}
		}
		
		return self;
	},
	
	/**
	 * When using the mouseenter/touchstart open triggers, this function will
	 * schedule the opening of the tooltip after the delay, if there is one
	 *
	 * @param event
	 * @returns {self}
	 * @protected
 	 */
	_openShortly: function(event) {
		
		var self = this,
			ok = true;
		
		if (self.__state != 'stable' && self.__state != 'appearing') {
			
			// if a timeout is not already running
			if (!self.__timeouts.open) {
				
				self._trigger({
					type: 'start',
					event: event,
					stop: function() {
						ok = false;
					}
				});
				
				if (ok) {
					
					var delay = (event.type.indexOf('touch') == 0) ?
						self.__options.delayTouch :
						self.__options.delay;
					
					if (delay[0]) {
						
						self.__timeouts.open = setTimeout(function() {
							
							self.__timeouts.open = null;
							
							// open only if the pointer (mouse or touch) is still over the origin.
							// The check on the "meaningful event" can only be made here, after some
							// time has passed (to know if the touch was a swipe or not)
							if (self.__pointerIsOverOrigin && self._touchIsMeaningfulEvent(event)) {
								
								// signal that we go on
								self._trigger('startend');
								
								self._open(event);
							}
							else {
								// signal that we cancel
								self._trigger('startcancel');
							}
						}, delay[0]);
					}
					else {
						// signal that we go on
						self._trigger('startend');
						
						self._open(event);
					}
				}
			}
		}
		
		return self;
	},
	
	/**
	 * Meant for plugins to get their options
	 * 
	 * @param {string} pluginName The name of the plugin that asks for its options
	 * @param {object} defaultOptions The default options of the plugin
	 * @returns {object} The options
	 * @protected
	 */
	_optionsExtract: function(pluginName, defaultOptions) {
		
		var self = this,
			options = $.extend(true, {}, defaultOptions);
		
		// if the plugin options were isolated in a property named after the
		// plugin, use them (prevents conflicts with other plugins)
		var pluginOptions = self.__options[pluginName];
		
		// if not, try to get them as regular options
		if (!pluginOptions){
			
			pluginOptions = {};
			
			$.each(defaultOptions, function(optionName, value) {
				
				var o = self.__options[optionName];
				
				if (o !== undefined) {
					pluginOptions[optionName] = o;
				}
			});
		}
		
		// let's merge the default options and the ones that were provided. We'd want
		// to do a deep copy but not let jQuery merge arrays, so we'll do a shallow
		// extend on two levels, that will be enough if options are not more than 1
		// level deep
		$.each(options, function(optionName, value) {
			
			if (pluginOptions[optionName] !== undefined) {
				
				if ((		typeof value == 'object'
						&&	!(value instanceof Array)
						&&	value != null
					)
					&&
					(		typeof pluginOptions[optionName] == 'object'
						&&	!(pluginOptions[optionName] instanceof Array)
						&&	pluginOptions[optionName] != null
					)
				) {
					$.extend(options[optionName], pluginOptions[optionName]);
				}
				else {
					options[optionName] = pluginOptions[optionName];
				}
			}
		});
		
		return options;
	},
	
	/**
	 * Used at instantiation of the plugin, or afterwards by plugins that activate themselves
	 * on existing instances
	 * 
	 * @param {object} pluginName
	 * @returns {self}
	 * @protected
	 */
	_plug: function(pluginName) {
		
		var plugin = $.tooltipster._plugin(pluginName);
		
		if (plugin) {
			
			// if there is a constructor for instances
			if (plugin.instance) {
				
				// proxy non-private methods on the instance to allow new instance methods
				$.tooltipster.__bridge(plugin.instance, this, plugin.name);
			}
		}
		else {
			throw new Error('The "'+ pluginName +'" plugin is not defined');
		}
		
		return this;
	},
	
	/**
	 * This will return true if the event is a mouse event which was
	 * emulated by the browser after a touch event. This allows us to
	 * really dissociate mouse and touch triggers.
	 * 
	 * There is a margin of error if a real mouse event is fired right
	 * after (within the delay shown below) a touch event on the same
	 * element, but hopefully it should not happen often.
	 * 
	 * @returns {boolean}
	 * @protected
	 */
	_touchIsEmulatedEvent: function(event) {
		
		var isEmulated = false,
			now = new Date().getTime();
		
		for (var i = this.__touchEvents.length - 1; i >= 0; i--) {
			
			var e = this.__touchEvents[i];
			
			// delay, in milliseconds. It's supposed to be 300ms in
			// most browsers (350ms on iOS) to allow a double tap but
			// can be less (check out FastClick for more info)
			if (now - e.time < 500) {
				
				if (e.target === event.target) {
					isEmulated = true;
				}
			}
			else {
				break;
			}
		}
		
		return isEmulated;
	},
	
	/**
	 * Returns false if the event was an emulated mouse event or
	 * a touch event involved in a swipe gesture.
	 * 
	 * @param {object} event
	 * @returns {boolean}
	 * @protected
	 */
	_touchIsMeaningfulEvent: function(event) {
		return (
				(this._touchIsTouchEvent(event) && !this._touchSwiped(event.target))
			||	(!this._touchIsTouchEvent(event) && !this._touchIsEmulatedEvent(event))
		);
	},
	
	/**
	 * Checks if an event is a touch event
	 * 
	 * @param {object} event
	 * @returns {boolean}
	 * @protected
	 */
	_touchIsTouchEvent: function(event){
		return event.type.indexOf('touch') == 0;
	},
	
	/**
	 * Store touch events for a while to detect swiping and emulated mouse events
	 * 
	 * @param {object} event
	 * @returns {self}
	 * @protected
	 */
	_touchRecordEvent: function(event) {
		
		if (this._touchIsTouchEvent(event)) {
			event.time = new Date().getTime();
			this.__touchEvents.push(event);
		}
		
		return this;
	},
	
	/**
	 * Returns true if a swipe happened after the last touchstart event fired on
	 * event.target.
	 * 
	 * We need to differentiate a swipe from a tap before we let the event open
	 * or close the tooltip. A swipe is when a touchmove (scroll) event happens
	 * on the body between the touchstart and the touchend events of an element.
	 * 
	 * @param {object} target The HTML element that may have triggered the swipe
	 * @returns {boolean}
	 * @protected
	 */
	_touchSwiped: function(target) {
		
		var swiped = false;
		
		for (var i = this.__touchEvents.length - 1; i >= 0; i--) {
			
			var e = this.__touchEvents[i];
			
			if (e.type == 'touchmove') {
				swiped = true;
				break;
			}
			else if (
				e.type == 'touchstart'
				&&	target === e.target
			) {
				break;
			}
		}
		
		return swiped;
	},
	
	/**
	 * Triggers an event on the instance emitters
	 * 
	 * @returns {self}
	 * @protected
	 */
	_trigger: function() {
		
		var args = Array.prototype.slice.apply(arguments);
		
		if (typeof args[0] == 'string') {
			args[0] = { type: args[0] };
		}
		
		// add properties to the event
		args[0].instance = this;
		args[0].origin = this._$origin ? this._$origin[0] : null;
		args[0].tooltip = this._$tooltip ? this._$tooltip[0] : null;
		
		// note: the order of emitters matters
		this.__$emitterPrivate.trigger.apply(this.__$emitterPrivate, args);
		$.tooltipster._trigger.apply($.tooltipster, args);
		this.__$emitterPublic.trigger.apply(this.__$emitterPublic, args);
		
		return this;
	},
	
	/**
	 * Deactivate a plugin on this instance
	 * 
	 * @returns {self}
	 * @protected
	 */
	_unplug: function(pluginName) {
		
		var self = this;
		
		// if the plugin has been activated on this instance
		if (self[pluginName]) {
			
			var plugin = $.tooltipster._plugin(pluginName);
			
			// if there is a constructor for instances
			if (plugin.instance) {
				
				// unbridge
				$.each(plugin.instance, function(methodName, fn) {
					
					// if the method exists (privates methods do not) and comes indeed from
					// this plugin (may be missing or come from a conflicting plugin).
					if (	self[methodName]
						&&	self[methodName].bridged === self[pluginName]
					) {
						delete self[methodName];
					}
				});
			}
			
			// destroy the plugin
			if (self[pluginName].__destroy) {
				self[pluginName].__destroy();
			}
			
			// remove the reference to the plugin instance
			delete self[pluginName];
		}
		
		return self;
	},
	
	/**
	 * @see self::_close
	 * @returns {self}
	 * @public
	 */
	close: function(callback) {
		
		if (!this.__destroyed) {
			this._close(null, callback);
		}
		else {
			this.__destroyError();
		}
		
		return this;
	},
	
	/**
	 * Sets or gets the content of the tooltip
	 * 
	 * @returns {mixed|self}
	 * @public
	 */
	content: function(content) {
		
		var self = this;
		
		// getter method
		if (content === undefined) {
			return self.__Content;
		}
		// setter method
		else {
			
			if (!self.__destroyed) {
				
				// change the content
				self.__contentSet(content);
				
				if (self.__Content !== null) {
					
					// update the tooltip if it is open
					if (self.__state !== 'closed') {
						
						// reset the content in the tooltip
						self.__contentInsert();
						
						// reposition and resize the tooltip
						self.reposition();
						
						// if we want to play a little animation showing the content changed
						if (self.__options.updateAnimation) {
							
							if (env.hasTransitions) {
								
								// keep the reference in the local scope
								var animation = self.__options.updateAnimation;
								
								self._$tooltip.addClass('tooltipster-update-'+ animation);
								
								// remove the class after a while. The actual duration of the
								// update animation may be shorter, it's set in the CSS rules
								setTimeout(function() {
									
									if (self.__state != 'closed') {
										
										self._$tooltip.removeClass('tooltipster-update-'+ animation);
									}
								}, 1000);
							}
							else {
								self._$tooltip.fadeTo(200, 0.5, function() {
									if (self.__state != 'closed') {
										self._$tooltip.fadeTo(200, 1);
									}
								});
							}
						}
					}
				}
				else {
					self._close();
				}
			}
			else {
				self.__destroyError();
			}
			
			return self;
		}
	},
	
	/**
	 * Destroys the tooltip
	 * 
	 * @returns {self}
	 * @public
	 */
	destroy: function() {
		
		var self = this;
		
		if (!self.__destroyed) {
			
			if(self.__state != 'closed'){
				
				// no closing delay
				self.option('animationDuration', 0)
					// force closing
					._close(null, null, true);
			}
			else {
				// there might be an open timeout still running
				self.__timeoutsClear();
			}
			
			// send event
			self._trigger('destroy');
			
			self.__destroyed = true;
			
			self._$origin
				.removeData(self.__namespace)
				// remove the open trigger listeners
				.off('.'+ self.__namespace +'-triggerOpen');
			
			// remove the touch listener
			$(env.window.document.body).off('.' + self.__namespace +'-triggerOpen');
			
			var ns = self._$origin.data('tooltipster-ns');
			
			// if the origin has been removed from DOM, its data may
			// well have been destroyed in the process and there would
			// be nothing to clean up or restore
			if (ns) {
				
				// if there are no more tooltips on this element
				if (ns.length === 1) {
					
					// optional restoration of a title attribute
					var title = null;
					if (self.__options.restoration == 'previous') {
						title = self._$origin.data('tooltipster-initialTitle');
					}
					else if (self.__options.restoration == 'current') {
						
						// old school technique to stringify when outerHTML is not supported
						title = (typeof self.__Content == 'string') ?
							self.__Content :
							$('<div></div>').append(self.__Content).html();
					}
					
					if (title) {
						self._$origin.attr('title', title);
					}
					
					// final cleaning
					
					self._$origin.removeClass('tooltipstered');
					
					self._$origin
						.removeData('tooltipster-ns')
						.removeData('tooltipster-initialTitle');
				}
				else {
					// remove the instance namespace from the list of namespaces of
					// tooltips present on the element
					ns = $.grep(ns, function(el, i) {
						return el !== self.__namespace;
					});
					self._$origin.data('tooltipster-ns', ns);
				}
			}
			
			// last event
			self._trigger('destroyed');
			
			// unbind private and public event listeners
			self._off();
			self.off();
			
			// remove external references, just in case
			self.__Content = null;
			self.__$emitterPrivate = null;
			self.__$emitterPublic = null;
			self.__options.parent = null;
			self._$origin = null;
			self._$tooltip = null;
			
			// make sure the object is no longer referenced in there to prevent
			// memory leaks
			$.tooltipster.__instancesLatestArr = $.grep($.tooltipster.__instancesLatestArr, function(el, i) {
				return self !== el;
			});
			
			clearInterval(self.__garbageCollector);
		}
		else {
			self.__destroyError();
		}
		
		// we return the scope rather than true so that the call to
		// .tooltipster('destroy') actually returns the matched elements
		// and applies to all of them
		return self;
	},
	
	/**
	 * Disables the tooltip
	 * 
	 * @returns {self}
	 * @public
	 */
	disable: function() {
		
		if (!this.__destroyed) {
			
			// close first, in case the tooltip would not disappear on
			// its own (no close trigger)
			this._close();
			this.__enabled = false;
			
			return this;
		}
		else {
			this.__destroyError();
		}
		
		return this;
	},
	
	/**
	 * Returns the HTML element of the origin
	 *
	 * @returns {self}
	 * @public
	 */
	elementOrigin: function() {
		
		if (!this.__destroyed) {
			return this._$origin[0];
		}
		else {
			this.__destroyError();
		}
	},
	
	/**
	 * Returns the HTML element of the tooltip
	 *
	 * @returns {self}
	 * @public
	 */
	elementTooltip: function() {
		return this._$tooltip ? this._$tooltip[0] : null;
	},
	
	/**
	 * Enables the tooltip
	 * 
	 * @returns {self}
	 * @public
	 */
	enable: function() {
		this.__enabled = true;
		return this;
	},
	
	/**
	 * Alias, deprecated in 4.0.0
	 * 
	 * @param {function} callback
	 * @returns {self}
	 * @public
	 */
	hide: function(callback) {
		return this.close(callback);
	},
	
	/**
	 * Returns the instance
	 * 
	 * @returns {self}
	 * @public
	 */
	instance: function() {
		return this;
	},
	
	/**
	 * For public use only, not to be used by plugins (use ::_off() instead)
	 * 
	 * @returns {self}
	 * @public
	 */
	off: function() {
		
		if (!this.__destroyed) {
			this.__$emitterPublic.off.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
		}
		
		return this;
	},
	
	/**
	 * For public use only, not to be used by plugins (use ::_on() instead)
	 *
	 * @returns {self}
	 * @public
	 */
	on: function() {
		
		if (!this.__destroyed) {
			this.__$emitterPublic.on.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
		}
		else {
			this.__destroyError();
		}
		
		return this;
	},
	
	/**
	 * For public use only, not to be used by plugins
	 *
	 * @returns {self}
	 * @public
	 */
	one: function() {
		
		if (!this.__destroyed) {
			this.__$emitterPublic.one.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
		}
		else {
			this.__destroyError();
		}
		
		return this;
	},
	
	/**
	 * @see self::_open
	 * @returns {self}
	 * @public
	 */
	open: function(callback) {
		
		if (!this.__destroyed) {
			this._open(null, callback);
		}
		else {
			this.__destroyError();
		}
		
		return this;
	},
	
	/**
	 * Get or set options. For internal use and advanced users only.
	 * 
	 * @param {string} o Option name
	 * @param {mixed} val optional A new value for the option
	 * @return {mixed|self} If val is omitted, the value of the option
	 * is returned, otherwise the instance itself is returned
	 * @public
	 */ 
	option: function(o, val) {
		
		// getter
		if (val === undefined) {
			return this.__options[o];
		}
		// setter
		else {
			
			if (!this.__destroyed) {
				
				// change value
				this.__options[o] = val;
				
				// format
				this.__optionsFormat();
				
				// re-prepare the triggers if needed
				if ($.inArray(o, ['trigger', 'triggerClose', 'triggerOpen']) >= 0) {
					this.__prepareOrigin();
				}
				
				if (o === 'selfDestruction') {
					this.__prepareGC();
				}
			}
			else {
				this.__destroyError();
			}
			
			return this;
		}
	},
	
	/**
	 * This method is in charge of setting the position and size properties of the tooltip.
	 * All the hard work is delegated to the display plugin.
	 * Note: The tooltip may be detached from the DOM at the moment the method is called 
	 * but must be attached by the end of the method call.
	 * 
	 * @param {object} event For internal use only. Defined if an event such as
	 * window resizing triggered the repositioning
	 * @param {boolean} tooltipIsDetached For internal use only. Set this to true if you
	 * know that the tooltip not being in the DOM is not an issue (typically when the
	 * tooltip element has just been created but has not been added to the DOM yet).
	 * @returns {self}
	 * @public
	 */
	reposition: function(event, tooltipIsDetached) {
		
		var self = this;
		
		if (!self.__destroyed) {
			
			// if the tooltip is still open and the origin is still in the DOM
			if (self.__state != 'closed' && bodyContains(self._$origin)) {
				
				// if the tooltip has not been removed from DOM manually (or if it
				// has been detached on purpose)
				if (tooltipIsDetached || bodyContains(self._$tooltip)) {
					
					if (!tooltipIsDetached) {
						// detach in case the tooltip overflows the window and adds
						// scrollbars to it, so __geometry can be accurate
						self._$tooltip.detach();
					}
					
					// refresh the geometry object before passing it as a helper
					self.__Geometry = self.__geometry();
					
					// let a plugin fo the rest
					self._trigger({
						type: 'reposition',
						event: event,
						helper: {
							geo: self.__Geometry
						}
					});
				}
			}
		}
		else {
			self.__destroyError();
		}
		
		return self;
	},
	
	/**
	 * Alias, deprecated in 4.0.0
	 *
	 * @param callback
	 * @returns {self}
	 * @public
	 */
	show: function(callback) {
		return this.open(callback);
	},
	
	/**
	 * Returns some properties about the instance
	 * 
	 * @returns {object}
	 * @public
	 */
	status: function() {
		
		return {
			destroyed: this.__destroyed,
			enabled: this.__enabled,
			open: this.__state !== 'closed',
			state: this.__state
		};
	},
	
	/**
	 * For public use only, not to be used by plugins
	 *
	 * @returns {self}
	 * @public
	 */
	triggerHandler: function() {
		
		if (!this.__destroyed) {
			this.__$emitterPublic.triggerHandler.apply(this.__$emitterPublic, Array.prototype.slice.apply(arguments));
		}
		else {
			this.__destroyError();
		}
		
		return this;
	}
};

$.fn.tooltipster = function() {
	
	// for using in closures
	var args = Array.prototype.slice.apply(arguments),
		// common mistake: an HTML element can't be in several tooltips at the same time
		contentCloningWarning = 'You are using a single HTML element as content for several tooltips. You probably want to set the contentCloning option to TRUE.';
	
	// this happens with $(sel).tooltipster(...) when $(sel) does not match anything
	if (this.length === 0) {
		
		// still chainable
		return this;
	}
	// this happens when calling $(sel).tooltipster('methodName or options')
	// where $(sel) matches one or more elements
	else {
		
		// method calls
		if (typeof args[0] === 'string') {
			
			var v = '#*$~&';
			
			this.each(function() {
				
				// retrieve the namepaces of the tooltip(s) that exist on that element.
				// We will interact with the first tooltip only.
				var ns = $(this).data('tooltipster-ns'),
					// self represents the instance of the first tooltipster plugin
					// associated to the current HTML object of the loop
					self = ns ? $(this).data(ns[0]) : null;
				
				// if the current element holds a tooltipster instance
				if (self) {
					
					if (typeof self[args[0]] === 'function') {
						
						if (	this.length > 1
							&&	args[0] == 'content'
							&&	(	args[1] instanceof $
								|| (typeof args[1] == 'object' && args[1] != null && args[1].tagName)
							)
							&&	!self.__options.contentCloning
							&&	self.__options.debug
						) {
							console.log(contentCloningWarning);
						}
						
						// note : args[1] and args[2] may not be defined
						var resp = self[args[0]](args[1], args[2]);
					}
					else {
						throw new Error('Unknown method "'+ args[0] +'"');
					}
					
					// if the function returned anything other than the instance
					// itself (which implies chaining, except for the `instance` method)
					if (resp !== self || args[0] === 'instance') {
						
						v = resp;
						
						// return false to stop .each iteration on the first element
						// matched by the selector
						return false;
					}
				}
				else {
					throw new Error('You called Tooltipster\'s "'+ args[0] +'" method on an uninitialized element');
				}
			});
			
			return (v !== '#*$~&') ? v : this;
		}
		// first argument is undefined or an object: the tooltip is initializing
		else {
			
			// reset the array of last initialized objects
			$.tooltipster.__instancesLatestArr = [];
			
			// is there a defined value for the multiple option in the options object ?
			var	multipleIsSet = args[0] && args[0].multiple !== undefined,
				// if the multiple option is set to true, or if it's not defined but
				// set to true in the defaults
				multiple = (multipleIsSet && args[0].multiple) || (!multipleIsSet && defaults.multiple),
				// same for content
				contentIsSet = args[0] && args[0].content !== undefined,
				content = (contentIsSet && args[0].content) || (!contentIsSet && defaults.content),
				// same for contentCloning
				contentCloningIsSet = args[0] && args[0].contentCloning !== undefined,
				contentCloning =
						(contentCloningIsSet && args[0].contentCloning)
					||	(!contentCloningIsSet && defaults.contentCloning),
				// same for debug
				debugIsSet = args[0] && args[0].debug !== undefined,
				debug = (debugIsSet && args[0].debug) || (!debugIsSet && defaults.debug);
			
			if (	this.length > 1
				&&	(	content instanceof $
					|| (typeof content == 'object' && content != null && content.tagName)
				)
				&&	!contentCloning
				&&	debug
			) {
				console.log(contentCloningWarning);
			}
			
			// create a tooltipster instance for each element if it doesn't
			// already have one or if the multiple option is set, and attach the
			// object to it
			this.each(function() {
				
				var go = false,
					$this = $(this),
					ns = $this.data('tooltipster-ns'),
					obj = null;
				
				if (!ns) {
					go = true;
				}
				else if (multiple) {
					go = true;
				}
				else if (debug) {
					console.log('Tooltipster: one or more tooltips are already attached to the element below. Ignoring.');
					console.log(this);
				}
				
				if (go) {
					obj = new $.Tooltipster(this, args[0]);
					
					// save the reference of the new instance
					if (!ns) ns = [];
					ns.push(obj.__namespace);
					$this.data('tooltipster-ns', ns);
					
					// save the instance itself
					$this.data(obj.__namespace, obj);
					
					// call our constructor custom function.
					// we do this here and not in ::init() because we wanted
					// the object to be saved in $this.data before triggering
					// it
					if (obj.__options.functionInit) {
						obj.__options.functionInit.call(obj, obj, {
							origin: this
						});
					}
					
					// and now the event, for the plugins and core emitter
					obj._trigger('init');
				}
				
				$.tooltipster.__instancesLatestArr.push(obj);
			});
			
			return this;
		}
	}
};

// Utilities

/**
 * A class to check if a tooltip can fit in given dimensions
 * 
 * @param {object} $tooltip The jQuery wrapped tooltip element, or a clone of it
 */
function Ruler($tooltip) {
	
	// list of instance variables
	
	this.$container;
	this.constraints = null;
	this.__$tooltip;
	
	this.__init($tooltip);
}

Ruler.prototype = {
	
	/**
	 * Move the tooltip into an invisible div that does not allow overflow to make
	 * size tests. Note: the tooltip may or may not be attached to the DOM at the
	 * moment this method is called, it does not matter.
	 * 
	 * @param {object} $tooltip The object to test. May be just a clone of the
	 * actual tooltip.
	 * @private
	 */
	__init: function($tooltip) {
		
		this.__$tooltip = $tooltip;
		
		this.__$tooltip
			.css({
				// for some reason we have to specify top and left 0
				left: 0,
				// any overflow will be ignored while measuring
				overflow: 'hidden',
				// positions at (0,0) without the div using 100% of the available width
				position: 'absolute',
				top: 0
			})
			// overflow must be auto during the test. We re-set this in case
			// it were modified by the user
			.find('.tooltipster-content')
				.css('overflow', 'auto');
		
		this.$container = $('<div class="tooltipster-ruler"></div>')
			.append(this.__$tooltip)
			.appendTo(env.window.document.body);
	},
	
	/**
	 * Force the browser to redraw (re-render) the tooltip immediately. This is required
	 * when you changed some CSS properties and need to make something with it
	 * immediately, without waiting for the browser to redraw at the end of instructions.
	 *
	 * @see http://stackoverflow.com/questions/3485365/how-can-i-force-webkit-to-redraw-repaint-to-propagate-style-changes
	 * @private
	 */
	__forceRedraw: function() {
		
		// note: this would work but for Webkit only
		//this.__$tooltip.close();
		//this.__$tooltip[0].offsetHeight;
		//this.__$tooltip.open();
		
		// works in FF too
		var $p = this.__$tooltip.parent();
		this.__$tooltip.detach();
		this.__$tooltip.appendTo($p);
	},
	
	/**
	 * Set maximum dimensions for the tooltip. A call to ::measure afterwards
	 * will tell us if the content overflows or if it's ok
	 *
	 * @param {int} width
	 * @param {int} height
	 * @return {Ruler}
	 * @public
	 */
	constrain: function(width, height) {
		
		this.constraints = {
			width: width,
			height: height
		};
		
		this.__$tooltip.css({
			// we disable display:flex, otherwise the content would overflow without
			// creating horizontal scrolling (which we need to detect).
			display: 'block',
			// reset any previous height
			height: '',
			// we'll check if horizontal scrolling occurs
			overflow: 'auto',
			// we'll set the width and see what height is generated and if there
			// is horizontal overflow
			width: width
		});
		
		return this;
	},
	
	/**
	 * Reset the tooltip content overflow and remove the test container
	 * 
	 * @returns {Ruler}
	 * @public
	 */
	destroy: function() {
		
		// in case the element was not a clone
		this.__$tooltip
			.detach()
			.find('.tooltipster-content')
				.css({
					// reset to CSS value
					display: '',
					overflow: ''
				});
		
		this.$container.remove();
	},
	
	/**
	 * Removes any constraints
	 * 
	 * @returns {Ruler}
	 * @public
	 */
	free: function() {
		
		this.constraints = null;
		
		// reset to natural size
		this.__$tooltip.css({
			display: '',
			height: '',
			overflow: 'visible',
			width: ''
		});
		
		return this;
	},
	
	/**
	 * Returns the size of the tooltip. When constraints are applied, also returns
	 * whether the tooltip fits in the provided dimensions.
	 * The idea is to see if the new height is small enough and if the content does
	 * not overflow horizontally.
	 *
	 * @param {int} width
	 * @param {int} height
	 * @returns {object} An object with a bool `fits` property and a `size` property
	 * @public
	 */
	measure: function() {
		
		this.__forceRedraw();
		
		var tooltipBcr = this.__$tooltip[0].getBoundingClientRect(),
			result = { size: {
				// bcr.width/height are not defined in IE8- but in this
				// case, bcr.right/bottom will have the same value
				// except in iOS 8+ where tooltipBcr.bottom/right are wrong
				// after scrolling for reasons yet to be determined.
				// tooltipBcr.top/left might not be 0, see issue #514
				height: tooltipBcr.height || (tooltipBcr.bottom - tooltipBcr.top),
				width: tooltipBcr.width || (tooltipBcr.right - tooltipBcr.left)
			}};
		
		if (this.constraints) {
			
			// note: we used to use offsetWidth instead of boundingRectClient but
			// it returned rounded values, causing issues with sub-pixel layouts.
			
			// note2: noticed that the bcrWidth of text content of a div was once
			// greater than the bcrWidth of its container by 1px, causing the final
			// tooltip box to be too small for its content. However, evaluating
			// their widths one against the other (below) surprisingly returned
			// equality. Happened only once in Chrome 48, was not able to reproduce
			// => just having fun with float position values...
			
			var $content = this.__$tooltip.find('.tooltipster-content'),
				height = this.__$tooltip.outerHeight(),
				contentBcr = $content[0].getBoundingClientRect(),
				fits = {
					height: height <= this.constraints.height,
					width: (
						// this condition accounts for min-width property that
						// may apply
						tooltipBcr.width <= this.constraints.width
							// the -1 is here because scrollWidth actually returns
							// a rounded value, and may be greater than bcr.width if
							// it was rounded up. This may cause an issue for contents
							// which actually really overflow  by 1px or so, but that
							// should be rare. Not sure how to solve this efficiently.
							// See http://blogs.msdn.com/b/ie/archive/2012/02/17/sub-pixel-rendering-and-the-css-object-model.aspx
						&&	contentBcr.width >= $content[0].scrollWidth - 1
					)
				};
			
			result.fits = fits.height && fits.width;
		}
		
		// old versions of IE get the width wrong for some reason and it causes
		// the text to be broken to a new line, so we round it up. If the width
		// is the width of the screen though, we can assume it is accurate.
		if (	env.IE
			&&	env.IE <= 11
			&&	result.size.width !== env.window.document.documentElement.clientWidth
		) {
			result.size.width = Math.ceil(result.size.width) + 1;
		}
		
		return result;
	}
};

// quick & dirty compare function, not bijective nor multidimensional
function areEqual(a,b) {
	var same = true;
	$.each(a, function(i, _) {
		if (b[i] === undefined || a[i] !== b[i]) {
			same = false;
			return false;
		}
	});
	return same;
}

/**
 * A fast function to check if an element is still in the DOM. It
 * tries to use an id as ids are indexed by the browser, or falls
 * back to jQuery's `contains` method. May fail if two elements
 * have the same id, but so be it
 *
 * @param {object} $obj A jQuery-wrapped HTML element
 * @return {boolean}
 */
function bodyContains($obj) {
	var id = $obj.attr('id'),
		el = id ? env.window.document.getElementById(id) : null;
	// must also check that the element with the id is the one we want
	return el ? el === $obj[0] : $.contains(env.window.document.body, $obj[0]);
}

// detect IE versions for dirty fixes
var uA = navigator.userAgent.toLowerCase();
if (uA.indexOf('msie') != -1) env.IE = parseInt(uA.split('msie')[1]);
else if (uA.toLowerCase().indexOf('trident') !== -1 && uA.indexOf(' rv:11') !== -1) env.IE = 11;
else if (uA.toLowerCase().indexOf('edge/') != -1) env.IE = parseInt(uA.toLowerCase().split('edge/')[1]);

// detecting support for CSS transitions
function transitionSupport() {
	
	// env.window is not defined yet when this is called
	if (!win) return false;
	
	var b = win.document.body || win.document.documentElement,
		s = b.style,
		p = 'transition',
		v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];
	
	if (typeof s[p] == 'string') { return true; }
	
	p = p.charAt(0).toUpperCase() + p.substr(1);
	for (var i=0; i<v.length; i++) {
		if (typeof s[v[i] + p] == 'string') { return true; }
	}
	return false;
}

// we'll return jQuery for plugins not to have to declare it as a dependency,
// but it's done by a build task since it should be included only once at the
// end when we concatenate the main file with a plugin
// sideTip is Tooltipster's default plugin.
// This file will be UMDified by a build task.

var pluginName = 'tooltipster.sideTip';

$.tooltipster._plugin({
	name: pluginName,
	instance: {
		/**
		 * Defaults are provided as a function for an easy override by inheritance
		 *
		 * @return {object} An object with the defaults options
		 * @private
		 */
		__defaults: function() {
			
			return {
				// if the tooltip should display an arrow that points to the origin
				arrow: true,
				// the distance in pixels between the tooltip and the origin
				distance: 6,
				// allows to easily change the position of the tooltip
				functionPosition: null,
				maxWidth: null,
				// used to accomodate the arrow of tooltip if there is one.
				// First to make sure that the arrow target is not too close
				// to the edge of the tooltip, so the arrow does not overflow
				// the tooltip. Secondly when we reposition the tooltip to
				// make sure that it's positioned in such a way that the arrow is
				// still pointing at the target (and not a few pixels beyond it).
				// It should be equal to or greater than half the width of
				// the arrow (by width we mean the size of the side which touches
				// the side of the tooltip).
				minIntersection: 16,
				minWidth: 0,
				// deprecated in 4.0.0. Listed for _optionsExtract to pick it up
				position: null,
				side: 'top',
				// set to false to position the tooltip relatively to the document rather
				// than the window when we open it
				viewportAware: true
			};
		},
		
		/**
		 * Run once: at instantiation of the plugin
		 *
		 * @param {object} instance The tooltipster object that instantiated this plugin
		 * @private
		 */
		__init: function(instance) {
			
			var self = this;
			
			// list of instance variables
			
			self.__instance = instance;
			self.__namespace = 'tooltipster-sideTip-'+ Math.round(Math.random()*1000000);
			self.__previousState = 'closed';
			self.__options;
			
			// initial formatting
			self.__optionsFormat();
			
			self.__instance._on('state.'+ self.__namespace, function(event) {
				
				if (event.state == 'closed') {
					self.__close();
				}
				else if (event.state == 'appearing' && self.__previousState == 'closed') {
					self.__create();
				}
				
				self.__previousState = event.state;
			});
			
			// reformat every time the options are changed
			self.__instance._on('options.'+ self.__namespace, function() {
				self.__optionsFormat();
			});
			
			self.__instance._on('reposition.'+ self.__namespace, function(e) {
				self.__reposition(e.event, e.helper);
			});
		},
		
		/**
		 * Called when the tooltip has closed
		 * 
		 * @private
		 */
		__close: function() {
			
			// detach our content object first, so the next jQuery's remove()
			// call does not unbind its event handlers
			if (this.__instance.content() instanceof $) {
				this.__instance.content().detach();
			}
			
			// remove the tooltip from the DOM
			this.__instance._$tooltip.remove();
			this.__instance._$tooltip = null;
		},
		
		/**
		 * Creates the HTML element of the tooltip.
		 * 
		 * @private
		 */
		__create: function() {
			
			// note: we wrap with a .tooltipster-box div to be able to set a margin on it
			// (.tooltipster-base must not have one)
			var $html = $(
				'<div class="tooltipster-base tooltipster-sidetip">' +
					'<div class="tooltipster-box">' +
						'<div class="tooltipster-content"></div>' +
					'</div>' +
					'<div class="tooltipster-arrow">' +
						'<div class="tooltipster-arrow-uncropped">' +
							'<div class="tooltipster-arrow-border"></div>' +
							'<div class="tooltipster-arrow-background"></div>' +
						'</div>' +
					'</div>' +
				'</div>'
			);
			
			// hide arrow if asked
			if (!this.__options.arrow) {
				$html
					.find('.tooltipster-box')
						.css('margin', 0)
						.end()
					.find('.tooltipster-arrow')
						.hide();
			}
			
			// apply min/max width if asked
			if (this.__options.minWidth) {
				$html.css('min-width', this.__options.minWidth + 'px');
			}
			if (this.__options.maxWidth) {
				$html.css('max-width', this.__options.maxWidth + 'px');
			}
			
			this.__instance._$tooltip = $html;
			
			// tell the instance that the tooltip element has been created
			this.__instance._trigger('created');
		},
		
		/**
		 * Used when the plugin is to be unplugged
		 *
		 * @private
		 */
		__destroy: function() {
			this.__instance._off('.'+ self.__namespace);
		},
		
		/**
		 * (Re)compute this.__options from the options declared to the instance
		 *
		 * @private
		 */
		__optionsFormat: function() {
			
			var self = this;
			
			// get the options
			self.__options = self.__instance._optionsExtract(pluginName, self.__defaults());
			
			// for backward compatibility, deprecated in v4.0.0
			if (self.__options.position) {
				self.__options.side = self.__options.position;
			}
			
			// options formatting
			
			// format distance as a four-cell array if it ain't one yet and then make
			// it an object with top/bottom/left/right properties
			if (typeof self.__options.distance != 'object') {
				self.__options.distance = [self.__options.distance];
			}
			if (self.__options.distance.length < 4) {
				if (self.__options.distance[1] === undefined) self.__options.distance[1] = self.__options.distance[0];
				if (self.__options.distance[2] === undefined) self.__options.distance[2] = self.__options.distance[0];
				if (self.__options.distance[3] === undefined) self.__options.distance[3] = self.__options.distance[1];
			}
			
			self.__options.distance = {
				top: self.__options.distance[0],
				right: self.__options.distance[1],
				bottom: self.__options.distance[2],
				left: self.__options.distance[3]
			};
			
			// let's transform:
			// 'top' into ['top', 'bottom', 'right', 'left']
			// 'right' into ['right', 'left', 'top', 'bottom']
			// 'bottom' into ['bottom', 'top', 'right', 'left']
			// 'left' into ['left', 'right', 'top', 'bottom']
			if (typeof self.__options.side == 'string') {
				
				var opposites = {
					'top': 'bottom',
					'right': 'left',
					'bottom': 'top',
					'left': 'right'
				};
				
				self.__options.side = [self.__options.side, opposites[self.__options.side]];
				
				if (self.__options.side[0] == 'left' || self.__options.side[0] == 'right') {
					self.__options.side.push('top', 'bottom');
				}
				else {
					self.__options.side.push('right', 'left');
				}
			}
			
			// misc
			// disable the arrow in IE6 unless the arrow option was explicitly set to true
			if (	$.tooltipster._env.IE === 6
				&&	self.__options.arrow !== true
			) {
				self.__options.arrow = false;
			}
		},
		
		/**
		 * This method must compute and set the positioning properties of the
		 * tooltip (left, top, width, height, etc.). It must also make sure the
		 * tooltip is eventually appended to its parent (since the element may be
		 * detached from the DOM at the moment the method is called).
		 *
		 * We'll evaluate positioning scenarios to find which side can contain the
		 * tooltip in the best way. We'll consider things relatively to the window
		 * (unless the user asks not to), then to the document (if need be, or if the
		 * user explicitly requires the tests to run on the document). For each
		 * scenario, measures are taken, allowing us to know how well the tooltip
		 * is going to fit. After that, a sorting function will let us know what
		 * the best scenario is (we also allow the user to choose his favorite
		 * scenario by using an event).
		 * 
		 * @param {object} helper An object that contains variables that plugin
		 * creators may find useful (see below)
		 * @param {object} helper.geo An object with many layout properties
		 * about objects of interest (window, document, origin). This should help
		 * plugin users compute the optimal position of the tooltip
		 * @private
		 */
		__reposition: function(event, helper) {
			
			var self = this,
				finalResult,
				// to know where to put the tooltip, we need to know on which point
				// of the x or y axis we should center it. That coordinate is the target
				targets = self.__targetFind(helper),
				testResults = [];
			
			// make sure the tooltip is detached while we make tests on a clone
			self.__instance._$tooltip.detach();
			
			// we could actually provide the original element to the Ruler and
			// not a clone, but it just feels right to keep it out of the
			// machinery.
			var $clone = self.__instance._$tooltip.clone(),
				// start position tests session
				ruler = $.tooltipster._getRuler($clone),
				satisfied = false,
				animation = self.__instance.option('animation');
			
			// an animation class could contain properties that distort the size
			if (animation) {
				$clone.removeClass('tooltipster-'+ animation);
			}
			
			// start evaluating scenarios
			$.each(['window', 'document'], function(i, container) {
				
				var takeTest = null;
				
				// let the user decide to keep on testing or not
				self.__instance._trigger({
					container: container,
					helper: helper,
					satisfied: satisfied,
					takeTest: function(bool) {
						takeTest = bool;
					},
					results: testResults,
					type: 'positionTest'
				});
				
				if (	takeTest == true
					||	(	takeTest != false
						&&	satisfied == false
							// skip the window scenarios if asked. If they are reintegrated by
							// the callback of the positionTest event, they will have to be
							// excluded using the callback of positionTested
						&&	(container != 'window' || self.__options.viewportAware)
					)
				) {
					
					// for each allowed side
					for (var i=0; i < self.__options.side.length; i++) {
						
						var distance = {
								horizontal: 0,
								vertical: 0
							},
							side = self.__options.side[i];
						
						if (side == 'top' || side == 'bottom') {
							distance.vertical = self.__options.distance[side];
						}
						else {
							distance.horizontal = self.__options.distance[side];
						}
						
						// this may have an effect on the size of the tooltip if there are css
						// rules for the arrow or something else
						self.__sideChange($clone, side);
						
						$.each(['natural', 'constrained'], function(i, mode) {
							
							takeTest = null;
							
							// emit an event on the instance
							self.__instance._trigger({
								container: container,
								event: event,
								helper: helper,
								mode: mode,
								results: testResults,
								satisfied: satisfied,
								side: side,
								takeTest: function(bool) {
									takeTest = bool;
								},
								type: 'positionTest'
							});
							
							if (	takeTest == true
								||	(	takeTest != false
									&&	satisfied == false
								)
							) {
								
								var testResult = {
									container: container,
									// we let the distance as an object here, it can make things a little easier
									// during the user's calculations at positionTest/positionTested
									distance: distance,
									// whether the tooltip can fit in the size of the viewport (does not mean
									// that we'll be able to make it initially entirely visible, see 'whole')
									fits: null,
									mode: mode,
									outerSize: null,
									side: side,
									size: null,
									target: targets[side],
									// check if the origin has enough surface on screen for the tooltip to
									// aim at it without overflowing the viewport (this is due to the thickness
									// of the arrow represented by the minIntersection length).
									// If not, the tooltip will have to be partly or entirely off screen in
									// order to stay docked to the origin. This value will stay null when the
									// container is the document, as it is not relevant
									whole: null
								};
								
								// get the size of the tooltip with or without size constraints
								var rulerConfigured = (mode == 'natural') ?
										ruler.free() :
										ruler.constrain(
											helper.geo.available[container][side].width - distance.horizontal,
											helper.geo.available[container][side].height - distance.vertical
										),
									rulerResults = rulerConfigured.measure();
								
								testResult.size = rulerResults.size;
								testResult.outerSize = {
									height: rulerResults.size.height + distance.vertical,
									width: rulerResults.size.width + distance.horizontal
								};
								
								if (mode == 'natural') {
									
									if(		helper.geo.available[container][side].width >= testResult.outerSize.width
										&&	helper.geo.available[container][side].height >= testResult.outerSize.height
									) {
										testResult.fits = true;
									}
									else {
										testResult.fits = false;
									}
								}
								else {
									testResult.fits = rulerResults.fits;
								}
								
								if (container == 'window') {
									
									if (!testResult.fits) {
										testResult.whole = false;
									}
									else {
										if (side == 'top' || side == 'bottom') {
											
											testResult.whole = (
													helper.geo.origin.windowOffset.right >= self.__options.minIntersection
												&&	helper.geo.window.size.width - helper.geo.origin.windowOffset.left >= self.__options.minIntersection
											);
										}
										else {
											testResult.whole = (
													helper.geo.origin.windowOffset.bottom >= self.__options.minIntersection
												&&	helper.geo.window.size.height - helper.geo.origin.windowOffset.top >= self.__options.minIntersection
											);
										}
									}
								}
								
								testResults.push(testResult);
								
								// we don't need to compute more positions if we have one fully on screen
								if (testResult.whole) {
									satisfied = true;
								}
								else {
									// don't run the constrained test unless the natural width was greater
									// than the available width, otherwise it's pointless as we know it
									// wouldn't fit either
									if (	testResult.mode == 'natural'
										&&	(	testResult.fits
											||	testResult.size.width <= helper.geo.available[container][side].width
										)
									) {
										return false;
									}
								}
							}
						});
					}
				}
			});
			
			// the user may eliminate the unwanted scenarios from testResults, but he's
			// not supposed to alter them at this point. functionPosition and the
			// position event serve that purpose.
			self.__instance._trigger({
				edit: function(r) {
					testResults = r;
				},
				event: event,
				helper: helper,
				results: testResults,
				type: 'positionTested'
			});
			
			/**
			 * Sort the scenarios to find the favorite one.
			 * 
			 * The favorite scenario is when we can fully display the tooltip on screen,
			 * even if it means that the middle of the tooltip is no longer centered on
			 * the middle of the origin (when the origin is near the edge of the screen
			 * or even partly off screen). We want the tooltip on the preferred side,
			 * even if it means that we have to use a constrained size rather than a
			 * natural one (as long as it fits). When the origin is off screen at the top
			 * the tooltip will be positioned at the bottom (if allowed), if the origin
			 * is off screen on the right, it will be positioned on the left, etc.
			 * If there are no scenarios where the tooltip can fit on screen, or if the
			 * user does not want the tooltip to fit on screen (viewportAware == false),
			 * we fall back to the scenarios relative to the document.
			 * 
			 * When the tooltip is bigger than the viewport in either dimension, we stop
			 * looking at the window scenarios and consider the document scenarios only,
			 * with the same logic to find on which side it would fit best.
			 * 
			 * If the tooltip cannot fit the document on any side, we force it at the
			 * bottom, so at least the user can scroll to see it.
 			 */
			testResults.sort(function(a, b) {
				
				// best if it's whole (the tooltip fits and adapts to the viewport)
				if (a.whole && !b.whole) {
					return -1;
				}
				else if (!a.whole && b.whole) {
					return 1;
				}
				else if (a.whole && b.whole) {
					
					var ai = self.__options.side.indexOf(a.side),
						bi = self.__options.side.indexOf(b.side);
					
					// use the user's sides fallback array
					if (ai < bi) {
						return -1;
					}
					else if (ai > bi) {
						return 1;
					}
					else {
						// will be used if the user forced the tests to continue
						return a.mode == 'natural' ? -1 : 1;
					}
				}
				else {
					
					// better if it fits
					if (a.fits && !b.fits) {
						return -1;
					}
					else if (!a.fits && b.fits) {
						return 1;
					}
					else if (a.fits && b.fits) {
						
						var ai = self.__options.side.indexOf(a.side),
							bi = self.__options.side.indexOf(b.side);
						
						// use the user's sides fallback array
						if (ai < bi) {
							return -1;
						}
						else if (ai > bi) {
							return 1;
						}
						else {
							// will be used if the user forced the tests to continue
							return a.mode == 'natural' ? -1 : 1;
						}
					}
					else {
						
						// if everything failed, this will give a preference to the case where
						// the tooltip overflows the document at the bottom
						if (	a.container == 'document'
							&&	a.side == 'bottom'
							&&	a.mode == 'natural'
						) {
							return -1;
						}
						else {
							return 1;
						}
					}
				}
			});
			
			finalResult = testResults[0];
			
			
			// now let's find the coordinates of the tooltip relatively to the window
			finalResult.coord = {};
			
			switch (finalResult.side) {
				
				case 'left':
				case 'right':
					finalResult.coord.top = Math.floor(finalResult.target - finalResult.size.height / 2);
					break;
				
				case 'bottom':
				case 'top':
					finalResult.coord.left = Math.floor(finalResult.target - finalResult.size.width / 2);
					break;
			}
			
			switch (finalResult.side) {
				
				case 'left':
					finalResult.coord.left = helper.geo.origin.windowOffset.left - finalResult.outerSize.width;
					break;
				
				case 'right':
					finalResult.coord.left = helper.geo.origin.windowOffset.right + finalResult.distance.horizontal;
					break;
				
				case 'top':
					finalResult.coord.top = helper.geo.origin.windowOffset.top - finalResult.outerSize.height;
					break;
				
				case 'bottom':
					finalResult.coord.top = helper.geo.origin.windowOffset.bottom + finalResult.distance.vertical;
					break;
			}
			
			// if the tooltip can potentially be contained within the viewport dimensions
			// and that we are asked to make it fit on screen
			if (finalResult.container == 'window') {
				
				// if the tooltip overflows the viewport, we'll move it accordingly (then it will
				// not be centered on the middle of the origin anymore). We only move horizontally
				// for top and bottom tooltips and vice versa.
				if (finalResult.side == 'top' || finalResult.side == 'bottom') {
					
					// if there is an overflow on the left
					if (finalResult.coord.left < 0) {
						
						// prevent the overflow unless the origin itself gets off screen (minus the
						// margin needed to keep the arrow pointing at the target)
						if (helper.geo.origin.windowOffset.right - this.__options.minIntersection >= 0) {
							finalResult.coord.left = 0;
						}
						else {
							finalResult.coord.left = helper.geo.origin.windowOffset.right - this.__options.minIntersection - 1;
						}
					}
					// or an overflow on the right
					else if (finalResult.coord.left > helper.geo.window.size.width - finalResult.size.width) {
						
						if (helper.geo.origin.windowOffset.left + this.__options.minIntersection <= helper.geo.window.size.width) {
							finalResult.coord.left = helper.geo.window.size.width - finalResult.size.width;
						}
						else {
							finalResult.coord.left = helper.geo.origin.windowOffset.left + this.__options.minIntersection + 1 - finalResult.size.width;
						}
					}
				}
				else {
					
					// overflow at the top
					if (finalResult.coord.top < 0) {
						
						if (helper.geo.origin.windowOffset.bottom - this.__options.minIntersection >= 0) {
							finalResult.coord.top = 0;
						}
						else {
							finalResult.coord.top = helper.geo.origin.windowOffset.bottom - this.__options.minIntersection - 1;
						}
					}
					// or at the bottom
					else if (finalResult.coord.top > helper.geo.window.size.height - finalResult.size.height) {
						
						if (helper.geo.origin.windowOffset.top + this.__options.minIntersection <= helper.geo.window.size.height) {
							finalResult.coord.top = helper.geo.window.size.height - finalResult.size.height;
						}
						else {
							finalResult.coord.top = helper.geo.origin.windowOffset.top + this.__options.minIntersection + 1 - finalResult.size.height;
						}
					}
				}
			}
			else {
				
				// there might be overflow here too but it's easier to handle. If there has
				// to be an overflow, we'll make sure it's on the right side of the screen
				// (because the browser will extend the document size if there is an overflow
				// on the right, but not on the left). The sort function above has already
				// made sure that a bottom document overflow is preferred to a top overflow,
				// so we don't have to care about it.
				
				// if there is an overflow on the right
				if (finalResult.coord.left > helper.geo.window.size.width - finalResult.size.width) {
					
					// this may actually create on overflow on the left but we'll fix it in a sec
					finalResult.coord.left = helper.geo.window.size.width - finalResult.size.width;
				}
				
				// if there is an overflow on the left
				if (finalResult.coord.left < 0) {
					
					// don't care if it overflows the right after that, we made our best
					finalResult.coord.left = 0;
				}
			}
			
			
			// submit the positioning proposal to the user function which may choose to change
			// the side, size and/or the coordinates
			
			// first, set the rules that corresponds to the proposed side: it may change
			// the size of the tooltip, and the custom functionPosition may want to detect the
			// size of something before making a decision. So let's make things easier for the
			// implementor
			self.__sideChange($clone, finalResult.side);
			
			// add some variables to the helper
			helper.tooltipClone = $clone[0];
			helper.tooltipParent = self.__instance.option('parent').parent[0];
			// move informative values to the helper
			helper.mode = finalResult.mode;
			helper.whole = finalResult.whole;
			// add some variables to the helper for the functionPosition callback (these
			// will also be added to the event fired by self.__instance._trigger but that's
			// ok, we're just being consistent)
			helper.origin = self.__instance._$origin[0];
			helper.tooltip = self.__instance._$tooltip[0];
			
			// leave only the actionable values in there for functionPosition
			delete finalResult.container;
			delete finalResult.fits;
			delete finalResult.mode;
			delete finalResult.outerSize;
			delete finalResult.whole;
			
			// keep only the distance on the relevant side, for clarity
			finalResult.distance = finalResult.distance.horizontal || finalResult.distance.vertical;
			
			// beginners may not be comfortable with the concept of editing the object
			//  passed by reference, so we provide an edit function and pass a clone
			var finalResultClone = $.extend(true, {}, finalResult);
			
			// emit an event on the instance
			self.__instance._trigger({
				edit: function(result) {
					finalResult = result;
				},
				event: event,
				helper: helper,
				position: finalResultClone,
				type: 'position'
			});
			
			if (self.__options.functionPosition) {
				
				var result = self.__options.functionPosition.call(self, self.__instance, helper, finalResultClone);
				
				if (result) finalResult = result;
			}
			
			// end the positioning tests session (the user might have had a
			// use for it during the position event, now it's over)
			ruler.destroy();
			
			// compute the position of the target relatively to the tooltip root
			// element so we can place the arrow and make the needed adjustments
			var arrowCoord,
				maxVal;
			
			if (finalResult.side == 'top' || finalResult.side == 'bottom') {
				
				arrowCoord = {
					prop: 'left',
					val: finalResult.target - finalResult.coord.left
				};
				maxVal = finalResult.size.width - this.__options.minIntersection;
			}
			else {
				
				arrowCoord = {
					prop: 'top',
					val: finalResult.target - finalResult.coord.top
				};
				maxVal = finalResult.size.height - this.__options.minIntersection;
			}
			
			// cannot lie beyond the boundaries of the tooltip, minus the
			// arrow margin
			if (arrowCoord.val < this.__options.minIntersection) {
				arrowCoord.val = this.__options.minIntersection;
			}
			else if (arrowCoord.val > maxVal) {
				arrowCoord.val = maxVal;
			}
			
			var originParentOffset;
			
			// let's convert the window-relative coordinates into coordinates relative to the
			// future positioned parent that the tooltip will be appended to
			if (helper.geo.origin.fixedLineage) {
				
				// same as windowOffset when the position is fixed
				originParentOffset = helper.geo.origin.windowOffset;
			}
			else {
				
				// this assumes that the parent of the tooltip is located at
				// (0, 0) in the document, typically like when the parent is
				// <body>.
				// If we ever allow other types of parent, .tooltipster-ruler
				// will have to be appended to the parent to inherit css style
				// values that affect the display of the text and such.
				originParentOffset = {
					left: helper.geo.origin.windowOffset.left + helper.geo.window.scroll.left,
					top: helper.geo.origin.windowOffset.top + helper.geo.window.scroll.top
				};
			}
			
			finalResult.coord = {
				left: originParentOffset.left + (finalResult.coord.left - helper.geo.origin.windowOffset.left),
				top: originParentOffset.top + (finalResult.coord.top - helper.geo.origin.windowOffset.top)
			};
			
			// set position values on the original tooltip element
			
			self.__sideChange(self.__instance._$tooltip, finalResult.side);
			
			if (helper.geo.origin.fixedLineage) {
				self.__instance._$tooltip
					.css('position', 'fixed');
			}
			else {
				// CSS default
				self.__instance._$tooltip
					.css('position', '');
			}
			
			self.__instance._$tooltip
				.css({
					left: finalResult.coord.left,
					top: finalResult.coord.top,
					// we need to set a size even if the tooltip is in its natural size
					// because when the tooltip is positioned beyond the width of the body
					// (which is by default the width of the window; it will happen when
					// you scroll the window horizontally to get to the origin), its text
					// content will otherwise break lines at each word to keep up with the
					// body overflow strategy.
					height: finalResult.size.height,
					width: finalResult.size.width
				})
				.find('.tooltipster-arrow')
					.css({
						'left': '',
						'top': ''
					})
					.css(arrowCoord.prop, arrowCoord.val);
			
			// append the tooltip HTML element to its parent
			self.__instance._$tooltip.appendTo(self.__instance.option('parent'));
			
			self.__instance._trigger({
				type: 'repositioned',
				event: event,
				position: finalResult
			});
		},
		
		/**
		 * Make whatever modifications are needed when the side is changed. This has
		 * been made an independant method for easy inheritance in custom plugins based
		 * on this default plugin.
		 *
		 * @param {object} $obj
		 * @param {string} side
		 * @private
		 */
		__sideChange: function($obj, side) {
			
			$obj
				.removeClass('tooltipster-bottom')
				.removeClass('tooltipster-left')
				.removeClass('tooltipster-right')
				.removeClass('tooltipster-top')
				.addClass('tooltipster-'+ side);
		},
		
		/**
		 * Returns the target that the tooltip should aim at for a given side.
		 * The calculated value is a distance from the edge of the window
		 * (left edge for top/bottom sides, top edge for left/right side). The
		 * tooltip will be centered on that position and the arrow will be
		 * positioned there (as much as possible).
		 *
		 * @param {object} helper
		 * @return {integer}
		 * @private
		 */
		__targetFind: function(helper) {
			
			var target = {},
				rects = this.__instance._$origin[0].getClientRects();
			
			// these lines fix a Chrome bug (issue #491)
			if (rects.length > 1) {
				var opacity = this.__instance._$origin.css('opacity');
				if(opacity == 1) {
					this.__instance._$origin.css('opacity', 0.99);
					rects = this.__instance._$origin[0].getClientRects();
					this.__instance._$origin.css('opacity', 1);
				}
			}
			
			// by default, the target will be the middle of the origin
			if (rects.length < 2) {
				
				target.top = Math.floor(helper.geo.origin.windowOffset.left + (helper.geo.origin.size.width / 2));
				target.bottom = target.top;
				
				target.left = Math.floor(helper.geo.origin.windowOffset.top + (helper.geo.origin.size.height / 2));
				target.right = target.left;
			}
			// if multiple client rects exist, the element may be text split
			// up into multiple lines and the middle of the origin may not be
			// best option anymore. We need to choose the best target client rect
			else {
				
				// top: the first
				var targetRect = rects[0];
				target.top = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);
		
				// right: the middle line, rounded down in case there is an even
				// number of lines (looks more centered => check out the
				// demo with 4 split lines)
				if (rects.length > 2) {
					targetRect = rects[Math.ceil(rects.length / 2) - 1];
				}
				else {
					targetRect = rects[0];
				}
				target.right = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);
		
				// bottom: the last
				targetRect = rects[rects.length - 1];
				target.bottom = Math.floor(targetRect.left + (targetRect.right - targetRect.left) / 2);
		
				// left: the middle line, rounded up
				if (rects.length > 2) {
					targetRect = rects[Math.ceil((rects.length + 1) / 2) - 1];
				}
				else {
					targetRect = rects[rects.length - 1];
				}
				
				target.left = Math.floor(targetRect.top + (targetRect.bottom - targetRect.top) / 2);
			}
			
			return target;
		}
	}
});

/* a build task will add "return $;" here */
return $;

}));

/*
   WPM - Wiseman plugin manager
*/

(function( $ ) {

$root = {

   "class": new Array(),

   "prefix": "data-",

   "apply": function(){
      $wpm.setStyles();
      $wpm.setClasses();
   }

};

$wpm = {

   debug: false,
   
   attributes: [$root.prefix+"plugin", $root.prefix+"component", $root.prefix+"toggle", $root.prefix+"click", $root.prefix+"init", $root.prefix+"class", "title"],

   initialize: function(){

      if( $wpm.debug ){
         console.info("jQuery present. Initialization started. So far so good!"); 
      }

      var resizeDelay = 200;
      $root.resizeArray = new Array();
      var resizeDebounce = false;

      $(window).on("resize", function(e){
         clearTimeout(resizeDebounce);

         resizeDebounce = setTimeout(function(){
            for( var i in $root.resizeArray ){
               var functionName = $root.resizeArray[i];
               $(window).trigger("resize:"+functionName);   
            };
         }, resizeDelay);

      }).trigger('resize');
      
      $wpm.bindObjects();
      

      $root.apply();

   },
   
   getAttributes: function( $node ) {
       var attrs = {};
       $.each( $node[0].attributes, function ( index, attribute ) {
           attrs[attribute.name] = attribute.value;
       } );

       return attrs;
   },
   
   bindObjects: function(elem){
      
      var selectorString = '';
      for( var i in $wpm.attributes ){
         if( i > 0 ){ selectorString+=",";}
         selectorString+= "["+$wpm.attributes[i]+"]";
      }
      
      var selector = elem ? elem.find(selectorString) : $(selectorString);

      selector.each(function(){
         var obj = $(this);
         
         var objectAttrs = $wpm.getAttributes( obj );

         for(var i in $wpm.getAttributes( obj ) ){
            
            var name = i.replace($root.prefix, "");
            var value = objectAttrs[i];
            
            if( $.inArray( i, $wpm.attributes ) !== -1 && i.match($root.prefix) ){
               if( name == "show" || name == "hide" ){}
               else{
                  $wpm[name](obj);
               }
            }
         };
         
         
         obj.removeAttr(""+$root.prefix+"plugin "+$root.prefix+"component "+$root.prefix+"toggle "+$root.prefix+"click "+$root.prefix+"init "+$root.prefix+"class" );
      }); 
   },
   
   plugin: function(obj){

      var plugin = obj.attr($root.prefix+"plugin");
      var attributes = plugin.match(/ *\([^)]*\) */g, "");

      if( attributes ){
         attributes = attributes.toString().replace(/[\(\)]+/g,'').split(", ");
      }else{
         attributes = null;
      }

      plugin = plugin.replace(/ *\([^)]*\) */g, "");

      $root.resizeArray.push( plugin );

      try {
          obj[plugin](attributes);
      }
      catch(err){
          if( $wpm.debug ){
             console.info("The plugin '"+plugin+"' does not exist! Maybe there's a typo in the plugin name?");
          }
      }

   },

   component: function(obj){

      var component = obj.attr($root.prefix+"component");
      var attributes = component.match(/ *\([^)]*\) */g, "");

      if( attributes ){
         attributes = attributes.toString().replace(/[\(\)]+/g,'').split(", ");
      }else{
         attributes = null;
      }

      component = component.replace(/ *\([^)]*\) */g, "");

      $root.resizeArray.push( component );


      try {
          obj[component](attributes);
      }
      catch(err){
          if( $wpm.debug ){
             console.info("The component '"+component+"' does not exist! Maybe there's a typo in the component name?");
          }
      }

   },
   
   click: function(obj){
      var attribute = obj.attr($root.prefix+"click").replace(/ +/g, '').split("=");
      var variable = attribute[0];
      var value = attribute[1];

      
      obj.on("click", function(e){
         e.preventDefault();

         $root[variable] = value;

         if( $wpm.debug ){
            console.log(variable+"="+$root[variable]);
         }

         $root.apply();

      });
   },
   
   class: function(obj){
      var variable = obj.attr($root.prefix+"class").replace(/ +/g, '');
      var className = variable.match(/ *\'[^']*\' */g).toString().replace(/'+/g, '');

      variable = variable.match(/\:(.*)$/g).toString().replace(":", '');

      var value = true;

      if( variable.match("==") ){
         value = variable.split("==")[1];
         variable = variable.split("==")[0];
      }

      if( variable ){
         if( $root.class[variable] ){
            $root.class[variable].push({
               object: obj,
               className: className,
               value: value
            });
         }else{
            $root.class[variable] = [{
               object: obj,
               className: className,
               value: value
            }];
         }
      }
   },
   
   toggle: function(obj){
      var variable = obj.attr($root.prefix+"toggle");

      obj.on("click", function(e){

         e.preventDefault();
         $root[variable] = $root[variable] ? false : true;

         if( variable == "accessibility" ){
            $root['headerSearch'] = false;
         }

         if( variable == "headerSearch" ){
            $root['accessibility'] = false;
         }

         if( $wpm.debug ){
            console.log(variable+"="+$root[variable]);
         }

         $root.apply();

      });
   },
   
   init: function(obj){
      var attribute = obj.attr($root.prefix+"init").replace(/ +/g, '').split("=");
      var variable = attribute[0];
      var value = attribute[1];

      $root[variable] = value;

      if( $wpm.debug ){
         console.log(variable+"="+$root[variable]);
      }
   },

   setStyles: function(obj){

      if( !$root.styleObj ){
         $("body").append( $root.styleObj = $("<style></style>") );
      }

      var styleOutput = '';

      for( var i in $root ){

         if( $root[i] == $root.prefix ){ continue; }
         
         if( typeof $root[i] == "string" ){
            styleOutput+= "* ["+$root.prefix+"show='"+i+" == "+$root[i]+"']{display:block !important;}";
            styleOutput+= "* ["+$root.prefix+"show='"+i+" == "+$root[i]+" | flex']{display:flex !important;}";
            styleOutput+= "* ["+$root.prefix+"show='"+i+" == "+$root[i]+" | inlineBlock']{display:inline-block !important;}";
         }
         else if( typeof $root[i] !== "function" && typeof $root[i] !== "object" ){
            
            var show = $root[i] ? "block" : "none";
            var hide = $root[i] ? "none" : "block";
            
            styleOutput+= "* ["+$root.prefix+"show='"+i+"']{display:"+show+" !important;}";
            styleOutput+= "* ["+$root.prefix+"show='"+i+" | inlineBlock']{display:"+( show == 'block' ? 'inline-block' : 'none') +" !important;}";
            styleOutput+= "* ["+$root.prefix+"show='"+i+" | flex']{display:"+( show == 'block' ? 'flex' : 'none') +" !important;}";
            
            styleOutput+= "* ["+$root.prefix+"hide='"+i+"']{display:"+hide+" !important;}";
         }
      }

      $root.styleObj.text( styleOutput );

      if( $wpm.debug ){
         console.info("New styles generated");  
      }
   },

   setClasses: function(){
      
      for( var i in $root['class'] ){
         var key = i;
         var instance = $root['class'][i];
         
         for( var ii in instance ){
            var entry = instance[ii];

            if( $root[key] == entry['value'] ){
               entry.object.addClass(entry.className);
            }else{
               entry.object.removeClass(entry.className);
            }
         }
      }

      if( $wpm.debug ){
         console.info("Classes toggled!");
      }
   }
}


if( 'jQuery' in window ){

   $(function(){
      $wpm.initialize();
   });
}
else{
   console.warn("jQuery not loaded! Load jQuery before WPM!");
}

})(jQuery);